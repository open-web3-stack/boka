// Generated by SwiftInternals -- DO NOT EDIT
// This file was generated by parsing a Swift AST and modifying it.
// Run `make format` to reformat.

import Foundation
import Logging
import Utils

/// Patricia Trie for state storage
///
/// Structure:
/// - Branch nodes have left and right children (Data32 hashes)
/// - Leaf nodes store key and value directly
/// - Embedded leaves: value <= 32 bytes, stored inline
/// - Regular leaves: value > 32 bytes, stores value hash
enum TrieNodeType: UInt8 {
    case branch = 0
    case embeddedLeaf = 1
    case regularLeaf = 2
}

struct TrieNode {
    let left: Data32  // For branch: left child, for leaf: encoded key
    let right: Data32  // For branch: right child, for leaf: value hash or embedded value
    let type: TrieNodeType
    let hash: Data32
    let isNew: Bool
    let rawValue: Data?  // Cached raw value for leaves

    var isBranch: Bool {
        type == .branch
    }

    var isLeaf: Bool {
        !isBranch
    }

    func isLeaf(key: Data31) -> Bool {
        isLeaf && left.data[relative: 1 ..< 32] == key.data
    }

    var value: Data? {
        if let rawValue {
            return rawValue
        }
        guard type == .embeddedLeaf else {
            return nil
        }
        // For embedded leaves: length is stored in first byte
        let len = Int(left.data[relative: 0])
        let safeLen = min(len, 32)
        return right.data[relative: 0 ..< safeLen]
    }

    static func leaf(key: Data31, value: Data) -> TrieNode {
        if value.count <= 32 {
            // Embedded leaf: store length + key, padded value
            var keyData = Data(capacity: 32)
            keyData.append(UInt8(value.count)) // Store length in first byte
            keyData += key.data
            let paddedValue = value + Data(repeating: 0, count: 32 - value.count)
            return .init(left: Data32(keyData)!, right: Data32(paddedValue)!, type: .embeddedLeaf, isNew: true, rawValue: value)
        } else {
            // Regular leaf: store key, value hash
            var keyData = Data(capacity: 32)
            keyData.append(0x00) // Placeholder for first byte
            keyData += key.data
            return .init(left: Data32(keyData)!, right: value.blake2b256hash(), type: .regularLeaf, isNew: true, rawValue: value)
        }
    }

    static func branch(left: Data32, right: Data32) -> TrieNode {
        .init(left: left, right: right, type: .branch, isNew: true, rawValue: nil)
    }
}

public enum StateTrieError: Error {
    case invalidData
    case invalidParent
}

public actor StateTrie {
    private let backend: StateBackendProtocol
    public private(set) var rootHash: Data32
    private var nodes: [Data: TrieNode] = [:]
    private var deleted: Set<Data> = []
    private var lastSavedRootHash: Data32 // Track last saved root for proper ref counting

    // Performance optimization: LRU cache for frequently accessed nodes
    private let nodeCache: LRUCache<Data, TrieNode>?
    private let cacheStats: CacheStatsTracker?
    private let enableWriteBuffer: Bool
    private var writeBuffer: WriteBuffer?

    private let logger = Logger(label: "StateTrie")

    // MARK: - Bit manipulation utilities

    /// Extract bit at position i from data (MSB first)
    /// i=0 returns the MSB of the first byte
    private static func bitAt(_ data: Data, position: UInt8) -> Bool {
        let byteIndex = Int(position) / 8
        let bitIndex = 7 - (Int(position) % 8)  // MSB first
        guard byteIndex < data.count else {
            return false  // Past end of data, treat as 0
        }
        let byte = data[data.startIndex + byteIndex]
        return (byte & (1 << bitIndex)) != 0
    }

    // MARK: - Initialization

    public init(
        rootHash: Data32,
        backend: StateBackendProtocol,
        config: ProtocolConfigRef = .dev,
        enableCache: Bool = true,
        cacheSize: Int = 100,
        enableWriteBuffer: Bool = true
    ) {
        self.rootHash = rootHash
        self.backend = backend
        self.lastSavedRootHash = rootHash
        self.enableWriteBuffer = enableWriteBuffer

        // Initialize cache if enabled
        if enableCache {
            self.nodeCache = LRUCache(capacity: cacheSize)
            self.cacheStats = CacheStatsTracker()
            self.logger.debug("StateTrie initialized with LRU cache (size: \(cacheSize))")
        } else {
            self.nodeCache = nil
            self.cacheStats = nil
            self.logger.debug("StateTrie initialized without cache")
        }

        // Initialize write buffer if enabled
        if enableWriteBuffer {
            self.writeBuffer = WriteBuffer(
                maxSize: config.maxStateBatchSize,
                maxTime: config.maxStateBatchTime
            )
            self.logger.debug("StateTrie initialized with write buffer")
        }
    }

    // MARK: - Public API

    /// Read a value from the trie
    public func read(key: Data31) async throws -> Data? {
        var currentHash = rootHash

        // Traverse down the trie
        for depth in 0...255 {
            guard let node = try await get(hash: currentHash, bypassCache: false) else {
                return nil
            }

            if node.isBranch {
                // Follow the path based on the key bit
                let bitValue = Self.bitAt(key.data, position: UInt8(depth))
                currentHash = bitValue ? node.right : node.left
            } else {
                // Found a leaf node
                if node.isLeaf(key: key) {
                    return node.value
                } else {
                    return nil  // Key not found (different key at this position)
                }
            }
        }

        // Should not reach here unless we've traversed 256 levels
        return nil
    }

    /// Update trie with multiple key-value pairs
    /// Performance optimizations:
    /// - Write buffering: Phase 2 - Buffer updates before batch I/O
    /// - Parallel processing: Use TaskGroup for independent updates (future)
    /// - Cache optimization: Keep recently accessed nodes in memory
    public func update(_ updates: [(key: Data31, value: Data?)]) async throws {
        // If write buffering is enabled, use buffered updates
        if enableWriteBuffer, let buffer = writeBuffer {
            try await updateBuffered(updates, buffer: buffer)
        } else {
            // Original immediate update path
            for (key, value) in updates {
                if let value {
                    rootHash = try await insert(hash: rootHash, key: key, value: value, depth: 0)
                } else {
                    rootHash = try await delete(hash: rootHash, key: key, depth: 0)
                }
            }
        }
    }

    /// Phase 2: Buffered update implementation
    /// Accumulates updates in buffer and flushes when necessary
    private func updateBuffered(_ updates: [(key: Data31, value: Data?)], buffer: WriteBuffer) async throws {
        for (key, value) in updates {
            // Add to buffer (synchronous since WriteBuffer is no longer an actor)
            let shouldFlush = buffer.add(key: key, value: value)

            // Apply update to in-memory trie
            if let value {
                rootHash = try await insert(hash: rootHash, key: key, value: value, depth: 0)
            } else {
                rootHash = try await delete(hash: rootHash, key: key, depth: 0)
            }

            // Flush if buffer is full or time interval elapsed
            if shouldFlush {
                try await flushWriteBuffer()
            }
        }
    }

    /// Flush write buffer to backend
    private func flushWriteBuffer() async throws {
        guard let buffer = writeBuffer else { return }

        let updates = buffer.flush()
        guard !updates.isEmpty else { return }

        logger.debug("Flushing write buffer with \(updates.count) updates")

        // Apply all updates to backend
        try await backend.update(
            updates.map { ($0.key, $0.value) },
            refUpdate: .setToCurrent,  // Mark new/updated values
            rootHash: rootHash
        )
    }

    /// Save all pending changes to the backend
    public func save() async throws {
        // Flush write buffer first
        try await flushWriteBuffer()

        // Track nodes for ref counting updates
        var newNodes: Set<Data32> = []
        var accessedNodes: Set<Data32> = []

        // Process all new/modified nodes
        for (_, node) in nodes {
            if node.isNew {
                newNodes.insert(node.hash)
            } else {
                accessedNodes.insert(node.hash)
            }
        }

        // Write all nodes to backend
        let writeOps = nodes.values.map { node in
            BackendOp.write(key: node.hash.data.suffix(31), value: node.storageData)
        }

        // Track ref count updates for accessed nodes
        let refUpdateOps = accessedNodes.flatMap { hash in
            [
                BackendOp.refUpdate(key: hash.data.suffix(31), refUpdate: .increment),
                BackendOp.refUpdate(key: hash.data.suffix(31), refUpdate: .decrement),
            ]
        }

        // Track ref count updates for deleted nodes
        let deleteOps = deleted.map { key in
            BackendOp.refUpdate(key: key, refUpdate: .decrement)
        }

        // Combine all operations
        let allOps = writeOps + refUpdateOps + deleteOps

        // Execute batch write
        try await backend.batchWrite(allOps)

        // Update cache for newly written nodes
        for (key, node) in nodes {
            cacheStats?.recordWrite()
            nodeCache?.put(key, value: node)
        }

        // Clear in-memory state
        nodes.removeAll()
        deleted.removeAll()

        // Track the root we just saved
        lastSavedRootHash = rootHash

        logger.debug("Saved trie with \(writeOps.count) node writes, \(refUpdateOps.count) ref updates, \(deleteOps.count) deletes")
    }

    public func flush() async throws {
        try await flushWriteBuffer()
    }

    /// Get write buffer statistics for monitoring and debugging
    public func getWriteBufferStats() -> WriteBufferStats? {
        guard let buffer = writeBuffer else {
            return nil
        }
        return buffer.stats
    }

    /// Clear the write buffer without flushing (use with caution - data loss!)
    /// Only useful for testing or error recovery
    public func clearWriteBuffer() {
        writeBuffer?.clear()
    }

    // MARK: - Recursive Insert (to be converted to iterative)

    private func insert(
        hash: Data32, key: Data31, value: Data, depth: UInt8
    ) async throws -> Data32 {
        guard let parent = try await get(hash: hash) else {
            let node = TrieNode.leaf(key: key, value: value)
            saveNode(node: node)
            return node.hash
        }

        if parent.isBranch {
            removeNode(node: parent)

            let bitValue = Self.bitAt(key.data, position: depth)
            var left = parent.left
            var right = parent.right
            if bitValue {
                right = try await insert(hash: parent.right, key: key, value: value, depth: depth + 1)
            } else {
                left = try await insert(hash: parent.left, key: key, value: value, depth: depth + 1)
            }
            let newBranch = TrieNode.branch(left: left, right: right)
            saveNode(node: newBranch)
            return newBranch.hash
        } else {
            // leaf
            return try await insertLeafNode(existing: parent, newKey: key, newValue: value, depth: depth)
        }
    }

    private func insertLeafNode(existing: TrieNode, newKey: Data31, newValue: Data, depth: UInt8) async throws -> Data32 {
        if existing.isLeaf(key: newKey) {
            // update existing leaf
            removeNode(node: existing)
            let newLeaf = TrieNode.leaf(key: newKey, value: newValue)
            saveNode(node: newLeaf)
            return newLeaf.hash
        }

        let existingKeyBit = Self.bitAt(existing.left.data[relative: 1...], position: depth)
        let newKeyBit = Self.bitAt(newKey.data, position: depth)

        if existingKeyBit == newKeyBit {
            // need to go deeper
            let childNodeHash = try await insertLeafNode(
                existing: existing, newKey: newKey, newValue: newValue, depth: depth + 1
            )
            let newBranch = if existingKeyBit {
                TrieNode.branch(left: Data32(), right: childNodeHash)
            } else {
                TrieNode.branch(left: childNodeHash, right: Data32())
            }
            saveNode(node: newBranch)
            return newBranch.hash
        } else {
            let newLeaf = TrieNode.leaf(key: newKey, value: newValue)
            saveNode(node: newLeaf)
            let newBranch = if existingKeyBit {
                TrieNode.branch(left: newLeaf.hash, right: existing.hash)
            } else {
                TrieNode.branch(left: existing.hash, right: newLeaf.hash)
            }
            saveNode(node: newBranch)
            return newBranch.hash
        }
    }

    // MARK: - Recursive Delete (to be converted to iterative)

    private func delete(hash: Data32, key: Data31, depth: UInt8) async throws -> Data32 {
        let node = try await get(hash: hash)
        guard let node else {
            return Data32()
        }

        if node.isBranch {
            removeNode(node: node)

            let bitValue = Self.bitAt(key.data, position: depth)
            var left = node.left
            var right = node.right

            if bitValue {
                right = try await delete(hash: node.right, key: key, depth: depth + 1)
            } else {
                left = try await delete(hash: node.left, key: key, depth: depth + 1)
            }

            if left == Data32(), right == Data32() {
                // this branch is empty
                return Data32()
            } else if left == Data32() {
                // only right child remains
                if let rightNode = try await get(hash: right), rightNode.isLeaf {
                    return right
                }
            } else if right == Data32() {
                // only left child remains
                if let leftNode = try await get(hash: left), leftNode.isLeaf {
                    return left
                }
            }

            let newBranch = TrieNode.branch(left: left, right: right)
            saveNode(node: newBranch)
            return newBranch.hash
        } else {
            // leaf
            if node.isLeaf(key: key) {
                removeNode(node: node)
                return Data32()
            } else {
                // key not found
                return hash
            }
        }
    }

    // MARK: - Node Management

    private func get(hash: Data32, bypassCache: Bool = false, prefetchSiblings: Bool = true) async throws -> TrieNode? {
        if hash == Data32() {
            return nil
        }
        let id = hash.data.suffix(31)
        if deleted.contains(id) {
            return nil
        }

        // Check in-memory nodes first (current operation)
        if let node = nodes[id] {
            // Phase 2 Week 4: Prefetch siblings when returning cached node
            if prefetchSiblings, node.isBranch {
                // Prefetch both children asynchronously (don't await)
                Task {
                    _ = try? await get(hash: node.left, bypassCache: false, prefetchSiblings: false)
                    _ = try? await get(hash: node.right, bypassCache: false, prefetchSiblings: false)
                }
            }
            return node
        }

        // Check cache (only if not bypassing)
        if !bypassCache, let cached = nodeCache?.get(id) {
            cacheStats?.recordHit()
            // Don't save loaded nodes to nodes map - they're already persisted
            // and don't need ref count updates (only new nodes do)
            return cached
        }

        // Load from backend
        guard let data = try await backend.get(hash) else {
            return nil
        }

        let node = try TrieNode.from(storageData: data, hash: hash)

        cacheStats?.recordMiss()
        nodeCache?.put(id, value: node)

        // Don't save loaded nodes to nodes map - they're already persisted
        // and don't need ref count updates (only new nodes do)
        return node
    }

    private func saveNode(node: TrieNode) {
        let id = node.hash.data.suffix(31)
        nodes[id] = node
        deleted.remove(id)
    }

    private func removeNode(node: TrieNode) {
        let id = node.hash.data.suffix(31)
        deleted.insert(id)

        // Only remove from nodes map if it's a new node (never persisted)
        // For persisted nodes, we need to keep them in memory until save() processes
        // the deletion
        if node.isNew {
            nodes.removeValue(forKey: id)
        }
    }

    public func debugPrint() async throws {
        func printNode(_ hash: Data32, depth: UInt8) async throws {
            let prefix = String(repeating: " ", count: Int(depth))
            if hash == Data32() {
                logger.info("\(prefix) nil")
                return
            }
            let node = try await get(hash: hash)
            guard let node else {
                return logger.info("\(prefix) ????")
            }

            if node.isBranch {
                logger.info("\(prefix) BRANCH \(hash)")
                try await printNode(node.left, depth: depth + 1)
                try await printNode(node.right, depth: depth + 1)
            } else {
                logger.info("\(prefix) LEAF \(hash) = \(node.value?.toHexString() ?? "nil")")
            }
        }

        logger.info("=== StateTrie ===")
        try await printNode(rootHash, depth: 0)
        logger.info("================")
    }

    // MARK: - Cache Statistics

    public func getCacheStats() -> (hits: Int, misses: Int, hitRate: Double)? {
        guard let stats = cacheStats else { return nil }
        return (hits: stats.hits, misses: stats.misses, hitRate: stats.hitRate)
    }
}

// MARK: - TrieNode Storage Support

extension TrieNode {
    /// 65-byte storage format: [type:1][left:32][right:32]
    var storageData: Data {
        var data = Data(capacity: 65)
        data.append(type.rawValue)
        data.append(left.data)
        data.append(right.data)
        return data
    }

    static func from(storageData: Data, hash: Data32) throws -> TrieNode {
        guard storageData.count == 65 else {
            throw StateTrieError.invalidData
        }

        let typeValue = storageData[0]
        guard let type = TrieNodeType(rawValue: typeValue) else {
            throw StateTrieError.invalidData
        }

        let left = Data32(storageData[1...32])!
        let right = Data32(storageData[33...64])!

        // For embedded leaves, cache the raw value
        var rawValue: Data?
        if type == .embeddedLeaf {
            let len = Int(left.data[relative: 0])
            rawValue = right.data[relative: 0 ..< min(len, 32)]
        }

        return .init(left: left, right: right, type: type, hash: hash, isNew: false, rawValue: rawValue)
    }

    // JAM spec compliant hash calculation
    private static func calculateHash(left: Data32, right: Data32, type: TrieNodeType) -> Data32 {
        switch type {
        case .branch:
            var leftForHashing = left.data
            leftForHashing[leftForHashing.startIndex] = leftForHashing[leftForHashing.startIndex] & 0b0111_1111
            return Blake2b256.hash(leftForHashing, right.data)
        case .embeddedLeaf:
            var leftForHashing = left.data
            let valueLength = leftForHashing[leftForHashing.startIndex]
            leftForHashing[leftForHashing.startIndex] = 0b1000_0000 | valueLength
            return Blake2b256.hash(leftForHashing, right.data)
        case .regularLeaf:
            var leftForHashing = left.data
            leftForHashing[leftForHashing.startIndex] = 0b1100_0000
            return Blake2b256.hash(leftForHashing, right.data)
        }
    }
}
