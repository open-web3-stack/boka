import blst
import Foundation

/// A wrapper to blst C library.
///
/// `blst_p1` for public keys, and `blst_p2` for signatures
public enum BLS: KeyType {
    public enum Error: Swift.Error {
        case blstError(BLST_ERROR)
    }

    public final class SecretKey: SecretKeyProtocol, @unchecked Sendable {
        private var sk: blst_scalar

        public let publicKey: PublicKey

        /// Initiate a BLS secret key with IKM.
        /// IKM MUST be infeasible to guess, e.g., generated by a trusted source of randomness.
        /// IKM MUST be at least 32 bytes long, but it MAY be longer.
        public init(from ikm: Data32) throws {
            sk = blst_scalar()

            // avoid capture self
            withUnsafeMutablePointer(to: &sk) { sk in
                ikm.data.withUnsafeBytes { ptr in
                    blst_keygen(sk, ptr.baseAddress, ikm.data.count, nil, 0)
                }
            }

            var pk = blst_p1()
            blst_sk_to_pk_in_g1(&pk, &sk)

            publicKey = PublicKey(pk: &pk)
        }

        public func sign(message: Data) -> Data96 {
            var msgHash = blst_p2()

            message.withUnsafeBytes { ptr in
                blst_hash_to_g2(&msgHash, ptr.baseAddress, ptr.count, nil, 0, nil, 0)
            }

            var sig = blst_p2()
            blst_sign_pk_in_g1(&sig, &msgHash, &sk)

            var sigBytes = Data(repeating: 0, count: 96)
            sigBytes.withUnsafeMutableBytes { ptr in
                blst_p2_compress(ptr.baseAddress, &sig)
            }

            return Data96(sigBytes)!
        }
    }

    public final class PublicKey: PublicKeyProtocol, @unchecked Sendable {
        // this is immutable after initialization but C API requires it to be mutable
        fileprivate var pk = blst_p1_affine()
        public let data: Data48

        fileprivate init(pk: inout blst_p1) {
            var data = Data(repeating: 0, count: 48)

            data.withUnsafeMutableBytes { ptr in
                blst_p1_compress(ptr.baseAddress, &pk)
            }

            blst_p1_to_affine(&self.pk, &pk)
            self.data = Data48(data)!
        }

        public init(from data: Data48) throws {
            self.data = data

            try data.data.withUnsafeBytes { ptr in
                let result = blst_p1_uncompress(&pk, ptr.baseAddress)
                guard result == BLST_SUCCESS else {
                    throw Error.blstError(result)
                }
            }
        }

        public convenience init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            let data = try container.decode(Data48.self)
            try self.init(from: data)
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            try container.encode(data)
        }

        public func hash(into hasher: inout Hasher) {
            hasher.combine(data)
        }

        public static func == (lhs: PublicKey, rhs: PublicKey) -> Bool {
            lhs.data == rhs.data
        }

        public var description: String {
            "0x\(data.toHexString())"
        }

        public func verify(signature: Data96, message: Data) -> Bool {
            var sig = blst_p2_affine()

            let res = signature.data.withUnsafeBytes { ptr in
                blst_p2_uncompress(&sig, ptr.baseAddress)
            }

            guard res == BLST_SUCCESS else {
                return false
            }

            let verifyResult = message.withUnsafeBytes { ptr in
                blst_core_verify_pk_in_g1(
                    &pk, &sig, true, ptr.baseAddress, ptr.count, nil, 0, nil, 0
                )
            }

            return verifyResult == BLST_SUCCESS
        }
    }

    public static func aggregateVerify(
        signature: Data96, messages: [Data], publicKeys: [PublicKey]
    ) -> Bool {
        if messages.count != publicKeys.count {
            return false
        }

        let size = blst_pairing_sizeof()
        let ctx = OpaquePointer(malloc(size))
        defer { free(UnsafeMutableRawPointer(ctx)) }

        blst_pairing_init(ctx, true, nil, 0)

        var sig = blst_p2_affine()
        let sigResult = blst_p2_uncompress(&sig, [UInt8](signature.data))
        guard sigResult == BLST_SUCCESS else {
            return false
        }

        var first = true
        for (key, message) in zip(publicKeys, messages) {
            let res = message.withUnsafeBytes { ptr in
                if first {
                    blst_pairing_aggregate_pk_in_g1(
                        ctx, &key.pk, &sig, ptr.baseAddress, ptr.count, nil, 0
                    )
                } else {
                    blst_pairing_aggregate_pk_in_g1(
                        ctx, &key.pk, nil, ptr.baseAddress, ptr.count, nil, 0
                    )
                }
            }
            guard res == BLST_SUCCESS else {
                return false
            }

            first = false
        }

        blst_pairing_commit(ctx)
        return blst_pairing_finalverify(ctx, nil)
    }

    public static func aggregateSignatures(signatures: [Data96]) throws -> Data96 {
        var aggregate = blst_p2()

        for signature in signatures {
            var sig = blst_p2_affine()
            try signature.data.withUnsafeBytes { ptr in
                let sigResult = blst_p2_uncompress(&sig, ptr.baseAddress)
                guard sigResult == BLST_SUCCESS else {
                    throw Error.blstError(sigResult)
                }
            }
            // silance the memory overlapping accessing warning
            // as this is supported by the C API
            withUnsafeMutablePointer(to: &aggregate) { ptr in
                blst_p2_add_or_double_affine(ptr, ptr, &sig)
            }
        }

        var sigCompressed = Data(repeating: 0, count: 96)
        sigCompressed.withUnsafeMutableBytes { ptr in
            blst_p2_compress(ptr.baseAddress, &aggregate)
        }
        return Data96(sigCompressed)!
    }
}
