// generated by polka.codes
// PVM Instruction Opcodes
//
// Centralized opcode definitions for PolkaVM bytecode instructions.
// These opcodes MUST match the instruction decoder and emitter implementations.

#pragma once

#include <cstdint>

namespace PVM {

/// PVM instruction opcodes
/// These values define the operation code for each instruction type in the PolkaVM bytecode.
enum class Opcode : uint8_t {
    // Control Flow Instructions
    Trap = 0,           // Trap - stop execution with error
    Halt = 1,           // Fallthrough - normal termination
    Jump = 40,          // Unconditional jump to offset
    JumpInd = 50,       // Indirect jump through register
    LoadImmJump = 80,    // Load immediate and jump

    // Load Immediate Instructions
    LoadImm = 51,       // LoadImm (32-bit immediate)
    LoadImmU64 = 20,     // LoadImm64 (64-bit immediate)

    // Load Instructions
    LoadU8 = 52,         // Load unsigned 8-bit
    LoadI8 = 53,         // Load signed 8-bit
    LoadU16 = 54,        // Load unsigned 16-bit
    LoadI16 = 55,        // Load signed 16-bit
    LoadU32 = 56,        // Load unsigned 32-bit
    LoadI32 = 57,        // Load signed 32-bit
    LoadU64 = 58,        // Load unsigned 64-bit

    // Store Instructions
    StoreU8 = 59,        // Store unsigned 8-bit
    StoreU16 = 60,       // Store unsigned 16-bit
    StoreU32 = 61,       // Store unsigned 32-bit
    StoreU64 = 62,       // Store unsigned 64-bit
    StoreImmU8 = 30,     // Store immediate unsigned 8-bit
    StoreImmU16 = 31,    // Store immediate unsigned 16-bit
    StoreImmU32 = 32,    // Store immediate unsigned 32-bit
    StoreImmU64 = 33,    // Store immediate unsigned 64-bit

    // Branch Instructions
    BranchEq = 170,     // Branch if equal
    BranchNe = 171,     // Branch if not equal
    BranchEqImm = 173,  // Branch if equal (immediate)
    BranchNeImm = 174,  // Branch if not equal (immediate)

    // 32-bit Arithmetic Instructions
    Add32 = 190,        // Add 32-bit
    Sub32 = 191,        // Subtract 32-bit
    Mul32 = 192,        // Multiply 32-bit
    DivU32 = 193,       // Divide unsigned 32-bit
    DivS32 = 194,       // Divide signed 32-bit
    RemU32 = 195,       // Remainder unsigned 32-bit
    RemS32 = 196,       // Remainder signed 32-bit

    // 64-bit Arithmetic Instructions
    Add64 = 200,        // Add 64-bit
    Sub64 = 201,        // Subtract 64-bit
    Mul64 = 202,        // Multiply 64-bit
    DivU64 = 203,       // Divide unsigned 64-bit (Note: implementation uses different opcode)
    DivS64 = 204,       // Divide signed 64-bit
    RemU64 = 205,       // Remainder unsigned 64-bit
    RemS64 = 206,       // Remainder signed 64-bit

    // Bitwise Operations
    And = 210,          // Bitwise AND
    Xor = 211,          // Bitwise XOR
    Or = 212,           // Bitwise OR
};

// Instruction size constants (in bytes)
namespace InstructionSize {
    constexpr uint32_t Trap = 1;
    constexpr uint32_t Halt = 1;
    constexpr uint32_t Jump = 5;           // [opcode][offset_32bit]
    constexpr uint32_t JumpInd = 2;        // [opcode][reg_index]
    constexpr uint32_t LoadImmJump = 10;   // [opcode][reg_index][offset_32bit][value_32bit]

    constexpr uint32_t LoadImm = 6;        // [opcode][reg_index][value_32bit]
    constexpr uint32_t LoadImm64 = 10;     // [opcode][reg_index][value_64bit]

    constexpr uint32_t LoadU8 = 6;         // [opcode][reg_index][address_32bit]
    constexpr uint32_t LoadU16 = 6;
    constexpr uint32_t LoadU32 = 6;
    constexpr uint32_t LoadU64 = 6;

    constexpr uint32_t StoreU8 = 6;        // [opcode][reg_index][address_32bit]
    constexpr uint32_t StoreU16 = 6;
    constexpr uint32_t StoreU32 = 6;
    constexpr uint32_t StoreU64 = 6;

    constexpr uint32_t StoreImmU8 = 6;     // [opcode][value_8bit][address_32bit]
    constexpr uint32_t StoreImmU16 = 7;    // [opcode][value_16bit][address_32bit]
    constexpr uint32_t StoreImmU32 = 9;    // [opcode][value_32bit][address_32bit]
    constexpr uint32_t StoreImmU64 = 13;   // [opcode][value_64bit][address_32bit]

    constexpr uint32_t BranchEq = 7;       // [opcode][reg1][reg2][offset_32bit]
    constexpr uint32_t BranchNe = 7;
    constexpr uint32_t BranchEqImm = 7;   // [opcode][offset_32bit]
    constexpr uint32_t BranchNeImm = 7;   // [opcode][offset_32bit]

    constexpr uint32_t Arithmetic32 = 3;  // [opcode][dest_reg][src_reg]
    constexpr uint32_t Arithmetic64 = 3;

    constexpr uint32_t Bitwise = 3;        // [opcode][dest_reg][src_reg]
}

// Helper functions for opcode comparison
// These avoid repetitive static_cast<Opcode>(opcode) in the code
inline bool opcode_is(uint8_t opcode, Opcode target) {
    return static_cast<Opcode>(opcode) == target;
}

} // namespace PVM
