// generated by polka.codes
// Label-based control flow instructions for JIT compilation
// Implements direct jumps for maximum performance

#include "jit_control_flow.hh"
#include "jit_label_manager.hh"
#include <asmjit/a64.h>
#include <asmjit/x86.h>
#include <asmjit/core.h>
#include <cstring>

using namespace asmjit;
using namespace asmjit::x86;

namespace JIT {

// BranchEq: Branch if equal (register-register) with label support
bool jit_emit_branch_eq_labeled(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    uint8_t src1_reg,
    uint8_t src2_reg,
    Label target_label) noexcept
{
    if (strcmp(target_arch, "x86_64") == 0) {
        auto* a = static_cast<x86::Assembler*>(assembler);

        // Load src1 from VM array (VM_REGISTERS_PTR in rbx)
        a->mov(x86::rax, x86::qword_ptr(x86::rbx, src1_reg * 8));

        // Load src2 from VM array
        a->mov(x86::rdx, x86::qword_ptr(x86::rbx, src2_reg * 8));

        // Compare registers
        a->cmp(x86::rax, x86::rdx);

        // Conditional jump if equal to target label
        a->je(target_label);

        // If not equal, execution falls through to next instruction
        return true;

    } else if (strcmp(target_arch, "aarch64") == 0) {
        auto* a = static_cast<a64::Assembler*>(assembler);

        // Load src1 from VM array (VM_REGISTERS_PTR in x19)
        a64::Gp src1 = a64::x0;
        a64::Gp src2 = a64::x1;
        a64::Gp regPtr = a64::x19;

        a->ldr(src1, a64::ptr(regPtr, src1_reg * 8));
        a->ldr(src2, a64::ptr(regPtr, src2_reg * 8));

        // Compare registers
        a->cmp(src1, src2);

        // Conditional branch if equal to target label
        a->b_eq(target_label);

        return true;
    }

    return false;
}

// BranchNe: Branch if not equal (register-register) with label support
bool jit_emit_branch_ne_labeled(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    uint8_t src1_reg,
    uint8_t src2_reg,
    Label target_label) noexcept
{
    if (strcmp(target_arch, "x86_64") == 0) {
        auto* a = static_cast<x86::Assembler*>(assembler);

        // Load src1 from VM array (VM_REGISTERS_PTR in rbx)
        a->mov(x86::rax, x86::qword_ptr(x86::rbx, src1_reg * 8));

        // Load src2 from VM array
        a->mov(x86::rdx, x86::qword_ptr(x86::rbx, src2_reg * 8));

        // Compare registers
        a->cmp(x86::rax, x86::rdx);

        // Conditional jump if not equal to target label
        a->jne(target_label);

        // If equal, execution falls through to next instruction
        return true;

    } else if (strcmp(target_arch, "aarch64") == 0) {
        auto* a = static_cast<a64::Assembler*>(assembler);

        // Load src1 from VM array (VM_REGISTERS_PTR in x19)
        a64::Gp src1 = a64::x0;
        a64::Gp src2 = a64::x1;
        a64::Gp regPtr = a64::x19;

        a->ldr(src1, a64::ptr(regPtr, src1_reg * 8));
        a->ldr(src2, a64::ptr(regPtr, src2_reg * 8));

        // Compare registers
        a->cmp(src1, src2);

        // Conditional branch if not equal to target label
        a->b_ne(target_label);

        return true;
    }

    return false;
}

// Unconditional jump to label
bool jit_emit_jump_labeled(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    Label target_label) noexcept
{
    if (strcmp(target_arch, "x86_64") == 0) {
        auto* a = static_cast<x86::Assembler*>(assembler);
        a->jmp(target_label);
        return true;

    } else if (strcmp(target_arch, "aarch64") == 0) {
        auto* a = static_cast<a64::Assembler*>(assembler);
        a->b(target_label);
        return true;
    }

    return false;
}

// Load immediate and jump to label
bool jit_emit_load_imm_jump_labeled(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    uint8_t dest_reg,
    uint32_t immediate,
    Label target_label) noexcept
{
    if (strcmp(target_arch, "x86_64") == 0) {
        auto* a = static_cast<x86::Assembler*>(assembler);

        // Load immediate into destination register (zero-extended)
        // Use mov to register first to ensure zero-extension (not sign-extension)
        a->mov(x86::rax, immediate);
        a->mov(x86::qword_ptr(x86::rbx, dest_reg * 8), x86::rax);

        // Unconditional jump to target
        a->jmp(target_label);

        return true;

    } else if (strcmp(target_arch, "aarch64") == 0) {
        auto* a = static_cast<a64::Assembler*>(assembler);

        a64::Gp regPtr = a64::x19;

        // Load immediate into temporary register
        a64::Gp temp = a64::x0;
        a->mov(temp, immediate);

        // Store to destination register
        a->str(temp, a64::ptr(regPtr, dest_reg * 8));

        // Unconditional branch to target
        a->b(target_label);

        return true;
    }

    return false;
}

// Indirect jump (JumpInd) - complex case
// This requires either a jump table or dispatcher approach
// For now, we'll keep the old PC-based behavior for indirect jumps
bool jit_emit_jump_indirect_labeled(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    uint8_t reg_index,
    JIT::LabelManager* label_manager,
    const uint8_t* _Nonnull bytecode,
    uint32_t bytecode_size) noexcept
{
    // TODO: Implement jump table approach for indirect jumps
    // For now, this is a stub that maintains compatibility
    // Indirect jumps will need special handling

    if (strcmp(target_arch, "x86_64") == 0) {
        auto* a = static_cast<x86::Assembler*>(assembler);

        // Load target PC from register
        a->mov(x86::eax, x86::dword_ptr(x86::rbx, reg_index * 8));

        // Store to PC register (r15d)
        a->mov(x86::r15d, x86::eax);

        // For now, we need to return to a dispatcher
        // This is why indirect jumps are complex
        // TODO: Implement jump table approach

        return true;
    } else if (strcmp(target_arch, "aarch64") == 0) {
        auto* a = static_cast<a64::Assembler*>(assembler);

        a64::Gp regPtr = a64::x19;
        a64::Gp pcReg = a64::w23;

        // Load target PC from register
        a64::Gp temp = a64::w0;
        a->ldr(temp, a64::ptr(regPtr, reg_index * 8));

        // Store to PC
        a->mov(pcReg, temp);

        // TODO: Implement jump table approach for ARM64

        return true;
    }

    return false;
}

} // namespace JIT
