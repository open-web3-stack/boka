// generated by polka.codes
// Label-based x86_64 JIT compilation for PolkaVM
// Single-pass compilation with lazy label creation for maximum performance

#include "helper.hh"
#include "jit_label_manager.hh"
#include "jit_control_flow.hh"
#include "a64_helper.hh"
#include <asmjit/asmjit.h>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <stdio.h>
#include <vector>

using namespace asmjit;
using namespace asmjit::x86;
using namespace JIT;

// External declaration for the instruction emitter
extern "C" bool jit_emitter_emit_basic_block_instructions(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    const uint8_t* _Nonnull bytecode,
    uint32_t start_pc,
    uint32_t end_pc);

// Helper to get instruction size
static uint32_t getInstructionSize(const uint8_t* bytecode, uint32_t pc, size_t bytecode_size) {
    return get_instruction_size(bytecode, pc, bytecode_size);
}

// Helper to extract jump target from instruction
static uint32_t getJumpTarget(const uint8_t* bytecode, uint32_t pc, uint32_t instrSize) {
    if (instrSize == 5 || instrSize == 7) {
        // Jump (5 bytes): [opcode][offset_32bit]
        // Branch (7 bytes): [opcode][reg1][reg2][offset_32bit]
        uint32_t offset;
        if (instrSize == 5) {
            memcpy(&offset, &bytecode[pc + 1], 4);
        } else {
            memcpy(&offset, &bytecode[pc + 3], 4);
        }
        return pc + instrSize + int32_t(offset);
    }
    return pc + instrSize; // Fallthrough
}

// Main compilation function with labels
extern "C" int32_t compilePolkaVMCode_x64_labeled(
    const uint8_t* _Nonnull codeBuffer,
    size_t codeSize,
    uint32_t initialPC,
    uint32_t jitMemorySize,
    void* _Nullable * _Nonnull funcOut)
{
    // Validate inputs
    if (!codeBuffer || codeSize == 0) {
        return 1; // Invalid input
    }

    if (!funcOut) {
        return 2; // Invalid output parameter
    }

    // Initialize asmjit runtime
    static JitRuntime runtime;
    CodeHolder code;
    code.init(runtime.environment());

    // Create x86 assembler
    x86::Assembler a(&code);

    // Prologue: save callee-saved registers
    a.push(rbx);
    a.push(rbp);
    a.push(r12);
    a.push(r13);
    a.push(r14);
    a.push(r15);

    // Setup VM environment registers
    a.mov(rbx, rdi);  // registers_ptr -> rbx
    a.mov(r12, rsi);  // memory_base_ptr -> r12
    a.mov(r13d, edx); // memory_size -> r13d
    a.mov(r14, rcx);  // gas_ptr -> r14
    a.mov(r15d, r8d); // initial_pvm_pc -> r15d (PC)
    a.mov(rbp, r9);   // invocation_context_ptr -> rbp

    // Create label manager
    LabelManager labelManager;

    // Create exit label
    Label exitLabel = a.newLabel();

    // === PRE-PASS: Identify all jump targets ===
    // This is necessary to handle backward jumps (loops)
    uint32_t pc = 0;
    while (pc < codeSize) {
        uint8_t opcode = codeBuffer[pc];
        uint32_t instrSize = getInstructionSize(codeBuffer, pc, codeSize);

        if (instrSize == 0) {
            // Unknown opcode - stop pre-pass
            break;
        }

        // Mark jump targets for control flow instructions
        if (opcode == 40) { // Jump
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);
            labelManager.markJumpTarget(targetPC);
        } else if (opcode == 170 || opcode == 171) { // BranchEq, BranchNe
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);
            labelManager.markJumpTarget(targetPC);
        } else if (opcode == 6) { // LoadImmJump
            uint8_t destReg = codeBuffer[pc + 1];
            uint32_t immediate;
            memcpy(&immediate, &codeBuffer[pc + 2], 4);
            uint32_t targetPC = pc + instrSize + int32_t(immediate);
            labelManager.markJumpTarget(targetPC);
        }

        pc += instrSize;
    }

    // === MAIN COMPILATION PASS ===
    pc = 0;
    std::vector<uint32_t> compiledPCs;

    while (pc < codeSize) {
        uint8_t opcode = codeBuffer[pc];
        uint32_t instrSize = getInstructionSize(codeBuffer, pc, codeSize);

        if (instrSize == 0) {
            // Unknown opcode - stop compilation
            break;
        }

        // Check if this PC is a jump target (from pre-pass or previous branch)
        // Bind label here if so
        if (labelManager.isMarkedTarget(pc) || labelManager.isJumpTarget(pc)) {
            labelManager.bindLabel(&a, pc, "x86_64");
        }

        // Handle control flow instructions with labels
        if (opcode == 40) { // Jump
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);
            Label targetLabel = labelManager.getOrCreateLabel(&a, targetPC, "x86_64");
            jit_emit_jump_labeled(&a, "x86_64", targetLabel);
            pc += instrSize;
            continue;
        }

        if (opcode == 170) { // BranchEq
            uint8_t reg1 = codeBuffer[pc + 1];
            uint8_t reg2 = codeBuffer[pc + 2];
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);

            Label targetLabel = labelManager.getOrCreateLabel(&a, targetPC, "x86_64");
            jit_emit_branch_eq_labeled(&a, "x86_64", reg1, reg2, targetLabel);

            pc += instrSize;
            continue;
        }

        if (opcode == 171) { // BranchNe
            uint8_t reg1 = codeBuffer[pc + 1];
            uint8_t reg2 = codeBuffer[pc + 2];
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);

            Label targetLabel = labelManager.getOrCreateLabel(&a, targetPC, "x86_64");
            jit_emit_branch_ne_labeled(&a, "x86_64", reg1, reg2, targetLabel);

            pc += instrSize;
            continue;
        }

        if (opcode == 6) { // LoadImmJump
            uint8_t destReg = codeBuffer[pc + 1];
            uint32_t immediate;
            memcpy(&immediate, &codeBuffer[pc + 2], 4);
            uint32_t targetPC = pc + instrSize + int32_t(immediate);

            Label targetLabel = labelManager.getOrCreateLabel(&a, targetPC, "x86_64");
            jit_emit_load_imm_jump_labeled(&a, "x86_64", destReg, immediate, targetLabel);

            pc += instrSize;
            continue;
        }

        if (opcode == 0) { // Trap
            // In labeled compilation, we jump directly to exit
            // rather than emitting a trap instruction
            a.jmp(exitLabel);
            pc += instrSize;
            continue;
        }

        if (opcode == 1) { // Fallthrough (halt)
            // Jump to exit
            a.jmp(exitLabel);
            pc += instrSize;
            continue;
        }

        // For all other instructions, use the existing dispatcher
        // but only for this single instruction
        if (!jit_emitter_emit_basic_block_instructions(&a, "x86_64", codeBuffer, pc, pc + instrSize)) {
            return 3; // Compilation error
        }

        pc += instrSize;
    }

    // Bind exit label
    a.bind(exitLabel);

    // Epilogue: restore callee-saved registers and return
    a.pop(r15);
    a.pop(r14);
    a.pop(r13);
    a.pop(r12);
    a.pop(rbp);
    a.pop(rbx);
    a.ret();

    // Generate the function code
    Error err = runtime.add(funcOut, &code);
    if (err) {
        return int32_t(err);
    }

    return 0; // Success
}

// ARM64 version - implemented in a64_labeled_helper.cpp
// Declaration is in a64_helper.hh
