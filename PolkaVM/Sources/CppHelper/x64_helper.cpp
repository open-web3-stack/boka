// generated by polka.codes
#include "helper.hh"
#include <asmjit/x86.h>
#include <asmjit/asmjit.h>
#include <iostream>
#include <stdio.h>
#include <cstring>

using namespace asmjit;

// Static register mapping for x86_64
namespace {
    // VM state registers (using callee-saved registers)
    const x86::Gp VM_REGISTERS_PTR = x86::rbx;  // Guest VM registers array
    const x86::Gp VM_MEMORY_PTR = x86::r12;     // Guest VM memory base
    const x86::Gp VM_MEMORY_SIZE = x86::r13d;   // Guest VM memory size (32-bit)
    const x86::Gp VM_GAS_PTR = x86::r14;        // Guest VM gas counter
    const x86::Gp VM_PC = x86::r15d;            // Guest VM program counter (32-bit)
    const x86::Gp VM_CONTEXT_PTR = x86::rbp;    // Invocation context pointer

    // Temporary registers (caller-saved)
    const x86::Gp TEMP_REG0 = x86::rax;         // General purpose temp
    const x86::Gp TEMP_REG1 = x86::r10;         // General purpose temp
    const x86::Gp TEMP_REG2 = x86::r11;         // General purpose temp

    // Parameter registers (System V AMD64 ABI)
    const x86::Gp PARAM_REG0 = x86::rdi;        // First parameter
    const x86::Gp PARAM_REG1 = x86::rsi;        // Second parameter
    const x86::Gp PARAM_REG2 = x86::rdx;        // Third parameter
    const x86::Gp PARAM_REG3 = x86::rcx;        // Fourth parameter
    const x86::Gp PARAM_REG4 = x86::r8;         // Fifth parameter
    const x86::Gp PARAM_REG5 = x86::r9;         // Sixth parameter
}

int32_t compilePolkaVMCode_x64(
    const uint8_t* codeBuffer,
    size_t codeSize,
    uint32_t initialPC,
    uint32_t jitMemorySize,
    void** funcOut) {

    if (codeBuffer == nullptr || codeSize == 0) {
        std::cerr << "Error (x86_64): codeBuffer is null or codeSize is 0." << std::endl;
        return 1; // Invalid input error
    }
    if (funcOut == nullptr) {
        std::cerr << "Error (x86_64): funcOut is null." << std::endl;
        return 2; // Invalid output parameter
    }
    *funcOut = nullptr;

    JitRuntime rt;
    CodeHolder code;
    Environment env;

    env.setArch(asmjit::Arch::kX64);
    // TODO: Configure CPU features if targeting specific x86_64 extensions (AVX, etc.)

    Error err = code.init(env);
    if (err) {
        fprintf(stderr, "AsmJit (x86_64) failed to initialize CodeHolder: %s\n",
                DebugUtils::errorAsString(err));
        return err;
    }

    x86::Assembler a(&code);
    Label L_HostCallSuccessful = a.newLabel();
    Label L_HostCallFailedPathReturn = a.newLabel();
    Label L_MainLoop = a.newLabel();
    Label L_ExitSuccess = a.newLabel();
    Label L_ExitOutOfGas = a.newLabel();
    Label L_ExitPanic = a.newLabel();

    // Function prologue - save callee-saved registers that we'll use
    a.push(VM_REGISTERS_PTR);  // rbx
    a.push(VM_CONTEXT_PTR);    // rbp
    a.push(VM_MEMORY_PTR);     // r12
    a.push(VM_MEMORY_SIZE.r64());  // r13
    a.push(VM_GAS_PTR);        // r14
    a.push(VM_PC.r64());       // r15

    // Initialize our static register mapping from function parameters
    // System V AMD64 ABI: rdi, rsi, rdx, rcx, r8, r9
    a.mov(VM_REGISTERS_PTR, PARAM_REG0);  // rdi: registers_ptr
    a.mov(VM_MEMORY_PTR, PARAM_REG1);     // rsi: memory_base_ptr
    a.mov(VM_MEMORY_SIZE, PARAM_REG2.r32());  // edx: memory_size
    a.mov(VM_GAS_PTR, PARAM_REG3);        // rcx: gas_ptr
    a.mov(VM_PC, PARAM_REG4.r32());       // r8d: initial_pvm_pc
    a.mov(VM_CONTEXT_PTR, PARAM_REG5);    // r9: invocation_context_ptr

    // Main instruction execution loop
    a.bind(L_MainLoop);

	// TODO: ???

    // Check if we should continue execution
    // For now, we'll just loop back to the main loop
    a.jmp(L_MainLoop);

    // Exit paths

    // Success exit path
    a.bind(L_ExitSuccess);
    a.mov(TEMP_REG0.r32(), 0); // Return ExitReason.Halt
    a.jmp(L_HostCallFailedPathReturn);

    // Out of gas exit path
    a.bind(L_ExitOutOfGas);
    a.mov(TEMP_REG0.r32(), 2); // Return ExitReason.OutOfGas
    a.jmp(L_HostCallFailedPathReturn);

    // Panic exit path
    a.bind(L_ExitPanic);
    a.mov(TEMP_REG0.r32(), 1); // Return ExitReason.Panic

    // Common exit path
    a.bind(L_HostCallFailedPathReturn);

    // Function epilogue - restore callee-saved registers
    a.pop(VM_PC.r64());       // r15
    a.pop(VM_GAS_PTR);        // r14
    a.pop(VM_MEMORY_SIZE.r64());  // r13
    a.pop(VM_MEMORY_PTR);     // r12
    a.pop(VM_CONTEXT_PTR);    // rbp
    a.pop(VM_REGISTERS_PTR);  // rbx

    a.ret();

    err = rt.add(reinterpret_cast<void**>(funcOut), &code);
    if (err) {
        fprintf(stderr, "AsmJit (x86_64) failed to add JITed code to runtime: %s\n",
                DebugUtils::errorAsString(err));
        return err;
    }

    return 0; // Success
}
