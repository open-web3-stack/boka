// generated by polka.codes
// x86_64-specific JIT compilation for PolkaVM

#include "x64_helper.hh"
#include "helper.hh"
#include <asmjit/asmjit.h>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <stdio.h>

using namespace asmjit;
using namespace asmjit::x86;

// Compiles PolkaVM bytecode to x86_64 machine code
int32_t compilePolkaVMCode_x64(
    const uint8_t* _Nonnull codeBuffer,
    size_t codeSize,
    uint32_t initialPC,
    uint32_t jitMemorySize,
    void* _Nullable * _Nonnull funcOut)
{
    // Validate input parameters
    if (!codeBuffer || codeSize == 0) {
        return 1; // Invalid input (null buffer or zero size)
    }

    if (!funcOut) {
        return 2; // Invalid output parameter
    }

    // Initialize asmjit runtime for code generation
    // IMPORTANT: JitRuntime must persist as long as generated code is used
    // Using static to ensure runtime lifetime exceeds function pointer usage
    static JitRuntime runtime;
    CodeHolder code;
    code.init(runtime.environment());

    // Create x86 assembler
    x86::Assembler a(&code);

    // Prologue: save callee-saved registers
    // System V ABI callee-saved: rbx, rbp, r12-r15
    a.push(rbx);
    a.push(rbp);
    a.push(r12);
    a.push(r13);
    a.push(r14);
    a.push(r15);

    // Setup VM environment registers:
    // - rbx: VM_REGISTERS_PTR - Guest VM registers array
    // - r12: VM_MEMORY_PTR - Guest VM memory base
    // - r13d: VM_MEMORY_SIZE - Guest VM memory size
    // - r14: VM_GAS_PTR - Guest VM gas counter
    // - r15d: VM_PC - Guest VM program counter
    // - rbp: VM_CONTEXT_PTR - Invocation context pointer

    // Copy function arguments to VM registers
    a.mov(rbx, rdi);  // registers_ptr -> rbx
    a.mov(r12, rsi);  // memory_base_ptr -> r12
    a.mov(r13d, edx); // memory_size -> r13d
    a.mov(r14, rcx);  // gas_ptr -> r14
    a.mov(r15d, r8d); // initial_pvm_pc -> r15d (PC)
    a.mov(rbp, r9);   // invocation_context_ptr -> rbp

    // Compile bytecode using instruction dispatcher
    // Compiles the entire bytecode range as a single unit
    // TODO: Future enhancement: Implement block-by-block compilation with label/fixup resolution
    // for better optimization and proper control flow handling
    if (!compile_bytecode_range(&a, "x86_64", codeBuffer, codeSize, initialPC, static_cast<uint32_t>(codeSize))) {
        // Compilation failed - return error code
        return 3; // Compilation error
    }

    // Epilogue: restore callee-saved registers and return
    a.pop(r15);
    a.pop(r14);
    a.pop(r13);
    a.pop(r12);
    a.pop(rbp);
    a.pop(rbx);
    a.ret();

    // Generate the function code
    Error err = runtime.add(funcOut, &code);
    if (err != Error::kOk) {
        return int32_t(err); // Return asmjit error code
    }

    return 0; // Success
}
