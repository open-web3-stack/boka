// generated by polka.codes
#include "helper.hh"
#include <asmjit/a64.h>
#include <asmjit/asmjit.h>
#include <iostream>
#include <stdio.h>
#include <cstring>

using namespace asmjit;

// Static register mapping for AArch64
namespace {
    // VM state registers (using callee-saved registers)
    const a64::Gp VM_REGISTERS_PTR = a64::x19;  // Guest VM registers array
    const a64::Gp VM_MEMORY_PTR = a64::x20;     // Guest VM memory base
    const a64::Gp VM_MEMORY_SIZE = a64::w21;    // Guest VM memory size (32-bit)
    const a64::Gp VM_GAS_PTR = a64::x22;        // Guest VM gas counter
    const a64::Gp VM_PC = a64::w23;             // Guest VM program counter (32-bit)
    const a64::Gp VM_CONTEXT_PTR = a64::x24;    // Invocation context pointer
    
    // Temporary registers (caller-saved)
    const a64::Gp TEMP_REG0 = a64::x9;          // General purpose temp
    const a64::Gp TEMP_REG1 = a64::x10;         // General purpose temp
    const a64::Gp TEMP_REG2 = a64::x11;         // General purpose temp
    const a64::Gp TEMP_REG3 = a64::x12;         // General purpose temp
    const a64::Gp TEMP_REG4 = a64::x13;         // General purpose temp
    const a64::Gp TEMP_REG5 = a64::x14;         // General purpose temp
    const a64::Gp TEMP_REG6 = a64::x15;         // General purpose temp
    
    // Parameter registers (AArch64 ABI)
    const a64::Gp PARAM_REG0 = a64::x0;         // First parameter
    const a64::Gp PARAM_REG1 = a64::x1;         // Second parameter
    const a64::Gp PARAM_REG2 = a64::x2;         // Third parameter
    const a64::Gp PARAM_REG3 = a64::x3;         // Fourth parameter
    const a64::Gp PARAM_REG4 = a64::x4;         // Fifth parameter
    const a64::Gp PARAM_REG5 = a64::x5;         // Sixth parameter
    const a64::Gp PARAM_REG6 = a64::x6;         // Seventh parameter
    const a64::Gp PARAM_REG7 = a64::x7;         // Eighth parameter
    
    // Return register
    const a64::Gp RETURN_REG = a64::x0;         // Return value register
}

// Forward declaration for instruction parsing function
extern "C" {
    // Function to be called from C++ to parse an instruction at a given PC
    // Returns a pointer to the parsed instruction or nullptr if parsing failed
    void* parseInstruction(const uint8_t* codeBuffer, size_t codeSize, uint32_t pc);
    
    // Function to be called from C++ to generate code for an instruction
    // Returns true if code generation was successful, false otherwise
    bool generateInstructionCode(
        void* assembler,
        const char* targetArch,
        void* instruction,
        uint32_t pc,
        uint32_t nextPC,
        void* gasPtr
    );
    
    // Function to release the parsed instruction
    void releaseInstruction(void* instruction);
}

int32_t compilePolkaVMCode_a64(
    const uint8_t* codeBuffer,
    size_t codeSize,
    uint32_t initialPC,
    uint32_t jitMemorySize,
    void** funcOut) {

    if (codeBuffer == nullptr || codeSize == 0) {
        std::cerr << "Error (AArch64): codeBuffer is null or codeSize is 0." << std::endl;
        return 1; // Invalid input error
    }
    if (funcOut == nullptr) {
        std::cerr << "Error (AArch64): funcOut is null." << std::endl;
        return 2; // Invalid output parameter
    }
    *funcOut = nullptr;

    JitRuntime rt;
    CodeHolder code;
    Environment env;

    env.setArch(asmjit::Arch::kAArch64);
    // TODO: Configure ABI settings if needed for specific AArch64 variants

    Error err = code.init(env);
    if (err) {
        fprintf(stderr, "AsmJit (AArch64) failed to initialize CodeHolder: %s\n",
                DebugUtils::errorAsString(err));
        return err;
    }

    a64::Assembler a(&code);
    Label L_HostCallSuccessful = a.newLabel();
    Label L_HostCallFailedPathReturn = a.newLabel();
    Label L_MainLoop = a.newLabel();
    Label L_ExitSuccess = a.newLabel();
    Label L_ExitOutOfGas = a.newLabel();
    Label L_ExitPanic = a.newLabel();

    // Function prologue - save callee-saved registers that we'll use
    a.sub(a64::sp, a64::sp, 64);  // Allocate stack space for 4 pairs of registers (8 registers * 8 bytes)
    a.stp(a64::x19, a64::x20, a64::ptr(a64::sp, 0));  // VM_REGISTERS_PTR, VM_MEMORY_PTR
    a.stp(a64::x21, a64::x22, a64::ptr(a64::sp, 16)); // VM_MEMORY_SIZE, VM_GAS_PTR
    a.stp(a64::x23, a64::x24, a64::ptr(a64::sp, 32)); // VM_PC, VM_CONTEXT_PTR
    a.stp(a64::x29, a64::x30, a64::ptr(a64::sp, 48)); // Frame pointer, Link register
    
    // Initialize our static register mapping from function parameters
    // AArch64 ABI: x0-x7 are parameter registers
    a.mov(VM_REGISTERS_PTR, PARAM_REG0);  // x0: registers_ptr
    a.mov(VM_MEMORY_PTR, PARAM_REG1);     // x1: memory_base_ptr
    a.mov(VM_MEMORY_SIZE, PARAM_REG2.w()); // w2: memory_size
    a.mov(VM_GAS_PTR, PARAM_REG3);        // x3: gas_ptr
    a.mov(VM_PC, PARAM_REG4.w());         // w4: initial_pvm_pc
    a.mov(VM_CONTEXT_PTR, PARAM_REG5);    // x5: invocation_context_ptr

    // Main instruction execution loop
    a.bind(L_MainLoop);
    
    // Parse the instruction at the current PC
    a.mov(PARAM_REG0, reinterpret_cast<uint64_t>(codeBuffer));
    a.mov(PARAM_REG1, codeSize);
    a.mov(PARAM_REG2.w(), VM_PC);
    a.mov(TEMP_REG0, reinterpret_cast<uint64_t>(parseInstruction));
    a.blr(TEMP_REG0); // Call parseInstruction, result in x0
    
    // Check if parsing failed (x0 == nullptr)
    a.cmp(RETURN_REG, 0);
    a.b_eq(L_ExitPanic); // If parsing failed, exit with panic
    
    // Calculate next PC (current PC + instruction size)
    // For simplicity, we'll just increment by 1 for now
    // In a real implementation, we'd need to determine the actual instruction size
    a.add(TEMP_REG1.w(), VM_PC, 1);
    
    // Generate code for the instruction
    a.mov(PARAM_REG0, reinterpret_cast<uint64_t>(&a)); // Assembler pointer
    a.mov(PARAM_REG1, reinterpret_cast<uint64_t>("aarch64")); // Target architecture
    a.mov(PARAM_REG2, RETURN_REG); // Instruction pointer (from parseInstruction)
    a.mov(PARAM_REG3.w(), VM_PC); // Current PC
    a.mov(PARAM_REG4.w(), TEMP_REG1.w()); // Next PC
    a.mov(PARAM_REG5, VM_GAS_PTR); // Gas pointer
    a.mov(TEMP_REG0, reinterpret_cast<uint64_t>(generateInstructionCode));
    a.blr(TEMP_REG0); // Call generateInstructionCode, result in x0
    
    // Release the instruction
    a.mov(PARAM_REG0, RETURN_REG); // Instruction pointer
    a.mov(TEMP_REG0, reinterpret_cast<uint64_t>(releaseInstruction));
    a.blr(TEMP_REG0); // Call releaseInstruction
    
    // Check if code generation was successful
    a.cmp(RETURN_REG, 0);
    a.b_eq(L_ExitPanic); // If code generation failed, exit with panic
    
    // Check if we should continue execution
    // For now, we'll just loop back to the main loop
    a.b(L_MainLoop);
    
    // Exit paths
    
    // Success exit path
    a.bind(L_ExitSuccess);
    a.mov(RETURN_REG, 0); // Return ExitReason.Halt
    a.b(L_HostCallFailedPathReturn);
    
    // Out of gas exit path
    a.bind(L_ExitOutOfGas);
    a.mov(RETURN_REG, 2); // Return ExitReason.OutOfGas
    a.b(L_HostCallFailedPathReturn);
    
    // Panic exit path
    a.bind(L_ExitPanic);
    a.mov(RETURN_REG, 1); // Return ExitReason.Panic
    
    // Common exit path
    a.bind(L_HostCallFailedPathReturn);
    
    // Function epilogue - restore callee-saved registers
    a.ldp(a64::x29, a64::x30, a64::ptr(a64::sp, 48)); // Frame pointer, Link register
    a.ldp(a64::x23, a64::x24, a64::ptr(a64::sp, 32)); // VM_PC, VM_CONTEXT_PTR
    a.ldp(a64::x21, a64::x22, a64::ptr(a64::sp, 16)); // VM_MEMORY_SIZE, VM_GAS_PTR
    a.ldp(a64::x19, a64::x20, a64::ptr(a64::sp, 0));  // VM_REGISTERS_PTR, VM_MEMORY_PTR
    a.add(a64::sp, a64::sp, 64);  // Deallocate stack space
    
    a.ret(a64::x30);

    err = rt.add(reinterpret_cast<void**>(funcOut), &code);
    if (err) {
        fprintf(stderr, "AsmJit (AArch64) failed to add JITed code to runtime: %s\n", 
                DebugUtils::errorAsString(err));
        return err;
    }

    return 0; // Success
}
