// generated by polka.codes
#include "helper.hh"
#include <asmjit/a64.h>
#include <asmjit/asmjit.h>
#include <iostream>
#include <stdio.h>
#include <cstring>

using namespace asmjit;

int32_t compilePolkaVMCode_a64(
    const uint8_t* codeBuffer,
    size_t codeSize,
    uint32_t initialPC,
    uint32_t jitMemorySize,
    void** funcOut) {

    if (codeBuffer == nullptr || codeSize == 0) {
        std::cerr << "Error (AArch64): codeBuffer is null or codeSize is 0." << std::endl;
        return 1; // Invalid input error
    }
    if (funcOut == nullptr) {
        std::cerr << "Error (AArch64): funcOut is null." << std::endl;
        return 2; // Invalid output parameter
    }
    *funcOut = nullptr;

    JitRuntime rt;
    CodeHolder code;
    Environment env;

    env.setArch(asmjit::Arch::kAArch64);
    // TODO: Configure ABI settings if needed for specific AArch64 variants

    Error err = code.init(env);
    if (err) {
        fprintf(stderr, "AsmJit (AArch64) failed to initialize CodeHolder: %s\n",
                DebugUtils::errorAsString(err));
        return err;
    }

    a64::Assembler a(&code);
    Label L_HostCallSuccessful = a.newLabel();
    Label L_HostCallFailedPathReturn = a.newLabel();

    // TODO: Implement full PolkaVM bytecode to AArch64 translation
    
    // Register usage for AArch64 ABI:
    // - x0-x7: Parameter/result registers (caller-saved)
    // - x8: Indirect result location register
    // - x9-x15: Temporary registers (caller-saved)
    // - x16-x17: Intra-procedure-call temporary registers
    // - x18: Platform register (reserved)
    // - x19-x28: Callee-saved registers
    // - x29: Frame pointer
    // - x30: Link register
    // - sp: Stack pointer

    // Example ECALL implementation
    if (codeSize > 0 && initialPC == 0) {
        std::cout << "JIT (AArch64): Simulating ECALL #1" << std::endl;
        uint32_t host_call_idx = 1;

        // Save JIT function arguments to callee-saved registers
        a.mov(a64::x19, a64::x0); // Save registers_ptr
        a.mov(a64::x20, a64::x1); // Save memory_base_ptr
        a.mov(a64::x21, a64::x2); // Save memory_size
        a.mov(a64::x22, a64::x3); // Save gas_ptr
        a.mov(a64::x23, a64::x4); // Save initial_pvm_pc
        a.mov(a64::x24, a64::x5); // Save invocation_context_ptr

        // Setup arguments for pvm_host_call_trampoline
        a.mov(a64::x0, a64::x24);     // arg0: invocation_context_ptr
        a.mov(a64::x1, host_call_idx); // arg1: host_call_idx
        a.mov(a64::x2, a64::x19);     // arg2: guest_registers_ptr
        a.mov(a64::x3, a64::x20);     // arg3: guest_memory_base_ptr
        a.mov(a64::w4, a64::w21);     // arg4: guest_memory_size
        a.mov(a64::x5, a64::x22);     // arg5: guest_gas_ptr

        // Call trampoline using x9 (temporary register)
        a.mov(a64::x9, reinterpret_cast<uint64_t>(pvm_host_call_trampoline));
        a.blr(a64::x9); // Result returned in x0

        // Check for error (0xFFFFFFFF)
        a.cmp(a64::x0, 0xFFFFFFFF);
        a.b_ne(L_HostCallSuccessful);

        // Host call failed path
        a.mov(a64::x0, 1); // Return ExitReason.Panic
        a.b(L_HostCallFailedPathReturn);

        a.bind(L_HostCallSuccessful);
        // Store host call result to PVM_R0 (first element in registers array)
        a.str(a64::x0, a64::ptr(a64::x19));
    }

    // Default exit path
    a.mov(a64::x0, 0); // Return ExitReason.Halt
    a.bind(L_HostCallFailedPathReturn);
    a.ret(a64::x30);

    err = rt.add(reinterpret_cast<void**>(funcOut), &code);
    if (err) {
        fprintf(stderr, "AsmJit (AArch64) failed to add JITed code to runtime: %s\n", 
                DebugUtils::errorAsString(err));
        return err;
    }

    return 0; // Success
}
