// generated by polka.codes
// Bridge between Swift and C++ for JIT compilation using AsmJit on AArch64 and x86_64

#pragma once

#include <cstddef>
#include <cstdint>
#include <asmjit/asmjit.h>

// JIT instruction generation interface
// This is the C++ implementation of the JITInstructionGenerator protocol
namespace jit_instruction {
    // Control flow instruction generators

    // Generate gas accounting code
    bool jit_emitGasAccounting(
        void* _Nonnull assembler,
        const char* _Nonnull target_arch,
        uint64_t gas_cost,
        void* _Nonnull gas_ptr
    );

    // Generate trap instruction
    bool jit_generateTrap(
        void* _Nonnull assembler,
        const char* _Nonnull target_arch
    );

    // Generate jump instruction
    bool jit_generateJump(
        void* _Nonnull assembler,
        const char* _Nonnull target_arch,
        uint32_t target_pc
    );

    // Generate jump indirect instruction
    bool jit_generateJumpIndirect(
        void* _Nonnull assembler,
        const char* _Nonnull target_arch,
        uint8_t reg_index
    );

    // Generate ecalli instruction (calls into host)
    bool jit_generateEcalli(
        void* _Nonnull assembler,
        const char* _Nonnull target_arch,
        uint32_t func_idx,
        void* _Nonnull gas_ptr
    );

    // Generate load immediate and jump
    bool jit_generateLoadImmJump(
        void* _Nonnull assembler,
        const char* _Nonnull target_arch,
        uint8_t dest_reg,
        uint32_t immediate,
        uint32_t target_pc
    );

    // Generate load immediate and jump indirect
    bool jit_generateLoadImmJumpInd(
        void* _Nonnull assembler,
        const char* _Nonnull target_arch,
        uint8_t dest_reg,
        uint32_t immediate,
        uint8_t jump_reg
    );
}

// Function signature matching JITHostFunctionFnSwift in ExecutorBackendJIT.swift
// Returns: 0xFFFFFFFF on error, otherwise host call result
typedef uint32_t (* _Nonnull JITHostFunctionFn)(
	void* _Nonnull ownerContext,
	uint32_t hostCallIndex,
	uint64_t* _Nonnull guestRegisters,
	uint8_t* _Nonnull guestMemoryBase,
	uint32_t guestMemorySize,
	uint64_t* _Nonnull guestGas,
	void* _Nullable invocationContext
);

// Table passed as `invocationContext` to JIT-compiled functions
struct JITHostFunctionTable {
    JITHostFunctionFn dispatchHostCall;
    void* _Nonnull ownerContext; // Opaque pointer to Swift ExecutorBackendJIT
    void* _Nullable invocationContext; // Opaque pointer to InvocationContext
};

// Trampoline for JIT code to call Swift host functions
// Returns: 0xFFFFFFFF on error, otherwise host call result (stored in PVM_R0)
uint32_t pvm_host_call_trampoline(
    JITHostFunctionTable* _Nonnull host_table,
    uint32_t host_call_index,
    uint64_t* _Nonnull guest_registers_ptr,
    uint8_t* _Nonnull guest_memory_base_ptr,
    uint32_t guest_memory_size,
    uint64_t* _Nonnull guest_gas_ptr);

// Compile a range of bytecode instructions to machine code
// This is the main entry point for JIT compilation from the C++ layer
// - Parameters:
//   - assembler: The AsmJit assembler instance
//   - target_arch: Target architecture ("x86_64" or "aarch64")
//   - bytecode: Pointer to the bytecode buffer
//   - bytecode_size: Size of the bytecode buffer
//   - start_pc: Starting program counter
//   - end_pc: Ending program counter (exclusive)
// - Returns: true if successful, false otherwise
bool compile_bytecode_range(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    const uint8_t* _Nonnull bytecode,
    size_t bytecode_size,
    uint32_t start_pc,
    uint32_t end_pc
);

// Basic block boundary detection
// Returns true if the given opcode ends a basic block
inline bool is_block_ending_instruction(uint8_t opcode) {
    // Block-ending instructions (matching BASIC_BLOCK_INSTRUCTIONS from Instructions.swift)
    // 0: Trap, 1: Fallthrough, 4: Jump, 5: JumpInd, 6: LoadImmJump, 80-90: Branch instructions
    return opcode == 0 ||  // Trap
           opcode == 1 ||  // Fallthrough
           opcode == 4 ||  // Jump
           opcode == 5 ||  // JumpInd
           opcode == 6 ||  // LoadImmJump
           (opcode >= 80 && opcode <= 90);  // Branch instructions (Eq, Ne, Lt, Le, Gt for signed/unsigned)
}

// Get the size of an instruction in bytes
// Returns 0 if the opcode is unknown
uint32_t get_instruction_size(const uint8_t* _Nonnull bytecode, uint32_t pc, size_t bytecode_size);
