// generated by polka.codes
// Label-based AArch64 JIT compilation for PolkaVM
// Single-pass compilation with lazy label creation for maximum performance

#include "helper.hh"
#include "jit_label_manager.hh"
#include "jit_control_flow.hh"
#include "opcodes.hh"
#include <asmjit/asmjit.h>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <stdio.h>
#include <vector>

using namespace asmjit;
using namespace asmjit::a64;
using namespace JIT;
using namespace PVM;

// External declaration for the instruction emitter
extern "C" bool jit_emitter_emit_basic_block_instructions(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    const uint8_t* _Nonnull bytecode,
    uint32_t start_pc,
    uint32_t end_pc);

// Helper to get instruction size
static uint32_t getInstructionSize(const uint8_t* bytecode, uint32_t pc, size_t bytecode_size) {
    return get_instruction_size(bytecode, pc, bytecode_size);
}

// Helper to extract jump target from instruction
static uint32_t getJumpTarget(const uint8_t* bytecode, uint32_t pc, uint32_t instrSize) {
    if (instrSize == 5 || instrSize == 7) {
        // Jump (5 bytes): [opcode][offset_32bit]
        // Branch (7 bytes): [opcode][reg1][reg2][offset_32bit]
        uint32_t offset;
        if (instrSize == 5) {
            memcpy(&offset, &bytecode[pc + 1], 4);
        } else {
            memcpy(&offset, &bytecode[pc + 3], 4);
        }
        return pc + instrSize + int32_t(offset);
    }
    return pc + instrSize; // Fallthrough
}

// Main compilation function with labels for ARM64
extern "C" int32_t compilePolkaVMCode_a64_labeled(
    const uint8_t* _Nonnull codeBuffer,
    size_t codeSize,
    uint32_t initialPC,
    uint32_t jitMemorySize,
    void* _Nullable * _Nonnull funcOut)
{
    // Validate inputs
    if (!codeBuffer || codeSize == 0) {
        return 1; // Invalid input
    }

    if (!funcOut) {
        return 2; // Invalid output parameter
    }

    // Initialize asmjit runtime
    static JitRuntime runtime;
    CodeHolder code;
    code.init(runtime.environment());

    // Create ARM64 assembler
    a64::Assembler a(&code);

    // Prologue: save callee-saved registers
    // ARM64 callee-saved: x19-x28, x29 (fp), x30 (lr)
    a.sub(a64::sp, a64::sp, 16 * 10); // Allocate stack space
    a.stp(x19, x20, ptr(a64::sp, 0));
    a.stp(x21, x22, ptr(a64::sp, 16));
    a.stp(x23, x24, ptr(a64::sp, 32));
    a.stp(x25, x26, ptr(a64::sp, 48));
    a.stp(x27, x28, ptr(a64::sp, 64));
    a.stp(x29, x30, ptr(a64::sp, 80));

    // Setup VM environment registers (per AArch64 ABI)
    // x0 = registers_ptr, x1 = memory_base_ptr, w2 = memory_size
    // x3 = gas_ptr, w4 = initial_pvm_pc, x5 = invocation_context_ptr
    a.mov(a64::x19, a64::x0);  // registers_ptr -> x19
    a.mov(a64::x20, a64::x1);  // memory_base_ptr -> x20
    a.mov(a64::w21, a64::w2);  // memory_size -> w21
    a.mov(a64::x22, a64::x3);  // gas_ptr -> x22
    a.mov(a64::w23, a64::w4);  // initial_pvm_pc -> w23 (PC)
    a.mov(a64::x24, a64::x5);  // invocation_context_ptr -> x24

    // Create label manager
    LabelManager labelManager;

    // Create exit labels for different exit conditions
    Label exitLabel = a.newLabel();       // Normal exit (halt) - w0 = 0
    Label panicLabel = a.newLabel();      // Panic exit (trap, address < 65536) - w0 = -1
    Label pagefaultLabel = a.newLabel();  // Page fault exit (address >= memory_size) - w0 = 3
    Label epilogueLabel = a.newLabel();   // Epilogue (restore registers and return)

    // === PRE-PASS: Identify all jump targets ===
    // This is necessary to handle backward jumps (loops)
    uint32_t pc = 0;
    while (pc < codeSize) {
        uint8_t opcode = codeBuffer[pc];
        uint32_t instrSize = getInstructionSize(codeBuffer, pc, codeSize);

        if (instrSize == 0) {
            // Unknown opcode - compilation error
            return 3; // Compilation error
        }

        // Mark jump targets for control flow instructions
        if (opcode_is(opcode, Opcode::Jump)) {
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);
            labelManager.markJumpTarget(targetPC);
        } else if (opcode_is(opcode, Opcode::BranchEq) ||
                   opcode_is(opcode, Opcode::BranchNe)) {
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);
            labelManager.markJumpTarget(targetPC);
        } else if (opcode_is(opcode, Opcode::LoadImmJump)) {
            uint8_t destReg = codeBuffer[pc + 1];
            uint32_t jumpOffset;
            memcpy(&jumpOffset, &codeBuffer[pc + 2], 4);   // Jump offset is at bytes 2-5
            uint32_t targetPC = pc + instrSize + int32_t(jumpOffset);
            labelManager.markJumpTarget(targetPC);
        }

        pc += instrSize;
    }

    // === MAIN COMPILATION PASS ===
    pc = 0;

    while (pc < codeSize) {
        uint8_t opcode = codeBuffer[pc];
        uint32_t instrSize = getInstructionSize(codeBuffer, pc, codeSize);

        if (instrSize == 0) {
            // Unknown opcode - compilation error
            return 3; // Compilation error
        }

        // Check if this PC is a jump target (from pre-pass or previous branch)
        // Bind label here if so
        if (labelManager.isMarkedTarget(pc) || labelManager.isJumpTarget(pc)) {
            labelManager.bindLabel(&a, pc, "aarch64");
        }

        // Handle control flow instructions with labels
        if (opcode_is(opcode, Opcode::Jump)) {
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);
            Label targetLabel = labelManager.getOrCreateLabel(&a, targetPC, "aarch64");
            jit_emit_jump_labeled(&a, "aarch64", targetLabel);
            pc += instrSize;
            continue;
        }

        if (opcode_is(opcode, Opcode::BranchEq)) {
            uint8_t reg1 = codeBuffer[pc + 1];
            uint8_t reg2 = codeBuffer[pc + 2];
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);

            Label targetLabel = labelManager.getOrCreateLabel(&a, targetPC, "aarch64");
            jit_emit_branch_eq_labeled(&a, "aarch64", reg1, reg2, targetLabel);

            pc += instrSize;
            continue;
        }

        if (opcode_is(opcode, Opcode::BranchNe)) {
            uint8_t reg1 = codeBuffer[pc + 1];
            uint8_t reg2 = codeBuffer[pc + 2];
            uint32_t targetPC = getJumpTarget(codeBuffer, pc, instrSize);

            Label targetLabel = labelManager.getOrCreateLabel(&a, targetPC, "aarch64");
            jit_emit_branch_ne_labeled(&a, "aarch64", reg1, reg2, targetLabel);

            pc += instrSize;
            continue;
        }

        if (opcode_is(opcode, Opcode::LoadImmJump)) {
            uint8_t destReg = codeBuffer[pc + 1];
            uint32_t jumpOffset;
            uint32_t immediate;
            memcpy(&jumpOffset, &codeBuffer[pc + 2], 4);   // Jump offset is at bytes 2-5
            memcpy(&immediate, &codeBuffer[pc + 6], 4);    // Immediate value is at bytes 6-9
            uint32_t targetPC = pc + instrSize + int32_t(jumpOffset);

            Label targetLabel = labelManager.getOrCreateLabel(&a, targetPC, "aarch64");
            jit_emit_load_imm_jump_labeled(&a, "aarch64", destReg, immediate, targetLabel);

            pc += instrSize;
            continue;
        }

        if (opcode_is(opcode, Opcode::Trap)) {
            // Set return value to -1 (trap) in w0, then jump to epilogue
            a.mov(a64::w0, -1);
            a.b(epilogueLabel);
            pc += instrSize;
            continue;
        }

        if (opcode_is(opcode, Opcode::Halt)) {
            // Jump to exit
            a.b(exitLabel);
            pc += instrSize;
            continue;
        }

        // === StoreImm Instructions with Bounds Checking ===
        // PVM Spec: addresses < 2^16 (65536) → panic, addresses >= memory_size → page fault
        // Format: [opcode][value_Xbit][address_32bit]
        if (opcode_is(opcode, Opcode::StoreImmU8)) {
            // StoreImmU8: [opcode][value_8bit][address_32bit] = 6 bytes
            uint8_t value = codeBuffer[pc + 1];
            uint32_t address;
            memcpy(&address, &codeBuffer[pc + 2], 4);

            // Load address into x0 for bounds checking
            a.mov(a64::x0, address);

            // Bounds check: address < 65536 → panic (use b.lo for unsigned <)
            a.cmp(a64::x0, 65536);
            a.b_lo(panicLabel);

            // Runtime check: address >= memory_size → page fault (use b.hs for unsigned >=)
            a.mov(a64::w1, a64::w21);  // Load memory_size into w1
            a.cmp(a64::x0, a64::x1);
            a.b_hs(pagefaultLabel);

            // Store value to memory
            a.mov(a64::w8, value);
            a.strb(a64::w8, a64::ptr(a64::x20, a64::x0));

            pc += instrSize;
            continue;
        }

        if (opcode_is(opcode, Opcode::StoreImmU16)) {
            // StoreImmU16: [opcode][value_16bit][address_32bit] = 7 bytes
            uint16_t value;
            uint32_t address;
            memcpy(&value, &codeBuffer[pc + 1], 2);
            memcpy(&address, &codeBuffer[pc + 3], 4);

            // Load address into x0 for bounds checking
            a.mov(a64::x0, address);

            // Bounds check: address < 65536 → panic
            a.cmp(a64::x0, 65536);
            a.b_lo(panicLabel);

            // Runtime check: address >= memory_size → page fault
            a.mov(a64::w1, a64::w21);  // Load memory_size into w1
            a.cmp(a64::x0, a64::x1);
            a.b_hs(pagefaultLabel);

            // Store value to memory
            a.mov(a64::w8, value);
            a.strh(a64::w8, a64::ptr(a64::x20, a64::x0));

            pc += instrSize;
            continue;
        }

        if (opcode_is(opcode, Opcode::StoreImmU32)) {
            // StoreImmU32: [opcode][value_32bit][address_32bit] = 9 bytes
            uint32_t value;
            uint32_t address;
            memcpy(&value, &codeBuffer[pc + 1], 4);
            memcpy(&address, &codeBuffer[pc + 5], 4);

            // Load address into x0 for bounds checking
            a.mov(a64::x0, address);

            // Bounds check: address < 65536 → panic
            a.cmp(a64::x0, 65536);
            a.b_lo(panicLabel);

            // Runtime check: address >= memory_size → page fault
            a.mov(a64::w1, a64::w21);  // Load memory_size into w1
            a.cmp(a64::x0, a64::x1);
            a.b_hs(pagefaultLabel);

            // Store value to memory
            a.mov(a64::w8, value);
            a.str(a64::w8, a64::ptr(a64::x20, a64::x0));

            pc += instrSize;
            continue;
        }

        if (opcode_is(opcode, Opcode::StoreImmU64)) {
            // StoreImmU64: [opcode][value_64bit][address_32bit] = 13 bytes
            uint64_t value;
            uint32_t address;
            memcpy(&value, &codeBuffer[pc + 1], 8);
            memcpy(&address, &codeBuffer[pc + 9], 4);

            // Load address into x0 for bounds checking
            a.mov(a64::x0, address);

            // Bounds check: address < 65536 → panic
            a.cmp(a64::x0, 65536);
            a.b_lo(panicLabel);

            // Runtime check: address >= memory_size → page fault
            a.mov(a64::w1, a64::w21);  // Load memory_size into w1
            a.cmp(a64::x0, a64::x1);
            a.b_hs(pagefaultLabel);

            // Store value to memory
            a.mov(a64::x8, value);
            a.str(a64::x8, a64::ptr(a64::x20, a64::x0));

            pc += instrSize;
            continue;
        }

        // For all other instructions, use the existing dispatcher
        if (!jit_emitter_emit_basic_block_instructions(&a, "aarch64", codeBuffer, pc, pc + instrSize)) {
            return 3; // Compilation error
        }

        pc += instrSize;
    }

    // Bind panic label
    a.bind(panicLabel);
    a.mov(a64::w0, -1);  // Exit code -1 = panic(.trap)
    a.b(epilogueLabel);

    // Bind pagefault label
    a.bind(pagefaultLabel);
    a.mov(a64::w0, 3);   // Exit code 3 = pageFault
    a.b(epilogueLabel);

    // Bind exit label
    a.bind(exitLabel);

    // Set return value to 0 (halt) in w0
    a.mov(a64::w0, 0);

    // Bind epilogue label (for Trap - already has w0=-1 set)
    a.bind(epilogueLabel);

    // Epilogue: restore callee-saved registers and return
    a.ldp(x29, x30, ptr(a64::sp, 80));
    a.ldp(x27, x28, ptr(a64::sp, 64));
    a.ldp(x25, x26, ptr(a64::sp, 48));
    a.ldp(x23, x24, ptr(a64::sp, 32));
    a.ldp(x21, x22, ptr(a64::sp, 16));
    a.ldp(x19, x20, ptr(a64::sp, 0));
    a.add(a64::sp, a64::sp, 16 * 10);
    a.ret(x30);

    // Generate the function code
    Error err = runtime.add(funcOut, &code);
    if (err) {
        return int32_t(err);
    }

    return 0; // Success
}
