// generated by polka.codes
// JIT exports from C++ to Swift for PolkaVM

#include "helper.hh"
#include <cstddef>
#include <cstring>
#include <stdio.h>
#include <string>

using namespace asmjit;

// JIT compiler resources
struct JITCompilerResources {
    JitRuntime runtime;
    CodeHolder code;
    BaseEmitter *emitter;
    std::string targetArch;

    JITCompilerResources(const std::string &arch) : targetArch(arch), emitter(nullptr)
    {
        code.init(runtime.environment());

        // Create the appropriate emitter based on target architecture
        if (arch.compare("x86_64") == 0) {
            emitter = new x86::Assembler(&code);
        } else if (arch.compare("aarch64") == 0) {
            emitter = new a64::Assembler(&code);
        }
    }

    ~JITCompilerResources()
    {
        if (emitter) {
            delete emitter;
            emitter = nullptr;
        }
    }
};

// Helper template for assembler access
template <typename T> T *getTypedAssembler(void *assembler, const char *targetArch)
{
    BaseEmitter *emitter = static_cast<BaseEmitter *>(assembler);
    if (emitter) {
        return static_cast<T *>(emitter);
    }
    return nullptr;
}

// Gas accounting
bool jit_emitGasAccounting(
    void *assembler,
    const char *target_arch,
    uint64_t gas_cost,
    void *gas_ptr)
{
    std::string arch(target_arch);

    if (arch.compare("x86_64") == 0) {
        auto *a = getTypedAssembler<x86::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // In x86_64:
        // 1. Load the current gas value from gas_ptr (VM_GAS_PTR is in r14)
        // 2. Subtract the gas cost
        // 3. Store the updated value back
        // 4. Check if gas is exhausted and jump to out-of-gas handler if so

        x86::Gp temp1 = x86::rax;
        x86::Gp gasReg = x86::r14;

        a->mov(temp1, x86::qword_ptr(gasReg));
        a->sub(temp1, gas_cost);
        a->mov(x86::qword_ptr(gasReg), temp1);

        // If gas < 0, jump to out-of-gas handler (which will be patched later)
        Label outOfGasLabel = a->newLabel();
        a->jl(outOfGasLabel);
        a->bind(outOfGasLabel);

        return true;
    } else if (arch.compare("aarch64") == 0) {
        auto *a = getTypedAssembler<a64::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // In AArch64:
        // 1. Load the current gas value from gas_ptr (VM_GAS_PTR is in x22)
        // 2. Subtract the gas cost
        // 3. Store the updated value back
        // 4. Check if gas is exhausted and jump to out-of-gas handler if so

        a64::Gp temp1 = a64::x0;
        a64::Gp gasReg = a64::x22;

        a->ldr(temp1, a64::ptr(gasReg));
        a->sub(temp1, temp1, gas_cost);
        a->str(temp1, a64::ptr(gasReg));

        // If gas < 0, jump to out-of-gas handler (which will be patched later)
        Label outOfGasLabel = a->newLabel();
        a->cmp(temp1, 0);
        a->b_lt(outOfGasLabel);
        a->bind(outOfGasLabel);

        return true;
    }

    return false;
}

// Generate trap instruction
bool jit_generateTrap(void *assembler, const char *target_arch)
{
    std::string arch(target_arch);

    if (arch.compare("x86_64") == 0) {
        auto *a = getTypedAssembler<x86::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // x86 trap instruction (causes SIGTRAP)
        a->int3();
        return true;
    } else if (arch.compare("aarch64") == 0) {
        auto *a = getTypedAssembler<a64::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // ARM breakpoint instruction (causes SIGTRAP)
        a->brk(0);
        return true;
    }

    return false;
}

// Generate jump instruction (direct)
bool jit_generateJump(void *assembler, const char *target_arch, uint32_t target_pc)
{
    std::string arch(target_arch);

    if (arch.compare("x86_64") == 0) {
        auto *a = getTypedAssembler<x86::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // x86: Update PC register (r15d) and jump to dispatcher
        x86::Gp pcReg = x86::r15d;
        a->mov(pcReg, target_pc);

        // Jump to code location (this will be patched later)
        Label dispatcherLabel = a->newLabel();
        a->jmp(dispatcherLabel);
        a->bind(dispatcherLabel);

        return true;
    } else if (arch.compare("aarch64") == 0) {
        auto *a = getTypedAssembler<a64::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // AArch64: Update PC register (w23) and jump to dispatcher
        a64::Gp pcReg = a64::w23;
        a->mov(pcReg, target_pc);

        // Jump to code location (this will be patched later)
        Label dispatcherLabel = a->newLabel();
        a->b(dispatcherLabel);
        a->bind(dispatcherLabel);

        return true;
    }

    return false;
}

// Generate jump indirect instruction
bool jit_generateJumpIndirect(void *assembler, const char *target_arch, uint8_t reg_index)
{
    std::string arch(target_arch);

    if (arch.compare("x86_64") == 0) {
        auto *a = getTypedAssembler<x86::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // x86: Load target PC from register and jump
        x86::Gp pcReg = x86::r15d;
        x86::Gp regPtr = x86::rbx;  // Register pointer (VM_REGISTERS_PTR in rbx)
        x86::Gp tempReg = x86::rax; // Temporary register

        // Load the target PC from the specified register
        a->mov(tempReg, x86::qword_ptr(regPtr, reg_index * 8));
        a->mov(pcReg, x86::eax); // Move 32-bit value to PC

        // Jump to dispatcher (will be patched later)
        Label dispatcherLabel = a->newLabel();
        a->jmp(dispatcherLabel);
        a->bind(dispatcherLabel);

        return true;
    } else if (arch.compare("aarch64") == 0) {
        auto *a = getTypedAssembler<a64::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // AArch64: Load target PC from register and jump
        a64::Gp pcReg = a64::w23;  // PC register
        a64::Gp regPtr = a64::x19; // Register pointer (VM_REGISTERS_PTR in x19)
        a64::Gp tempReg = a64::x0; // Temporary register

        // Load the target PC from the specified register
        a->ldr(tempReg, a64::ptr(regPtr, reg_index * 8));
        a->mov(pcReg, a64::w0); // Move 32-bit value to PC

        // Jump to dispatcher (will be patched later)
        Label dispatcherLabel = a->newLabel();
        a->b(dispatcherLabel);
        a->bind(dispatcherLabel);

        return true;
    }

    return false;
}

// Generate ecalli instruction (calls into host)
bool jit_generateEcalli(void *assembler, const char *target_arch, uint32_t func_idx, void *gas_ptr)
{
    std::string arch(target_arch);

    if (arch.compare("x86_64") == 0) {
        auto *a = getTypedAssembler<x86::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // x86_64 calling convention for host function
        x86::Gp contextPtr = x86::rbp; // VM_CONTEXT_PTR in rbp
        x86::Gp regPtr = x86::rbx;     // VM_REGISTERS_PTR in rbx
        x86::Gp memPtr = x86::r12;     // VM_MEMORY_PTR in r12
        x86::Gp memSize = x86::r13d;   // VM_MEMORY_SIZE in r13d
        x86::Gp gasPtr = x86::r14;     // VM_GAS_PTR in r14

        // Setup parameters for host call
        x86::Gp arg1 = x86::rdi; // First arg: context pointer
        x86::Gp arg2 = x86::rsi; // Second arg: func_idx
        x86::Gp arg3 = x86::rdx; // Third arg: registers pointer
        x86::Gp arg4 = x86::rcx; // Fourth arg: memory pointer
        x86::Gp arg5 = x86::r8d; // Fifth arg: memory size
        x86::Gp arg6 = x86::r9;  // Sixth arg: gas pointer

        a->mov(arg1, contextPtr);
        a->mov(arg2, func_idx);
        a->mov(arg3, regPtr);
        a->mov(arg4, memPtr);
        a->mov(arg5, memSize);
        a->mov(arg6, gasPtr);

        // Call the host function trampoline
        a->mov(x86::rax, (uint64_t)pvm_host_call_trampoline);
        a->call(x86::rax);

        // The result is in eax - check for error code
        // 0xFFFFFFFF indicates an error (magic value)
        a->cmp(x86::eax, 0xFFFFFFFF);

        // If equal, jump to error handler (will be patched later)
        Label errorLabel = a->newLabel();
        a->je(errorLabel);
        a->bind(errorLabel);

        // If not error, put result in R0
        a->mov(x86::qword_ptr(regPtr, 0), x86::rax); // Store in R0

        return true;
    } else if (arch.compare("aarch64") == 0) {
        auto *a = getTypedAssembler<a64::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // AArch64 calling convention for host function
        a64::Gp contextPtr = a64::x24; // VM_CONTEXT_PTR in x24
        a64::Gp regPtr = a64::x19;     // VM_REGISTERS_PTR in x19
        a64::Gp memPtr = a64::x20;     // VM_MEMORY_PTR in x20
        a64::Gp memSize = a64::w21;    // VM_MEMORY_SIZE in w21
        a64::Gp gasPtr = a64::x22;     // VM_GAS_PTR in x22

        // Setup parameters for host call
        a64::Gp arg1 = a64::x0; // First arg: context pointer
        a64::Gp arg2 = a64::w1; // Second arg: func_idx
        a64::Gp arg3 = a64::x2; // Third arg: registers pointer
        a64::Gp arg4 = a64::x3; // Fourth arg: memory pointer
        a64::Gp arg5 = a64::w4; // Fifth arg: memory size
        a64::Gp arg6 = a64::x5; // Sixth arg: gas pointer

        a->mov(arg1, contextPtr);
        a->mov(arg2, func_idx);
        a->mov(arg3, regPtr);
        a->mov(arg4, memPtr);
        a->mov(arg5, memSize);
        a->mov(arg6, gasPtr);

        // Call the host function trampoline
        a64::Gp tempReg = a64::x9;
        a->mov(tempReg, (uint64_t)pvm_host_call_trampoline);
        a->blr(tempReg);

        // The result is in w0 - check for error code
        // 0xFFFFFFFF indicates an error (magic value)
        a->cmp(a64::w0, 0xFFFFFFFF);

        // If equal, jump to error handler (will be patched later)
        Label errorLabel = a->newLabel();
        a->b_eq(errorLabel);
        a->bind(errorLabel);

        // If not error, put result in R0
        a->str(a64::x0, a64::ptr(regPtr, 0)); // Store in R0

        return true;
    }

    return false;
}

// Generate load immediate and jump
bool jit_generateLoadImmJump(
    void *assembler,
    const char *target_arch,
    uint8_t dest_reg,
    uint32_t immediate,
    uint32_t target_pc)
{
    std::string arch(target_arch);

    if (arch.compare("x86_64") == 0) {
        auto *a = getTypedAssembler<x86::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // Load immediate into destination register
        x86::Gp regPtr = x86::rbx;  // VM_REGISTERS_PTR in rbx
        x86::Gp pcReg = x86::r15d;  // PC in r15d
        x86::Gp tempReg = x86::rax; // Temporary register

        // Load the immediate value in target register
        a->mov(tempReg, (uint64_t)immediate);
        a->mov(x86::qword_ptr(regPtr, dest_reg * 8), tempReg);

        // Set PC to target and jump
        a->mov(pcReg, target_pc);

        // Jump to dispatcher (will be patched later)
        Label dispatcherLabel = a->newLabel();
        a->jmp(dispatcherLabel);
        a->bind(dispatcherLabel);

        return true;
    } else if (arch.compare("aarch64") == 0) {
        auto *a = getTypedAssembler<a64::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // Load immediate into destination register
        a64::Gp regPtr = a64::x19; // VM_REGISTERS_PTR in x19
        a64::Gp pcReg = a64::w23;  // PC in w23
        a64::Gp tempReg = a64::x0; // Temporary register

        // Load the immediate value in target register
        a->mov(tempReg, (uint64_t)immediate);
        a->str(tempReg, a64::ptr(regPtr, dest_reg * 8));

        // Set PC to target and jump
        a->mov(pcReg, target_pc);

        // Jump to dispatcher (will be patched later)
        Label dispatcherLabel = a->newLabel();
        a->b(dispatcherLabel);
        a->bind(dispatcherLabel);

        return true;
    }

    return false;
}

// Generate load immediate and jump indirect
bool jit_generateLoadImmJumpInd(
    void *assembler,
    const char *target_arch,
    uint8_t dest_reg,
    uint32_t immediate,
    uint8_t jump_reg)
{
    std::string arch(target_arch);

    if (arch.compare("x86_64") == 0) {
        auto *a = getTypedAssembler<x86::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // Load immediate into destination register and jump to target register
        x86::Gp regPtr = x86::rbx;  // VM_REGISTERS_PTR in rbx
        x86::Gp pcReg = x86::r15d;  // PC in r15d
        x86::Gp tempReg = x86::rax; // Temporary register

        // Load the immediate value in target register
        a->mov(tempReg, (uint64_t)immediate);
        a->mov(x86::qword_ptr(regPtr, dest_reg * 8), tempReg);

        // Load jump target from register
        a->mov(tempReg, x86::qword_ptr(regPtr, jump_reg * 8));
        a->mov(pcReg, x86::eax); // Move lower 32 bits to PC

        // Jump to dispatcher (will be patched later)
        Label dispatcherLabel = a->newLabel();
        a->jmp(dispatcherLabel);
        a->bind(dispatcherLabel);

        return true;
    } else if (arch.compare("aarch64") == 0) {
        auto *a = getTypedAssembler<a64::Assembler>(assembler, target_arch);
        if (!a)
            return false;

        // Load immediate into destination register and jump to target register
        a64::Gp regPtr = a64::x19;    // VM_REGISTERS_PTR in x19
        a64::Gp pcReg = a64::w23;     // PC in w23
        a64::Gp tempReg = a64::x0;    // Temporary register
        a64::Gp jumpTarget = a64::x1; // Target register for jump

        // Load the immediate value in target register
        a->mov(tempReg, (uint64_t)immediate);
        a->str(tempReg, a64::ptr(regPtr, dest_reg * 8));

        // Load jump target from register
        a->ldr(jumpTarget, a64::ptr(regPtr, jump_reg * 8));
        a->mov(pcReg, a64::w1); // Move lower 32 bits to PC

        // Jump to dispatcher (will be patched later)
        Label dispatcherLabel = a->newLabel();
        a->b(dispatcherLabel);
        a->bind(dispatcherLabel);

        return true;
    }

    return false;
}
