// generated by polka.codes
// Label manager for single-pass JIT compilation with lazy label creation
// Based on PolkaVM recompiler architecture documentation

#pragma once

#include <asmjit/asmjit.h>
#include <cstdint>
#include <unordered_map>
#include <unordered_set>

namespace JIT {

// Label manager for JIT compilation
// Implements single-pass compilation with lazy label creation and backpatching
class LabelManager {
public:
    LabelManager() = default;
    ~LabelManager() = default;

    // Get or create label for a PC (lazy creation)
    // Returns the label associated with this PC
    // Creates a new label if one doesn't exist
    asmjit::Label getOrCreateLabel(asmjit::Assembler* assembler, uint32_t pc) {
        auto it = labels.find(pc);
        if (it != labels.end()) {
            return it->second;
        }

        // Create new label (forward declaration)
        asmjit::Label label = assembler->newLabel();
        labels[pc] = label;
        return label;
    }

    // Bind label at current position if it exists
    // Marks this location as the target for jumps to this PC
    void bindLabel(asmjit::Assembler* assembler, uint32_t pc) {
        auto it = labels.find(pc);
        if (it != labels.end()) {
            // Label already created (forward reference), now bind it
            assembler->bind(it->second);
            definedLabels.insert(pc);
        } else {
            // Create and bind label immediately (no forward reference)
            asmjit::Label label = assembler->newLabel();
            labels[pc] = label;
            assembler->bind(label);
            definedLabels.insert(pc);
        }
    }

    // Check if a PC is a jump target
    bool isJumpTarget(uint32_t pc) const {
        return labels.find(pc) != labels.end();
    }

    // Check if a label has been defined (bound) at this PC
    bool isLabelDefined(uint32_t pc) const {
        return definedLabels.find(pc) != definedLabels.end();
    }

    // Get label for PC without creating (returns invalid label if not found)
    asmjit::Label getLabel(uint32_t pc) const {
        auto it = labels.find(pc);
        if (it != labels.end()) {
            return it->second;
        }
        return asmjit::Label(); // Invalid label
    }

    // Mark a PC as a jump target (pre-declare label)
    // Useful for analysis phase to mark all potential targets
    void markJumpTarget(uint32_t pc) {
        if (labels.find(pc) == labels.end()) {
            // Don't create label yet, just mark as target
            // Label will be created when first referenced or bound
            markedTargets.insert(pc);
        }
    }

    // Check if PC was marked as a target
    bool isMarkedTarget(uint32_t pc) const {
        return markedTargets.find(pc) != markedTargets.end();
    }

    // Get all PCs with labels
    std::vector<uint32_t> getAllPCs() const {
        std::vector<uint32_t> pcs;
        pcs.reserve(labels.size());
        for (const auto& entry : labels) {
            pcs.push_back(entry.first);
        }
        return pcs;
    }

    // Clear all state
    void clear() {
        labels.clear();
        definedLabels.clear();
        markedTargets.clear();
    }

    // Get number of labels
    size_t size() const {
        return labels.size();
    }

private:
    std::unordered_map<uint32_t, asmjit::Label> labels;
    std::unordered_set<uint32_t> definedLabels;
    std::unordered_set<uint32_t> markedTargets;
};

} // namespace JIT
