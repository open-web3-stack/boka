// generated by polka.codes
// Label manager for single-pass JIT compilation with lazy label creation
// Based on PolkaVM recompiler architecture documentation

#pragma once

#include <asmjit/a64.h>
#include <asmjit/x86.h>
#include <asmjit/core.h>
#include <cstdint>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace JIT {

// Label manager for JIT compilation
// Implements single-pass compilation with lazy label creation and backpatching
// Works with void* assembler pointers (cast to specific types as needed)
class LabelManager {
public:
    LabelManager() = default;
    ~LabelManager() = default;

    // Get or create label for a PC (lazy creation)
    // Returns the label associated with this PC
    // Creates a new label if one doesn't exist
    asmjit::Label getOrCreateLabel(void* assembler, uint32_t pc, const char* arch) {
        auto it = labels.find(pc);
        if (it != labels.end()) {
            return it->second;
        }

        // Create new label (forward declaration)
        asmjit::Label label;

        if (strcmp(arch, "x86_64") == 0) {
            auto* a = static_cast<asmjit::x86::Assembler*>(assembler);
            label = a->new_label();
        } else if (strcmp(arch, "aarch64") == 0) {
            auto* a = static_cast<asmjit::a64::Assembler*>(assembler);
            label = a->new_label();
        }

        labels[pc] = label;
        return label;
    }

    // Bind label at current position if it exists
    // Marks this location as the target for jumps to this PC
    void bindLabel(void* assembler, uint32_t pc, const char* arch) {
        auto it = labels.find(pc);
        asmjit::Label label;

        if (it != labels.end()) {
            // Label already created (forward reference), now bind it
            label = it->second;
        } else {
            // Create and bind label immediately (no forward reference)
            if (strcmp(arch, "x86_64") == 0) {
                auto* a = static_cast<asmjit::x86::Assembler*>(assembler);
                label = a->new_label();
            } else if (strcmp(arch, "aarch64") == 0) {
                auto* a = static_cast<asmjit::a64::Assembler*>(assembler);
                label = a->new_label();
            }
            labels[pc] = label;
        }

        // Bind the label
        if (strcmp(arch, "x86_64") == 0) {
            auto* a = static_cast<asmjit::x86::Assembler*>(assembler);
            a->bind(label);
        } else if (strcmp(arch, "aarch64") == 0) {
            auto* a = static_cast<asmjit::a64::Assembler*>(assembler);
            a->bind(label);
        }

        definedLabels.insert(pc);
    }

    // Check if a PC is a jump target
    bool isJumpTarget(uint32_t pc) const {
        return labels.find(pc) != labels.end();
    }

    // Check if a label has been defined (bound) at this PC
    bool isLabelDefined(uint32_t pc) const {
        return definedLabels.find(pc) != definedLabels.end();
    }

    // Get label for PC without creating (returns invalid label if not found)
    asmjit::Label getLabel(uint32_t pc) const {
        auto it = labels.find(pc);
        if (it != labels.end()) {
            return it->second;
        }
        return asmjit::Label(); // Invalid label
    }

    // Mark a PC as a jump target (pre-declare label)
    // Useful for analysis phase to mark all potential targets
    void markJumpTarget(uint32_t pc) {
        if (labels.find(pc) == labels.end()) {
            // Don't create label yet, just mark as target
            // Label will be created when first referenced or bound
            markedTargets.insert(pc);
        }
    }

    // Check if PC was marked as a target
    bool isMarkedTarget(uint32_t pc) const {
        return markedTargets.find(pc) != markedTargets.end();
    }

    // Get all PCs with labels
    std::vector<uint32_t> getAllPCs() const {
        std::vector<uint32_t> pcs;
        pcs.reserve(labels.size());
        for (const auto& entry : labels) {
            pcs.push_back(entry.first);
        }
        return pcs;
    }

    // Clear all state
    void clear() {
        labels.clear();
        definedLabels.clear();
        markedTargets.clear();
    }

    // Get number of labels
    size_t size() const {
        return labels.size();
    }

private:
    std::unordered_map<uint32_t, asmjit::Label> labels;
    std::unordered_set<uint32_t> definedLabels;
    std::unordered_set<uint32_t> markedTargets;
};

} // namespace JIT
