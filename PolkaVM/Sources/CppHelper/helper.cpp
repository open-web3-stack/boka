// generated by polka.codes
#include "helper.hh"
#include "instruction_emitter.hh"
#include <stdio.h>
#include <cstring>

using namespace asmjit;

// Declare the extern C wrapper from instruction_dispatcher.cpp
extern "C" bool jit_emitter_emit_basic_block_instructions(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    const uint8_t* _Nonnull bytecode,
    uint32_t start_pc,
    uint32_t end_pc
);

// Trampoline for JIT code to call Swift host functions
// Called by JIT-generated code when executing ECALL instructions
uint32_t pvm_host_call_trampoline(
    JITHostFunctionTable* host_table,
    uint32_t host_call_index,
    uint64_t* guest_registers_ptr,
    uint8_t* guest_memory_base_ptr,
    uint32_t guest_memory_size,
    uint64_t* guest_gas_ptr) {

    if (!host_table || !host_table->dispatchHostCall) {
        // TODO: Implement proper error logging with error codes
        return 0xFFFFFFFF; // Error code for HostFunctionError (matches ExitReason.PanicReason)
    }

    // Dispatch to Swift implementation with invocationContext (passed implicitly through host_table)
    return host_table->dispatchHostCall(
        host_table->ownerContext,
        host_call_index,
        guest_registers_ptr,
        guest_memory_base_ptr,
        guest_memory_size,
        guest_gas_ptr,
        host_table->invocationContext
    );
}

// Compile a range of bytecode instructions to machine code
// This function bridges Swift's ProgramCode parsing with C++ instruction emission
bool compile_bytecode_range(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    const uint8_t* _Nonnull bytecode,
    size_t bytecode_size,
    uint32_t start_pc,
    uint32_t end_pc)
{
    // Validate inputs
    if (!assembler || !target_arch || !bytecode) {
        return false;
    }

    if (bytecode_size == 0 || start_pc >= end_pc) {
        return false;
    }

    if (end_pc > bytecode_size) {
        return false;
    }

    // Call the extern C wrapper to the instruction emitter
    // This function handles all 194 implemented instructions
    return jit_emitter_emit_basic_block_instructions(assembler, target_arch, bytecode, start_pc, end_pc);
}

// Get the size of an instruction in bytes
// This matches ONLY the opcodes actually implemented in instruction_dispatcher.cpp
// For unimplemented opcodes, returns 0 to signal an error
uint32_t get_instruction_size(const uint8_t* bytecode, uint32_t pc, size_t bytecode_size) {
    if (pc >= bytecode_size) {
        return 0;
    }

    uint8_t opcode = bytecode[pc];

    // Instruction size lookup table - MUST match instruction_dispatcher.cpp exactly
    // Only includes opcodes that are actually implemented in the dispatcher's switch statement
    // Sizes are extracted from the decode functions in instruction_dispatcher.cpp
    switch (opcode) {
        // 1-byte instructions
        case 0:  // Trap
        case 1:  // Fallthrough
            return 1;

        // LoadImm64: [opcode][reg_index][value_64bit] = 10 bytes
        case 20:
            return 10;

        // StoreImmU8/U16/U32/U64
        case 30:  // StoreImmU8: [opcode][value_8bit][address_32bit] = 6 bytes
            return 6;
        case 31:  // StoreImmU16: [opcode][value_16bit][address_32bit] = 7 bytes
            return 7;
        case 32:  // StoreImmU32: [opcode][value_32bit][address_32bit] = 9 bytes
            return 9;
        case 33:  // StoreImmU64: [opcode][value_64bit][address_32bit] = 13 bytes
            return 13;

        // Jump: [opcode][offset_32bit] = 5 bytes
        case 40:
            return 5;

        // JumpInd: [opcode][reg_index] = 2 bytes
        case 50:
            return 2;

        // LoadImm: [opcode][reg_index][value_32bit] = 6 bytes
        case 51:
            return 6;

        // Load instructions: [opcode][reg_index][address_32bit] = 6 bytes
        case 52:  // LoadU8
        case 53:  // LoadI8
        case 54:  // LoadU16
        case 55:  // LoadI16
        case 56:  // LoadU32
        case 57:  // LoadI32
        case 58:  // LoadU64
            return 6;

        // Store instructions: [opcode][reg_index][address_32bit] = 6 bytes
        case 59:  // StoreU8
        case 60:  // StoreU16
        case 61:  // StoreU32
        case 62:  // StoreU64
            return 6;

        // Branch instructions: [opcode][reg1][reg2][offset_32bit] = 7 bytes
        case 170:  // BranchEq
        case 171:  // BranchNe
            return 7;

        // 32-bit arithmetic: [opcode][dest_reg][src_reg] = 3 bytes
        case 190: // Add32
        case 191: // Sub32
        case 192: // Mul32
        case 193: // DivU32
        case 194: // DivS32
        case 195: // RemU32
        case 196: // RemS32
            return 3;

        // 64-bit arithmetic: [opcode][dest_reg][src_reg] = 3 bytes
        case 200: // Add64
        case 201: // Sub64
        case 202: // Mul64
            return 3;

        // Bitwise operations: [opcode][dest_reg][src_reg] = 3 bytes
        case 210: // And
        case 211: // Xor
        case 212: // Or
            return 3;

        // For unimplemented opcodes, return 0 to signal error
        default:
            return 0;
    }
}
