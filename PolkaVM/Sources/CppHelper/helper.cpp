// generated by polka.codes
#include "helper.hh"
#include "opcodes.hh"
#include <stdio.h>
#include <cstring>

using namespace asmjit;
using namespace PVM;

// Declare the extern C wrapper from instruction_dispatcher.cpp
extern "C" bool jit_emitter_emit_basic_block_instructions(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    const uint8_t* _Nonnull bytecode,
    uint32_t start_pc,
    uint32_t end_pc
);

// Trampoline for JIT code to call Swift host functions
// Called by JIT-generated code when executing ECALL instructions
uint32_t pvm_host_call_trampoline(
    JITHostFunctionTable* _Nonnull host_table,
    uint32_t host_call_index,
    uint64_t* _Nonnull guest_registers_ptr,
    uint8_t* _Nonnull guest_memory_base_ptr,
    uint32_t guest_memory_size,
    uint64_t* _Nonnull guest_gas_ptr) noexcept {

    if (!host_table || !host_table->dispatchHostCall) {
        // TODO: Implement proper error logging with error codes
        return 0xFFFFFFFF; // Error code for HostFunctionError (matches ExitReason.PanicReason)
    }

    // Dispatch to Swift implementation with invocationContext (passed implicitly through host_table)
    return host_table->dispatchHostCall(
        host_table->ownerContext,
        host_call_index,
        guest_registers_ptr,
        guest_memory_base_ptr,
        guest_memory_size,
        guest_gas_ptr,
        host_table->invocationContext
    );
}

// Compile a range of bytecode instructions to machine code
// This function bridges Swift's ProgramCode parsing with C++ instruction emission
bool compile_bytecode_range(
    void* _Nonnull assembler,
    const char* _Nonnull target_arch,
    const uint8_t* _Nonnull bytecode,
    size_t bytecode_size,
    uint32_t start_pc,
    uint32_t end_pc) noexcept
{
    // Validate inputs
    if (!assembler || !target_arch || !bytecode) {
        return false;
    }

    if (bytecode_size == 0 || start_pc >= end_pc) {
        return false;
    }

    if (end_pc > bytecode_size) {
        return false;
    }

    // Call the extern C wrapper to the instruction emitter
    // This function handles all implemented PVM instructions
    return jit_emitter_emit_basic_block_instructions(assembler, target_arch, bytecode, start_pc, end_pc);
}

// Get the size of an instruction in bytes
// This matches ONLY the opcodes actually implemented in instruction_dispatcher.cpp
// For unimplemented opcodes, returns 0 to signal an error
uint32_t get_instruction_size(const uint8_t* _Nonnull bytecode, uint32_t pc, size_t bytecode_size) noexcept {
    if (pc >= bytecode_size) {
        return 0;
    }

    uint8_t opcode = bytecode[pc];

    // Instruction size lookup table - MUST match instruction_dispatcher.cpp exactly
    // Only includes opcodes that are actually implemented in the dispatcher's switch statement
    // Sizes are extracted from the decode functions in instruction_dispatcher.cpp
    uint32_t instrSize = 0;
    switch (static_cast<Opcode>(opcode)) {
        // 1-byte instructions
        case Opcode::Trap:
        case Opcode::Halt:
            instrSize = InstructionSize::Trap;
            break;

        // Ecalli has compact variable-width immediate encoding.
        // Exact instruction length must come from skip table / bitmask.
        case Opcode::Ecalli:
            return 0;
            break;

        // LoadImm64: [opcode][reg_index][value_64bit] = 10 bytes
        case Opcode::LoadImmU64:
            instrSize = InstructionSize::LoadImm64;
            break;

        // StoreImmU8/U16/U32/U64 have compact variable-width immediates.
        // Exact instruction length must come from skip table / bitmask.
        case Opcode::StoreImmU8:
        case Opcode::StoreImmU16:
        case Opcode::StoreImmU32:
        case Opcode::StoreImmU64:
            return 0;
            break;

        // Jump: [opcode][offset_32bit] = 5 bytes
        case Opcode::Jump:
            instrSize = InstructionSize::Jump;
            break;

        // JumpInd: [opcode][reg_index] = 2 bytes
        case Opcode::JumpInd:
            instrSize = InstructionSize::JumpInd;
            break;

        // LoadImm has compact variable-width immediate encoding.
        // Exact instruction length must come from skip table / bitmask.
        case Opcode::LoadImm:
            return 0;
            break;

        // LoadImmJump uses compact variable-width immediate encoding.
        // Exact instruction length must come from skip table / bitmask.
        case Opcode::LoadImmJump:
            return 0;
            break;

        // LoadImmJumpInd has compact variable-width immediates.
        // Exact instruction length must come from skip table / bitmask.
        case Opcode::LoadImmJumpInd:
            return 0;
            break;

        // Branch immediate instructions (opcodes 81-90) use compact variable-width
        // immediates. Exact instruction length must come from skip table / bitmask.
        case Opcode::BranchEqImm:
        case Opcode::BranchNeImm:
        case Opcode::BranchLtUImm:
        case Opcode::BranchLeUImm:
        case Opcode::BranchGeUImm:
        case Opcode::BranchGtUImm:
        case Opcode::BranchLtSImm:
        case Opcode::BranchLeSImm:
        case Opcode::BranchGeSImm:
        case Opcode::BranchGtSImm:
            return 0;
            break;

        // Load instructions: [opcode][reg_index][address_32bit] = 6 bytes
        case Opcode::LoadU8:
        case Opcode::LoadI8:
        case Opcode::LoadU16:
        case Opcode::LoadI16:
        case Opcode::LoadU32:
        case Opcode::LoadI32:
        case Opcode::LoadU64:
            instrSize = InstructionSize::LoadU8;
            break;

        // Store instructions: [opcode][reg_index][address_32bit] = 6 bytes
        case Opcode::StoreU8:
        case Opcode::StoreU16:
        case Opcode::StoreU32:
        case Opcode::StoreU64:
            instrSize = InstructionSize::StoreU8;
            break;

        // StoreImmIndU8/U16/U32/U64 have compact variable-width immediates.
        // Exact instruction length must come from skip table / bitmask.
        case Opcode::StoreImmIndU8:
        case Opcode::StoreImmIndU16:
        case Opcode::StoreImmIndU32:
        case Opcode::StoreImmIndU64:
            return 0;
            break;

        // Store Indirect instructions (opcodes 120-123)
        // Format: [opcode][src_reg][dest_reg][offset_32bit] = 7 bytes
        case Opcode::StoreIndU8:
        case Opcode::StoreIndU16:
        case Opcode::StoreIndU32:
        case Opcode::StoreIndU64:
            instrSize = 7; // 1 + 1 + 1 + 4 = 7 bytes
            break;

        // Load Indirect instructions (opcodes 124-130)
        // Format: [opcode][ra][rb][offset_32bit] = 7 bytes
        case Opcode::LoadIndU8:
        case Opcode::LoadIndI8:
        case Opcode::LoadIndU16:
        case Opcode::LoadIndI16:
        case Opcode::LoadIndU32:
        case Opcode::LoadIndI32:
        case Opcode::LoadIndU64:
            instrSize = 7; // 1 + 1 + 1 + 4 = 7 bytes
            break;

        // 32-bit immediate instructions (opcodes 131-148) use compact variable-width
        // immediate encoding. Exact instruction length must come from skip table / bitmask.
        case Opcode::AddImm32:
        case Opcode::AndImm:
        case Opcode::XorImm:
        case Opcode::OrImm:
        case Opcode::MulImm32:
        case Opcode::SetLtUImm:
        case Opcode::SetLtSImm:
        case Opcode::ShloLImm32:
        case Opcode::ShloRImm32:
        case Opcode::SharRImm32:
        case Opcode::NegAddImm32:
        case Opcode::SetGtUImm:
        case Opcode::SetGtSImm:
        case Opcode::ShloLImmAlt32:
        case Opcode::ShloRImmAlt32:
        case Opcode::SharRImmAlt32:
        case Opcode::CmovIzImm:
        case Opcode::CmovNzImm:
            return 0;
            break;

        // 64-bit Immediate instructions (opcodes 149-161)
        // Format: [opcode][packed_ra_rb][value_le32] = 6 bytes
        // where packed_ra_rb contains both registers in one byte
        case Opcode::AddImm64:
        case Opcode::MulImm64:
        case Opcode::ShloLImm64:
        case Opcode::ShloRImm64:
        case Opcode::SharRImm64:
        case Opcode::NegAddImm64:
        case Opcode::ShloLImmAlt64:
        case Opcode::ShloRImmAlt64:
        case Opcode::SharRImmAlt64:
        case Opcode::RotR64Imm:
        case Opcode::RotR64ImmAlt:
        case Opcode::RotR32Imm:
        case Opcode::RotR32ImmAlt:
            instrSize = 6; // opcode (1) + packed registers (1) + immediate (4)
            break;

        // Branch instructions: [opcode][reg1][reg2][offset_32bit] = 7 bytes
        case Opcode::BranchEq:
        case Opcode::BranchNe:
            instrSize = InstructionSize::BranchEq;
            break;

        // Additional branch instructions (same format as BranchEq)
        case Opcode::BranchLtU:
        case Opcode::BranchLtS:
        case Opcode::BranchGeU:
        case Opcode::BranchGeS:
            instrSize = InstructionSize::BranchEq;
            break;

        // 32-bit arithmetic: [opcode][dest_reg][src_reg] = 3 bytes
        case Opcode::Add32:
        case Opcode::Sub32:
        case Opcode::Mul32:
        case Opcode::DivU32:
        case Opcode::DivS32:
        case Opcode::RemU32:
        case Opcode::RemS32:
        case Opcode::ShloL32:
        case Opcode::ShloR32:
        case Opcode::SharR32:
            instrSize = InstructionSize::Arithmetic32;
            break;

        // 64-bit arithmetic: [opcode][dest_reg][src_reg] = 3 bytes
        case Opcode::Add64:
        case Opcode::Sub64:
        case Opcode::Mul64:
        case Opcode::DivU64:
        case Opcode::DivS64:
        case Opcode::RemU64:
        case Opcode::RemS64:
        case Opcode::ShloL64:
        case Opcode::ShloR64:
        case Opcode::SharR64:
            instrSize = InstructionSize::Arithmetic64;
            break;

        // Bitwise operations: [opcode][dest_reg][src_reg] = 3 bytes
        case Opcode::And:
        case Opcode::Xor:
        case Opcode::Or:
            instrSize = InstructionSize::Bitwise;
            break;

        // 3-register instructions: [opcode][rd][ra][rb] = 4 bytes
        case Opcode::MulUpperSS:      // 213
        case Opcode::MulUpperUU:      // 214
        case Opcode::MulUpperSU:      // 215
        case Opcode::SetLtU:          // 216
        case Opcode::SetLtS:          // 217
        case Opcode::CmovIz:          // 218
        case Opcode::CmovNz:          // 219
        case Opcode::RotL64:          // 220
        case Opcode::RotR64:          // 222
        case Opcode::Max:             // 227
        case Opcode::MaxU:            // 228
        case Opcode::Min:             // 229
        case Opcode::MinU:            // 230
            instrSize = 4;  // 3-register format
            break;

        // 3-register rotate instructions: [opcode][ra|rb<<4][rd] = 4 bytes
        case Opcode::RotL32:          // 221
        case Opcode::RotR32:          // 223
            instrSize = 4;  // 3-register format (ra, rb, rd)
            break;

        // For unimplemented opcodes, return 0 to signal error
        default:
            return 0;
    }

    // Verify the full instruction fits within the bytecode buffer
    if (instrSize > 0 && (bytecode_size - pc) < instrSize) {
        return 0; // Instruction extends beyond buffer bounds
    }

    return instrSize;
}

// ============================================================================
// MARK: - Memory Management (Dispatcher Table Cleanup)
// ============================================================================

/// Forward declarations from architecture-specific files
extern "C" void freeDispatcherTable_x64(
    void* _Nonnull context,
    void* _Nullable funcPtr) noexcept;
extern "C" void freeDispatcherTable_a64(
    void* _Nonnull context,
    void* _Nullable funcPtr) noexcept;
extern "C" void freeAllDispatcherTables_x64(void* _Nonnull context) noexcept;
extern "C" void freeAllDispatcherTables_a64(void* _Nonnull context) noexcept;
extern "C" void releaseJITFunction_x64(
    void* _Nonnull context,
    void* _Nullable funcPtr) noexcept;
extern "C" void releaseJITFunction_a64(
    void* _Nonnull context,
    void* _Nullable funcPtr) noexcept;

/// Free the dispatcher table associated with a JIT-compiled function
/// This is a wrapper that calls the appropriate architecture-specific implementation
///
/// @param context Runtime context owning the dispatcher table
/// @param funcPtr Function pointer returned by compilePolkaVMCode_x64_labeled or compilePolkaVMCode_a64_labeled
/// @note Safe to call with nullptr or function pointers that don't have tables
extern "C" void freeDispatcherTable(
    void* _Nonnull context,
    void* _Nullable funcPtr) noexcept {
    if (!context || !funcPtr) {
        return;
    }

    // Try x64 first (most common)
    freeDispatcherTable_x64(context, funcPtr);

    // ARM64 is a no-op currently (no dispatcher tables stored)
    // freeDispatcherTable_a64(context, funcPtr);
}

/// Free ALL dispatcher tables
/// This is a wrapper that calls all architecture-specific implementations
///
/// @param context Runtime context whose dispatcher tables should be freed
extern "C" void freeAllDispatcherTables(void* _Nonnull context) noexcept {
    if (!context) {
        return;
    }
    freeAllDispatcherTables_x64(context);
    // ARM64 version is a no-op
    // freeAllDispatcherTables_a64(context);
}

/// Release JIT-compiled code memory
/// This is a wrapper that calls all architecture-specific implementations
///
/// @param context Runtime context owning the JIT runtime
/// @param funcPtr Function pointer to release
/// @note Safe to call with nullptr
/// @warning After calling this, the function pointer becomes invalid and must not be called
extern "C" void releaseJITFunction(
    void* _Nonnull context,
    void* _Nullable funcPtr) noexcept {
    if (!context || !funcPtr) {
        return;
    }

    // Try x64 first (most common)
    releaseJITFunction_x64(context, funcPtr);

    // TODO: Add ARM64 support when needed
    // releaseJITFunction_a64(context, funcPtr);
}

// ============================================================================
// MARK: - Memory Protection
// ============================================================================

/// Update page map bitmaps to mark a region as readable/writable
///
/// This function sets bits in the readMap and/or writeMap bitmaps to mark
/// pages as accessible. Each bitmap is 128KB (2^20 bits), with 1 bit per 4KB page.
///
/// @param ctx JIT host function table containing the bitmap pointers
/// @param start Start address of the region to mark
/// @param size Size of the region in bytes
/// @param readable Whether to mark pages as readable
/// @param writable Whether to mark pages as writable
extern "C" void pvm_update_page_map(
    JITHostFunctionTable* _Nonnull ctx,
    uint32_t start,
    uint32_t size,
    bool readable,
    bool writable) noexcept {

    // Page size is 4KB (2^12 bytes)
    constexpr uint32_t PAGE_SIZE = 4096;

    // Calculate page range
    uint32_t startPage = start / PAGE_SIZE;
    uint32_t endPage = (start + size + PAGE_SIZE - 1) / PAGE_SIZE;

    // Mark pages as readable
    if (readable && ctx->readMap) {
        for (uint32_t page = startPage; page < endPage; ++page) {
            uint32_t byteIndex = page / 8;
            uint32_t bitIndex = page % 8;
            ctx->readMap[byteIndex] |= (1 << bitIndex);
        }
    }

    // Mark pages as writable
    if (writable && ctx->writeMap) {
        for (uint32_t page = startPage; page < endPage; ++page) {
            uint32_t byteIndex = page / 8;
            uint32_t bitIndex = page % 8;
            ctx->writeMap[byteIndex] |= (1 << bitIndex);
        }
    }
}
