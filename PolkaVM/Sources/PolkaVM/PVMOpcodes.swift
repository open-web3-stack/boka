// generated by polka.codes
// PVM Instruction Opcodes - Swift mirror of C++ opcodes.hh
//
// This file provides Swift enum values that match the C++ Opcode enum.
// When updating opcodes in C++, ensure this file is updated to match.

import Foundation

/// PVM instruction opcodes
/// These values MUST match the C++ opcodes.hh file exactly.
enum PVMOpcodes: UInt8 {
    // Control Flow Instructions
    case trap = 0
    case halt = 1
    case jump = 40
    case jumpInd = 50
    case loadImmJump = 80
    case loadImmJumpInd = 180  // Load immediate and jump indirect

    // Load Immediate Instructions
    case loadImm = 51      // LoadImm (32-bit immediate) - primary load immediate
    case loadImmU64 = 20   // LoadImm64 (64-bit immediate)

    // Load Instructions
    case loadU8 = 52
    case loadI8 = 53
    case loadU16 = 54
    case loadI16 = 55
    case loadU32 = 56
    case loadI32 = 57
    case loadU64 = 58

    // Store Instructions
    case storeU8 = 59
    case storeU16 = 60
    case storeU32 = 61
    case storeU64 = 62
    case storeImmU8 = 30
    case storeImmU16 = 31
    case storeImmU32 = 32
    case storeImmU64 = 33

    case ecalli = 10       // External call interface (host call)

    // Branch Immediate Instructions (Phase 3)
    case branchEqImm = 81
    case branchNeImm = 82
    case branchLtUImm = 83
    case branchLeUImm = 84
    case branchGeUImm = 85
    case branchGtUImm = 86
    case branchLtSImm = 87
    case branchLeSImm = 88
    case branchGeSImm = 89
    case branchGtSImm = 90

    // Store Immediate Indirect Instructions (Phase 2)
    case storeImmIndU8 = 70
    case storeImmIndU16 = 71
    case storeImmIndU32 = 72
    case storeImmIndU64 = 73

    // Store Indirect Instructions (Phase 2)
    case storeIndU8 = 120
    case storeIndU16 = 121
    case storeIndU32 = 122
    case storeIndU64 = 123

    // Load Indirect Instructions (Phase 2)
    case loadIndU8 = 124
    case loadIndI8 = 125
    case loadIndU16 = 126
    case loadIndI16 = 127
    case loadIndU32 = 128
    case loadIndI32 = 129
    case loadIndU64 = 130

    // 32-bit Immediate Instructions (Phase 4)
    case addImm32 = 131
    case andImm = 132
    case xorImm = 133
    case orImm = 134
    case mulImm32 = 135
    case setLtUImm = 136
    case setLtSImm = 137
    case shloLImm32 = 138
    case shloRImm32 = 139
    case sharRImm32 = 140
    case negAddImm32 = 141
    case setGtUImm = 142
    case setGtSImm = 143
    case shloLImmAlt32 = 144
    case shloRImmAlt32 = 145
    case sharRImmAlt32 = 146
    case cmovIzImm = 147
    case cmovNzImm = 148

    // 64-bit Immediate Instructions (Phase 4)
    case addImm64 = 149
    case mulImm64 = 150
    case shloLImm64 = 151
    case shloRImm64 = 152
    case sharRImm64 = 153
    case negAddImm64 = 154
    case shloLImmAlt64 = 155
    case shloRImmAlt64 = 156
    case sharRImmAlt64 = 157
    case rotR64Imm = 158
    case rotR64ImmAlt = 159
    case rotR32Imm = 160
    case rotR32ImmAlt = 161

    // Branch Instructions
    case branchEq = 170
    case branchNe = 171
    case branchLtU = 172
    case branchLtS = 173
    case branchGeU = 174
    case branchGeS = 175

    // 32-bit Arithmetic Instructions
    case add32 = 190
    case sub32 = 191
    case mul32 = 192
    case divU32 = 193
    case divS32 = 194
    case remU32 = 195
    case remS32 = 196
    case shloL32 = 197      // Shift left logical 32-bit
    case shloR32 = 198      // Shift right logical 32-bit
    case sharR32 = 199      // Shift right arithmetic 32-bit

    // 64-bit Arithmetic Instructions
    case add64 = 200
    case sub64 = 201
    case mul64 = 202
    case divU64 = 203
    case divS64 = 204
    case remU64 = 205
    case remS64 = 206
    case shloL64 = 207      // Shift left logical 64-bit
    case shloR64 = 208      // Shift right logical 64-bit
    case sharR64 = 209      // Shift right arithmetic 64-bit

    // Bitwise Operations
    case and = 210
    case xor = 211
    case or = 212
    case mulUpperSS = 213
    case mulUpperUU = 214
    case mulUpperSU = 215
    case setLtU = 216      // Set less than unsigned
    case setLtS = 217      // Set less than signed
    case cmovIz = 218      // Conditional move if zero
    case cmovNz = 219      // Conditional move if not zero
    case rotL64 = 220      // Rotate left 64-bit
    case rotL32 = 221      // Rotate left 32-bit
    case rotR64 = 222      // Rotate right 64-bit
    case rotR32 = 223      // Rotate right 32-bit
    case andInv = 224      // Bitwise AND with inverted operand
    case orInv = 225       // Bitwise OR with inverted operand
    case xnor = 226        // Bitwise XNOR
    case max = 227         // Maximum signed
    case maxU = 228        // Maximum unsigned
    case min = 229         // Minimum signed
    case minU = 230        // Minimum unsigned
}
