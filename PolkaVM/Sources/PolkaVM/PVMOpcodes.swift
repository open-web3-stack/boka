// generated by polka.codes
// PVM Instruction Opcodes - Swift mirror of C++ opcodes.hh
//
// This file provides Swift enum values that match the C++ Opcode enum.
// When updating opcodes in C++, ensure this file is updated to match.

import Foundation

/// PVM instruction opcodes
/// These values MUST match the C++ opcodes.hh file exactly.
enum PVMOpcodes: UInt8 {
    // Control Flow Instructions
    case trap = 0
    case halt = 1
    case jump = 40
    case jumpInd = 50
    case loadImmJump = 80

    // Load Immediate Instructions
    case loadImm = 51      // LoadImm (32-bit immediate) - primary load immediate
    case loadImmU64 = 20   // LoadImm64 (64-bit immediate)

    // Load Instructions
    case loadU8 = 52
    case loadI8 = 53
    case loadU16 = 54
    case loadI16 = 55
    case loadU32 = 56
    case loadI32 = 57
    case loadU64 = 58

    // Store Instructions
    case storeU8 = 59
    case storeU16 = 60
    case storeU32 = 61
    case storeU64 = 62
    case storeImmU8 = 30
    case storeImmU16 = 31
    case storeImmU32 = 32
    case storeImmU64 = 33

    case ecalli = 10       // External call interface (host call)

    // Branch Instructions
    case branchEq = 170
    case branchNe = 171
    case branchLtU = 172
    case branchLtS = 173
    case branchGeU = 174
    case branchGeS = 175

    // 32-bit Arithmetic Instructions
    case add32 = 190
    case sub32 = 191
    case mul32 = 192
    case divU32 = 193
    case divS32 = 194
    case remU32 = 195
    case remS32 = 196
    case shloL32 = 197      // Shift left logical 32-bit
    case shloR32 = 198      // Shift right logical 32-bit
    case sharR32 = 199      // Shift right arithmetic 32-bit

    // 64-bit Arithmetic Instructions
    case add64 = 200
    case sub64 = 201
    case mul64 = 202
    case divU64 = 203
    case divS64 = 204
    case remU64 = 205
    case remS64 = 206
    case shloL64 = 207      // Shift left logical 64-bit
    case shloR64 = 208      // Shift right logical 64-bit
    case sharR64 = 209      // Shift right arithmetic 64-bit

    // Bitwise Operations
    case and = 210
    case xor = 211
    case or = 212
    case mulUpperSS = 213
    case mulUpperUU = 214
    case mulUpperSU = 215
    case setLtU = 216      // Set less than unsigned
    case setLtS = 217      // Set less than signed
    case cmovIz = 218      // Conditional move if zero
    case cmovNz = 219      // Conditional move if not zero
    case rotL64 = 220      // Rotate left 64-bit
    case rotL32 = 221      // Rotate left 32-bit
    case rotR64 = 222      // Rotate right 64-bit
    case rotR32 = 223      // Rotate right 32-bit
    case andInv = 224      // Bitwise AND with inverted operand
    case orInv = 225       // Bitwise OR with inverted operand
    case xnor = 226        // Bitwise XNOR
    case max = 227         // Maximum signed
    case maxU = 228        // Maximum unsigned
    case min = 229         // Minimum signed
    case minU = 230        // Minimum unsigned
}
