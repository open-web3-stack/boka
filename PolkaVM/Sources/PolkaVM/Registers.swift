import CppHelper
import Foundation

public struct Registers: Equatable {
    public typealias Index = CppHelper.RegisterIndex

    public var reg1: UInt64 = 0
    public var reg2: UInt64 = 0
    public var reg3: UInt64 = 0
    public var reg4: UInt64 = 0
    public var reg5: UInt64 = 0
    public var reg6: UInt64 = 0
    public var reg7: UInt64 = 0
    public var reg8: UInt64 = 0
    public var reg9: UInt64 = 0
    public var reg10: UInt64 = 0
    public var reg11: UInt64 = 0
    public var reg12: UInt64 = 0
    public var reg13: UInt64 = 0

    public init() {}

    public init(_ values: [UInt64]) {
        assert(values.count == 13)
        reg1 = values[0]
        reg2 = values[1]
        reg3 = values[2]
        reg4 = values[3]
        reg5 = values[4]
        reg6 = values[5]
        reg7 = values[6]
        reg8 = values[7]
        reg9 = values[8]
        reg10 = values[9]
        reg11 = values[10]
        reg12 = values[11]
        reg13 = values[12]
    }

    /// standard program init registers
    public init(config: any PvmConfig, argumentData: Data?) {
        self[Index(raw: 0)] = UInt64(config.pvmProgramInitRegister1Value)
        self[Index(raw: 1)] = UInt64(config.pvmProgramInitStackBaseAddress)
        self[Index(raw: 7)] = UInt64(config.pvmProgramInitInputStartAddress)
        self[Index(raw: 8)] = UInt64(argumentData?.count ?? 0)
    }

    public subscript(index: Index) -> UInt64 {
        get {
            switch index.value {
            case 0:
                reg1
            case 1:
                reg2
            case 2:
                reg3
            case 3:
                reg4
            case 4:
                reg5
            case 5:
                reg6
            case 6:
                reg7
            case 7:
                reg8
            case 8:
                reg9
            case 9:
                reg10
            case 10:
                reg11
            case 11:
                reg12
            case 12:
                reg13
            default:
                fatalError("unreachable: index out of bounds \(index.value)")
            }
        }
        set {
            switch index.value {
            case 0:
                reg1 = newValue
            case 1:
                reg2 = newValue
            case 2:
                reg3 = newValue
            case 3:
                reg4 = newValue
            case 4:
                reg5 = newValue
            case 5:
                reg6 = newValue
            case 6:
                reg7 = newValue
            case 7:
                reg8 = newValue
            case 8:
                reg9 = newValue
            case 9:
                reg10 = newValue
            case 10:
                reg11 = newValue
            case 11:
                reg12 = newValue
            case 12:
                reg13 = newValue
            default:
                fatalError("unreachable: index out of bounds \(index.value)")
            }
        }
    }
}

extension CppHelper.RegisterIndex: @retroactive Equatable, @retroactive CustomStringConvertible {
    public init(r1: UInt8) {
        self.init(value: min(r1 & 0b1111, 12))
    }

    public init(r2: UInt8) {
        self.init(value: min(r2 >> 4, 12))
    }

    public init(r3: UInt8) {
        self.init(value: min(r3, 12))
    }

    public init(raw: UInt8) {
        self.init(value: raw)
    }

    public var description: String {
        "w\(value)"
    }

    public static func == (lhs: RegisterIndex, rhs: RegisterIndex) -> Bool {
        lhs.value == rhs.value
    }
}

extension Registers: Codable {
    public init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()

        var registers = [UInt64](repeating: 0, count: 13)
        for i in 0 ..< 13 {
            registers[i] = try container.decode(UInt64.self)
        }
        self.init(registers)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()

        for i in 0 ..< 13 {
            try container.encode(self[Registers.Index(raw: UInt8(i))])
        }
    }
}

extension Registers: CustomStringConvertible {
    public var description: String {
        var res = ""
        for i in 0 ..< 13 {
            let value = self[Registers.Index(raw: UInt8(i))]
            let formatted = String(format: "%08X", value)
            res += "w\(i):\t0x\(formatted) | \(value)\n"
        }
        return res
    }
}

// generated by polka.codes
// Extension to provide temporary unsafe mutable pointer access to registers for JIT interaction.
extension Registers {
    /// Provides scoped access to the registers as a contiguous mutable buffer.
    /// This is intended for use with JIT-compiled functions that expect a C-style array of registers.
    ///
    /// - Warning: The pointer is valid only within the scope of the `body` closure.
    ///   The register values are copied to a temporary buffer before the closure is called,
    ///   and copied back from the temporary buffer after the closure returns.
    ///
    /// - Parameter body: A closure that takes an `UnsafeMutablePointer<UInt64>` to the register buffer.
    /// - Returns: The value returned by the `body` closure.
    /// - Throws: Any error thrown by the `body` closure.
    public mutating func withUnsafeMutableRegistersPointer<R>(
        _ body: (UnsafeMutablePointer<UInt64>) throws -> R
    ) rethrows -> R {
        // Create a temporary array to hold register values
        var tempRegisters: [UInt64] = [
            reg1, reg2, reg3, reg4,
            reg5, reg6, reg7, reg8,
            reg9, reg10, reg11, reg12,
            reg13,
        ]

        let result = try tempRegisters.withUnsafeMutableBufferPointer { bufferPointer -> R in
            guard let baseAddress = bufferPointer.baseAddress else {
                // This should ideally not happen with a non-empty array
                fatalError("Could not get base address of temporary register buffer. This indicates a critical issue.")
            }
            return try body(baseAddress)
        }

        // Copy values back from the temporary array
        reg1 = tempRegisters[0]
        reg2 = tempRegisters[1]
        reg3 = tempRegisters[2]
        reg4 = tempRegisters[3]
        reg5 = tempRegisters[4]
        reg6 = tempRegisters[5]
        reg7 = tempRegisters[6]
        reg8 = tempRegisters[7]
        reg9 = tempRegisters[8]
        reg10 = tempRegisters[9]
        reg11 = tempRegisters[10]
        reg12 = tempRegisters[11]
        reg13 = tempRegisters[12]

        return result
    }
}
