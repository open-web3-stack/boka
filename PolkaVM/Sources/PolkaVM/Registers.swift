import CppHelper
import Foundation

public struct Registers: Equatable {
    public typealias Index = CppHelper.RegisterIndex

    private var regs: (UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64) = (
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    )

    public init() {}

    public init(_ values: [UInt64]) {
        assert(values.count == 13)
        regs = (
            values[0],
            values[1],
            values[2],
            values[3],
            values[4],
            values[5],
            values[6],
            values[7],
            values[8],
            values[9],
            values[10],
            values[11],
            values[12]
        )
    }

    /// standard program init registers
    public init(config: any PvmConfig, argumentData: Data?) {
        self[Index(raw: 0)] = UInt64(config.pvmProgramInitRegister0Value)
        self[Index(raw: 1)] = UInt64(config.pvmProgramInitStackBaseAddress)
        self[Index(raw: 7)] = UInt64(config.pvmProgramInitInputStartAddress)
        self[Index(raw: 8)] = UInt64(argumentData?.count ?? 0)
    }

    @inline(__always)
    public subscript(index: Index) -> UInt64 {
        get {
            withUnsafePointer(to: regs) { ptr in
                ptr.withMemoryRebound(to: UInt64.self, capacity: 13) { arrayPtr in
                    arrayPtr[Int(index.value)]
                }
            }
        }
        set {
            withUnsafeMutablePointer(to: &regs) { ptr in
                ptr.withMemoryRebound(to: UInt64.self, capacity: 13) { arrayPtr in
                    arrayPtr[Int(index.value)] = newValue
                }
            }
        }
    }

    public static func == (lhs: Registers, rhs: Registers) -> Bool {
        withUnsafePointer(to: lhs.regs) { lhsPtr in
            withUnsafePointer(to: rhs.regs) { rhsPtr in
                memcmp(
                    lhsPtr,
                    rhsPtr,
                    MemoryLayout<(UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64, UInt64)>
                        .size
                ) == 0
            }
        }
    }
}

extension CppHelper.RegisterIndex: @retroactive Equatable, @retroactive CustomStringConvertible {
    public init(r1: UInt8) {
        self.init(value: min(r1 & 0b1111, 12))
    }

    public init(r2: UInt8) {
        self.init(value: min(r2 >> 4, 12))
    }

    public init(r3: UInt8) {
        self.init(value: min(r3, 12))
    }

    public init(raw: UInt8) {
        self.init(value: raw)
    }

    public var description: String {
        "w\(value)"
    }

    public static func == (lhs: RegisterIndex, rhs: RegisterIndex) -> Bool {
        lhs.value == rhs.value
    }
}

extension Registers: Codable {
    public init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()

        var registers = [UInt64](repeating: 0, count: 13)
        for i in 0 ..< 13 {
            registers[i] = try container.decode(UInt64.self)
        }
        self.init(registers)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()

        for i in 0 ..< 13 {
            try container.encode(self[Registers.Index(raw: UInt8(i))])
        }
    }
}

extension Registers: CustomStringConvertible {
    public var description: String {
        var res = ""
        for i in 0 ..< 13 {
            let value = self[Registers.Index(raw: UInt8(i))]
            let formatted = String(format: "%08X", value)
            res += "w\(i):\t0x\(formatted) | \(value)\n"
        }
        return res
    }
}

// generated by polka.codes
// Extension to provide temporary unsafe mutable pointer access to registers for JIT interaction.
extension Registers {
    /// Provides scoped access to the registers as a contiguous mutable buffer.
    /// This is intended for use with JIT-compiled functions that expect a C-style array of registers.
    ///
    /// - Warning: The pointer is valid only within the scope of the `body` closure.
    ///   The register values are copied to a temporary buffer before the closure is called,
    ///   and copied back from the temporary buffer after the closure returns.
    ///
    /// - Parameter body: A closure that takes an `UnsafeMutablePointer<UInt64>` to the register buffer.
    /// - Returns: The value returned by the `body` closure.
    /// - Throws: Any error thrown by the `body` closure.
    public mutating func withUnsafeMutableRegistersPointer<R>(
        _ body: (UnsafeMutablePointer<UInt64>) throws -> R
    ) rethrows -> R {
        try withUnsafeMutablePointer(to: &regs) { ptr in
            try ptr.withMemoryRebound(to: UInt64.self, capacity: 13) { arrayPtr in
                try body(arrayPtr)
            }
        }
    }
}
