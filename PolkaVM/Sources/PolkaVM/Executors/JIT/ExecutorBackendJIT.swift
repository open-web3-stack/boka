// generated by polka.codes
// JIT compilation backend for PolkaVM executor

import asmjit
import CppHelper
import Foundation
import TracingUtils
import Utils

// TODO: Implement proper error mapping from JIT errors to ExitReason (align with interpreter's ExitReason handling)
// TODO: Add comprehensive performance metrics for instruction execution frequency and timing
// TODO: Implement instruction-specific optimizations based on interpreter hotspots

final class ExecutorBackendJIT: ExecutorBackend, @unchecked Sendable {
    private let logger = Logger(label: "ExecutorBackendJIT")

    private let jitCache = JITCache()
    private let jitCompiler = JITCompiler()
    private let jitExecutor = JITExecutor()
    private let jitMemoryManager = JITMemoryManager()

    // TODO: Improve HostFunction signature with proper VMState access (similar to interpreter's InvocationContext)
    // TODO: Add gas accounting for host function calls (deduct gas before and after host function execution)
    // TODO: Implement proper error propagation from host functions to JIT execution flow
    public typealias HostFunction = (
        _ guestRegisters: UnsafeMutablePointer<UInt64>,
        _ guestMemoryBase: UnsafeMutablePointer<UInt8>,
        _ guestMemorySize: UInt32,
        _ guestGas: UnsafeMutablePointer<UInt64>
        // TODO: Add specific arguments extracted from registers if needed
    ) throws -> UInt32 // Return value to be placed in a guest register (e.g., R0), or an error indicator.

    private var registeredHostFunctions: [UInt32: HostFunction] = [:]
    // This will hold the JITHostFunctionTable struct itself, and we'll pass a pointer to it.
    private var jitHostFunctionTableStorage: JITHostFunctionTable! // force unwrapped so we can have cyclic reference

    // TODO: Implement thread safety for JIT execution (similar to interpreter's async execution model)
    // TODO: Add support for debugging JIT-compiled code (instruction tracing, register dumps)
    // TODO: Implement proper memory management for JIT code (code cache eviction policies)
    // TODO: Add support for tiered compilation (interpret first, then JIT hot paths)

    // TODO: The init method should ideally take a PvmConfig or target architecture string
    // to correctly initialize CppHelper. For now, we'll use a placeholder or attempt
    // to get the host architecture if JITPlatformHelper allows without a full config.
    // TODO: Initialize JIT with instruction handlers that match interpreter behavior exactly
    init() {
        // Need to match with JITHostFunctionFn in helper.hh
        // we can't use JITHostFunctionFn directly due to Swift compiler bug
        typealias JITHostFunctionFnSwift = @convention(c) (
            UnsafeMutableRawPointer?,
            UInt32,
            UnsafeMutablePointer<UInt64>,
            UnsafeMutablePointer<UInt8>,
            UInt32,
            UnsafeMutablePointer<UInt64>
        ) -> UInt32

        // double unsafeBitCast to workaround Swift compiler bug
        let fnPtr = unsafeBitCast(
            dispatchHostCall_C_Trampoline as JITHostFunctionFnSwift,
            to: UnsafeRawPointer.self
        )
        jitHostFunctionTableStorage = JITHostFunctionTable(
            dispatchHostCall: unsafeBitCast(fnPtr, to: JITHostFunctionFn.self),
            ownerContext: Unmanaged.passUnretained(self).toOpaque()
        )
    }

    // Public method to register host functions
    public func registerHostFunction(index: UInt32, function: @escaping HostFunction) {
        registeredHostFunctions[index] = function
        logger.info("Registered host function for index \(index)")
    }

    // Instance method to handle the dispatch, called by the C trampoline
    fileprivate func dispatchHostCall(
        hostCallIndex: UInt32,
        guestRegistersPtr: UnsafeMutablePointer<UInt64>,
        guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
        guestMemorySize: UInt32,
        guestGasPtr: UnsafeMutablePointer<UInt64>
    ) -> UInt32 { // Return value for guest (e.g., to be put in R0) or error code
        logger.debug("Swift: Instance dispatchHostCall received call for index \(hostCallIndex)")

        guard let hostFunction = registeredHostFunctions[hostCallIndex] else {
            logger.error("Swift: No host function registered for index \(hostCallIndex)")
            // Return error code for "host function not found".
            return JITHostCallError.hostFunctionNotFound.rawValue
        }

        do {
            // Fixed gas cost for host function call setup
            // This matches the interpreter's fixed cost for host function calls
            let hostCallSetupGasCost: UInt64 = 100

            // Check if we have enough gas for the host call setup
            if guestGasPtr.pointee < hostCallSetupGasCost {
                logger.error("Swift: Gas exhausted during host function call setup")
                return JITHostCallError.gasExhausted.rawValue
            }

            // Deduct gas for host call setup
            guestGasPtr.pointee -= hostCallSetupGasCost
            logger.debug("Swift: Deducted \(hostCallSetupGasCost) gas for host call setup. Remaining: \(guestGasPtr.pointee)")

            // The host function is responsible for its internal gas consumption
            // by decrementing `guestGasPtr.pointee` as needed
            let resultFromHostFn = try hostFunction(
                guestRegistersPtr,
                guestMemoryBasePtr,
                guestMemorySize,
                guestGasPtr
            )

            // Fixed gas cost for host function call teardown/return
            let hostCallTeardownGasCost: UInt64 = 50

            // Check if we have enough gas for the host call teardown
            if guestGasPtr.pointee < hostCallTeardownGasCost {
                logger.error("Swift: Gas exhausted during host function call teardown")
                return JITHostCallError.gasExhausted.rawValue
            }

            // Deduct gas for host call teardown
            guestGasPtr.pointee -= hostCallTeardownGasCost
            logger.debug("Swift: Deducted \(hostCallTeardownGasCost) gas for host call teardown. Remaining: \(guestGasPtr.pointee)")

            // By convention, the JIT code that calls the host function trampoline
            // will expect the result in a specific register (e.g., x0 on AArch64).
            // The C++ trampoline will place `resultFromHostFn` into this return register.
            logger.debug("Swift: Host function \(hostCallIndex) executed successfully, result: \(resultFromHostFn)")
            return resultFromHostFn
        } catch {
            logger.error("Swift: Host function \(hostCallIndex) threw an error: \(error)")
            // Return error code for "host function threw error".
            return JITHostCallError.hostFunctionThrewError.rawValue
        }
    }

    func execute(
        config: PvmConfig,
        blob: Data,
        pc: UInt32,
        gas: Gas,
        argumentData: Data?,
        ctx: (any InvocationContext)?
    ) async -> ExitReason {
        logger.info("JIT execution request. PC: \(pc), Gas: \(gas.value), Blob size: \(blob.count) bytes.")

        var currentGas = gas // Mutable copy for JIT execution

        // Fixed gas cost for JIT execution setup - matches interpreter's setup cost
        let jitSetupGasCost: UInt64 = 200

        // Check if we have enough gas for JIT setup
        if currentGas.value < jitSetupGasCost {
            logger.error("Not enough gas for JIT execution setup. Required: \(jitSetupGasCost), Available: \(currentGas.value)")
            return .outOfGas
        }

        // Create a new Gas instance with the deducted amount
        currentGas = Gas(currentGas.value - jitSetupGasCost)
        logger.debug("Deducted \(jitSetupGasCost) gas for JIT setup. Remaining: \(currentGas.value)")

        do {
            let targetArchitecture = try JITPlatformHelper.getCurrentTargetArchitecture(config: config)
            logger.debug("Target architecture for JIT: \(targetArchitecture)")

            // Fixed gas cost for JIT compilation/cache lookup - matches interpreter's preparation cost
            let jitCompilationGasCost: UInt64 = 100

            // Check if we have enough gas for compilation/cache lookup
            if currentGas.value < jitCompilationGasCost {
                logger
                    .error(
                        "Not enough gas for JIT compilation/cache lookup. Required: \(jitCompilationGasCost), Available: \(currentGas.value)"
                    )
                return .outOfGas
            }

            // Create a new Gas instance with the deducted amount
            currentGas = Gas(currentGas.value - jitCompilationGasCost)
            logger.debug("Deducted \(jitCompilationGasCost) gas for JIT compilation/cache lookup. Remaining: \(currentGas.value)")

            let jitCacheKey = JITCache.createCacheKey(
                blob: blob,
                initialPC: pc,
                targetArchitecture: targetArchitecture,
                config: config
            )

            let jitTotalMemorySize = jitMemoryManager.getJITTotalMemorySize(config: config)
            var functionPtr: UnsafeMutableRawPointer?
            let functionAddress = await jitCache.getCachedFunction(forKey: jitCacheKey)
            if let address = functionAddress {
                functionPtr = UnsafeMutableRawPointer(bitPattern: address)
                logger.debug("JIT cache hit. Using cached function.")
            } else {
                logger.debug("JIT cache miss. Proceeding to compilation.")
            }

            if functionPtr == nil { // Cache miss or cache disabled
                // Additional gas cost for actual compilation (only on cache miss)
                let jitActualCompilationGasCost: UInt64 = 300

                // Check if we have enough gas for actual compilation
                if currentGas.value < jitActualCompilationGasCost {
                    logger
                        .error(
                            "Not enough gas for actual JIT compilation. Required: \(jitActualCompilationGasCost), Available: \(currentGas.value)"
                        )
                    return .outOfGas
                }

                // Create a new Gas instance with the deducted amount
                currentGas = Gas(currentGas.value - jitActualCompilationGasCost)
                logger.debug("Deducted \(jitActualCompilationGasCost) gas for actual JIT compilation. Remaining: \(currentGas.value)")

                let compiledFuncPtr = try jitCompiler.compile(
                    blob: blob,
                    initialPC: pc,
                    config: config,
                    targetArchitecture: targetArchitecture,
                    jitMemorySize: jitTotalMemorySize
                )
                functionPtr = compiledFuncPtr

                let functionAddressToCache = UInt(bitPattern: compiledFuncPtr)
                await jitCache.cacheFunction(functionAddressToCache, forKey: jitCacheKey)
                logger.debug("Compilation successful. Function cached.")
            }

            guard let validFunctionPtr = functionPtr else {
                // This case should ideally be caught by errors in compile or cache logic.
                logger.error("Function pointer is unexpectedly nil after cache check/compilation.")
                throw JITError.functionPointerNil
            }

            var registers = Registers()
            // Initialize registers based on interpreter's pattern
            if let argData = argumentData {
                // Copy up to 4 arguments into R0-R3 registers
                let argWords = min(4, argData.count / 8 + (argData.count % 8 > 0 ? 1 : 0))
                for i in 0 ..< argWords {
                    let startIndex = i * 8
                    let endIndex = min(startIndex + 8, argData.count)
                    var value: UInt64 = 0
                    for j in startIndex ..< endIndex {
                        let byteValue = UInt64(argData[j])
                        let shift = UInt64(j - startIndex) * 8
                        value |= byteValue << shift
                    }
                    registers[Registers.Index(raw: UInt8(i))] = value
                }
            }

            // Fixed gas cost for memory initialization - matches interpreter's memory setup cost
            let memoryInitGasCost: UInt64 = 150

            // Check if we have enough gas for memory initialization
            if currentGas.value < memoryInitGasCost {
                logger.error("Not enough gas for memory initialization. Required: \(memoryInitGasCost), Available: \(currentGas.value)")
                return .outOfGas
            }

            // Create a new Gas instance with the deducted amount
            currentGas = Gas(currentGas.value - memoryInitGasCost)
            logger.debug("Deducted \(memoryInitGasCost) gas for memory initialization. Remaining: \(currentGas.value)")

            var vmMemory: Memory
            do {
                let pvmPageSize = UInt32(config.pvmMemoryPageSize)
                vmMemory = try StandardMemory(
                    readOnlyData: config.readOnlyDataSegment ?? Data(),
                    readWriteData: config.readWriteDataSegment ?? Data(),
                    argumentData: argumentData ?? Data(),
                    heapEmptyPagesSize: config.initialHeapPages * pvmPageSize,
                    stackSize: config.stackPages * pvmPageSize
                )
            } catch {
                logger.error("Failed to initialize VM memory: \(error)")
                throw JITError.vmInitializationError(details: "StandardMemory init failed: \(error)")
            }

            // Fixed gas cost for memory buffer preparation
            let memoryBufferPrepGasCost: UInt64 = 100

            // Check if we have enough gas for memory buffer preparation
            if currentGas.value < memoryBufferPrepGasCost {
                logger
                    .error(
                        "Not enough gas for memory buffer preparation. Required: \(memoryBufferPrepGasCost), Available: \(currentGas.value)"
                    )
                return .outOfGas
            }

            // Create a new Gas instance with the deducted amount
            currentGas = Gas(currentGas.value - memoryBufferPrepGasCost)
            logger.debug("Deducted \(memoryBufferPrepGasCost) gas for memory buffer preparation. Remaining: \(currentGas.value)")

            var jitFlatMemoryBuffer = try jitMemoryManager.prepareJITMemoryBuffer(
                from: vmMemory,
                config: config,
                jitMemorySize: jitTotalMemorySize
            )

            // Execute the JIT-compiled function
            // The JIT function will deduct gas for each instruction executed
            let exitReason = try jitExecutor.execute(
                functionPtr: validFunctionPtr,
                registers: &registers,
                jitFlatMemoryBuffer: &jitFlatMemoryBuffer,
                jitMemorySize: jitTotalMemorySize,
                gas: &currentGas,
                initialPC: pc,
                invocationContext: ctx.map { Unmanaged.passUnretained($0 as AnyObject).toOpaque() }
            )

            // Fixed gas cost for memory changes reflection
            let memoryReflectionGasCost: UInt64 = 100

            // Check if we have enough gas for memory reflection
            if currentGas.value < memoryReflectionGasCost {
                logger.error("Not enough gas for memory reflection. Required: \(memoryReflectionGasCost), Available: \(currentGas.value)")
                return .outOfGas
            }

            // Create a new Gas instance with the deducted amount
            currentGas = Gas(currentGas.value - memoryReflectionGasCost)
            logger.debug("Deducted \(memoryReflectionGasCost) gas for memory reflection. Remaining: \(currentGas.value)")

            try jitMemoryManager.reflectJITMemoryChanges(
                from: jitFlatMemoryBuffer,
                to: &vmMemory,
                config: config,
                jitMemorySize: jitTotalMemorySize
            )

            logger.info("JIT execution finished. Reason: \(exitReason). Remaining gas: \(currentGas.value)")
            return exitReason

        } catch let error as JITError {
            logger.error("JIT execution failed with JITError: \(error)")
            return error.toExitReason()
        } catch {
            logger.error("JIT execution failed with an unexpected error: \(error)")
            return .panic(.trap) // Generic trap for unexpected errors
        }
    }
}

//
// The temporary extension PvmConfig from the original file has been removed.
// These properties need to be formally added to the PvmConfig definition.

// Type for a C-callable host function trampoline
// It receives an opaque context (pointer to ExecutorBackendJIT instance),
// guest registers, guest memory, gas, and the host call index.
// Returns a status or result (e.g., value for R0 or an error code).
public typealias PolkaVMHostCallCHandler = @convention(c) (
    _ opaqueOwnerContext: UnsafeMutableRawPointer?, // Points to ExecutorBackendJIT instance
    _ hostCallIndex: UInt32,
    _ guestRegisters: UnsafeMutablePointer<UInt64>, // Guest registers (PolkaVM format)
    _ guestMemoryBase: UnsafeMutablePointer<UInt8>, // Guest memory base
    _ guestMemorySize: UInt32, // Guest memory size (for bounds checks)
    _ guestGas: UnsafeMutablePointer<UInt64> // Guest gas counter
) -> UInt32 // Represents a value to be written to a specific register (e.g. R0 by convention) or a JITHostCallError rawValue.

// Defines standardized error codes for JIT host function calls.
// These raw values are returned by the host call C trampoline to the JIT-compiled code.
// The JIT-compiled code must check if the returned UInt32 matches any of these error codes.
// If it does, the JIT code should treat it as a VM-level error (e.g., trigger a panic).
// Otherwise, the returned UInt32 is the successful result from the host function.
// These values are chosen to be at the high end of the UInt32 range to minimize
// collision with legitimate success values returned by host functions.

enum JITHostCallError: UInt32 {
    // Indicates an internal error within the JIT host call mechanism,
    // such as the owner context being nil.
    case internalErrorInvalidContext = 0xFFFF_FFFF

    // Indicates that no host function was found registered for the given index.
    case hostFunctionNotFound = 0xFFFF_FFFE

    // Indicates that the registered host function was called but threw a Swift error during its execution.
    case hostFunctionThrewError = 0xFFFF_FFFD

    // Indicates that the VM ran out of gas during host function execution
    case gasExhausted = 0xFFFF_FFFC
}

// Static C-callable trampoline that calls the instance method.
private func dispatchHostCall_C_Trampoline(
    opaqueOwnerContext: UnsafeMutableRawPointer?,
    hostCallIndex: UInt32,
    guestRegistersPtr: UnsafeMutablePointer<UInt64>,
    guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
    guestMemorySize: UInt32,
    guestGasPtr: UnsafeMutablePointer<UInt64>
) -> UInt32 {
    guard let ownerCtxPtr = opaqueOwnerContext else {
        // This is a critical error: the context to find the Swift instance is missing.
        // Ideally, log this error through a mechanism available in a static context if possible,
        // or ensure this path is never taken by robust setup.
        // Logger(label: "ExecutorBackendJIT_StaticTrampoline").error("dispatchHostCall_C_Trampoline: opaqueOwnerContext is nil.")
        // Return a specific error code indicating context failure.
        // This UInt32 will be checked by the JITed code. If it's this sentinel,
        // the JITed code should trigger a VM panic.
        // Return a specific error code indicating context failure.
        // The JITed code should check this and trigger a VM panic.
        return JITHostCallError.internalErrorInvalidContext.rawValue
    }
    let backendInstance = Unmanaged<ExecutorBackendJIT>.fromOpaque(ownerCtxPtr).takeUnretainedValue()

    // Call the instance method that actually handles the dispatch.
    return backendInstance.dispatchHostCall(
        hostCallIndex: hostCallIndex,
        guestRegistersPtr: guestRegistersPtr,
        guestMemoryBasePtr: guestMemoryBasePtr,
        guestMemorySize: guestMemorySize,
        guestGasPtr: guestGasPtr
    )
}
