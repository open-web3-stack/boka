// generated by polka.codes
// JIT compilation backend for PolkaVM executor

import AsmJitLib
import CppHelper
import Foundation
import TracingUtils
import Utils

// TODO: Build a cache system for generated code

/// ⚠️ CRITICAL: ExecutorBackendJIT is SINGLE-THREADED ONLY
///
/// This class is designed for **single-threaded execution only** and is NOT
/// thread-safe for concurrent `execute()` calls.
///
/// ## Thread Safety Model
///
/// ✅ **SAFE**:
/// - Single-threaded execution of one instance
/// - Multiple instances (each accessed from different thread)
///
/// ❌ **UNSAFE**:
/// - Concurrent calls to `execute()` on the same instance
/// - Shared access to `syncHostCallHandler` or `currentProgramCode`
///
/// ## Concurrency Architecture Note
///
/// This implementation uses `semaphore.wait()` to bridge async Swift host
/// functions to synchronous JIT code. **This blocks the Swift concurrency
/// thread pool** and can cause deadlocks if:
/// 1. Multiple executions run concurrently on the same instance
/// 2. The thread pool has insufficient threads (e.g., pool size = 1)
///
/// **Mitigation**: ExecutorFrontendInProcess serializes execution, ensuring
/// only one JIT execution is active at a time. This is acceptable for the
/// single-threaded use case but is **NOT safe for concurrent use**.
///
/// ## Future Improvement
///
/// To support concurrent execution, the synchronous JIT call should be
/// offloaded to a dedicated `Thread` or `DispatchQueue` (outside the Swift
/// concurrency pool), allowing pool threads to remain free for async host calls.
final class ExecutorBackendJIT: ExecutorBackend {
    private let logger = Logger(label: "ExecutorBackendJIT")

    // WARNING: This class is NOT thread-safe for concurrent execute() calls.
    // The syncHostCallHandler and currentProgramCode are mutable instance state
    // that must not be shared across concurrent executions.
    // TODO: Refactor to pass execution-specific state through context object
    // instead of storing in instance properties.

    private let jitCompiler = JITCompiler()
    private let jitExecutor = JITExecutor()

    // Heap-allocated JITHostFunctionTable for C++ interop
    // Allocate as C-compatible struct directly on heap (not wrapped in Swift class)
    // to avoid passing Swift object header to C++ code
    private var jitHostFunctionTablePtr: UnsafeMutablePointer<JITHostFunctionTable>!

    // Store the program code during execution for VMStateJIT
    private var currentProgramCode: ProgramCode?

    // Using a simpler approach to handle host calls that doesn't require async/await
    private var syncHostCallHandler: ((
        UInt32,
        UnsafeMutablePointer<UInt64>,
        UnsafeMutablePointer<UInt8>,
        UInt32,
        UnsafeMutablePointer<UInt64>
    ) -> UInt32)?

    // Track compiled function pointers for memory leak cleanup
    private var compiledFunctionPointers: [UnsafeRawPointer] = []


    // TODO: Implement thread safety for JIT execution (similar to interpreter's async execution model)
    // TODO: Add support for debugging JIT-compiled code (instruction tracing, register dumps)
    // TODO: Implement proper memory management for JIT code (code cache eviction policies)
    // TODO: Add support for tiered compilation (interpret first, then JIT hot paths)

    // TODO: The init method should ideally take a PvmConfig or target architecture string
    // to correctly initialize CppHelper. For now, we'll use a placeholder or attempt
    // to get the host architecture if JITPlatformHelper allows without a full config.
    // TODO: Initialize JIT with instruction handlers that match interpreter behavior exactly
    init() {
        // Need to match with JITHostFunctionFn in helper.hh
        // we can't use JITHostFunctionFn directly due to Swift compiler bug
        typealias JITHostFunctionFnSwift = @convention(c) (
            UnsafeMutableRawPointer?,
            UInt32,
            UnsafeMutablePointer<UInt64>,
            UnsafeMutablePointer<UInt8>,
            UInt32,
            UnsafeMutablePointer<UInt64>,
            UnsafeMutableRawPointer?
        ) -> UInt32

        // double unsafeBitCast to workaround Swift compiler bug
        let fnPtr = unsafeBitCast(
            dispatchHostCall_C_Trampoline as JITHostFunctionFnSwift,
            to: UnsafeRawPointer.self
        )

        // Allocate JITHostFunctionTable on heap as C-compatible struct
        jitHostFunctionTablePtr = UnsafeMutablePointer<JITHostFunctionTable>.allocate(capacity: 1)
        jitHostFunctionTablePtr.initialize(to: JITHostFunctionTable(
            dispatchHostCall: unsafeBitCast(fnPtr, to: JITHostFunctionFn.self),
            ownerContext: Unmanaged.passUnretained(self).toOpaque(),
            invocationContext: nil,
            jumpTableData: nil,
            jumpTableSize: 0,
            jumpTableEntrySize: 0,
            jumpTableEntriesCount: 0,
            alignmentFactor: 0,
            dispatcherJumpTable: nil,
            dispatcherJumpTableSize: 0
        ))
    }

    deinit {
        // Clean up dispatcher tables for all compiled functions
        for funcPtr in compiledFunctionPointers {
            CppHelper.freeDispatcherTable(UnsafeMutableRawPointer(mutating: funcPtr))
        }

        // Clean up heap-allocated struct
        jitHostFunctionTablePtr.deinitialize(count: 1)
        jitHostFunctionTablePtr.deallocate()
    }

    // Simple synchronous handler for host functions
    // This is the bridge between the sync world of JIT and the async world of Swift
    fileprivate func dispatchHostCall(
        hostCallIndex: UInt32,
        guestRegistersPtr: UnsafeMutablePointer<UInt64>,
        guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
        guestMemorySize: UInt32,
        guestGasPtr: UnsafeMutablePointer<UInt64>,
        invocationContextPtr _: UnsafeMutableRawPointer?
    ) -> UInt32 { // Return value for guest (e.g., to be put in R0) or error code
        logger.debug("Swift: dispatchHostCall received call for index \(hostCallIndex)")

        // Fixed gas cost for host function call setup
        let hostCallSetupGasCost: UInt64 = 100

        // Check if we have enough gas for the host call setup
        if guestGasPtr.pointee < hostCallSetupGasCost {
            logger.error("Swift: Gas exhausted during host function call setup")
            return JITHostCallError.gasExhausted.rawValue
        }

        // Deduct gas for host call setup
        guestGasPtr.pointee -= hostCallSetupGasCost

        // Use the syncHandler to handle host calls
        if let handler = syncHostCallHandler {
            let result = handler(hostCallIndex, guestRegistersPtr, guestMemoryBasePtr, guestMemorySize, guestGasPtr)

            // Fixed gas cost for host function call teardown
            let hostCallTeardownGasCost: UInt64 = 50

            // Check if we have enough gas for teardown
            if guestGasPtr.pointee < hostCallTeardownGasCost {
                logger.error("Swift: Gas exhausted during host function call teardown")
                return JITHostCallError.gasExhausted.rawValue
            }

            // Deduct gas for host call teardown
            guestGasPtr.pointee -= hostCallTeardownGasCost

            logger.debug("Swift: Host function \(hostCallIndex) executed successfully via sync handler")
            return result
        } else {
            logger.error("Swift: No host function handler available")
            return JITHostCallError.internalErrorInvalidContext.rawValue
        }
    }

    func execute(
        config: PvmConfig,
        blob: Data,
        pc: UInt32,
        gas: Gas,
        argumentData: Data?,
        ctx: (any InvocationContext)?
    ) async -> VMExecutionResult {
        logger.debug("JIT execution request. PC: \(pc), Gas: \(gas.value), Blob size: \(blob.count) bytes.")

        var currentGas = gas // Mutable copy for JIT execution

        do {
            // Ensure cleanup happens on both success and error paths
            defer {
                syncHostCallHandler = nil
                currentProgramCode = nil
            }

            let targetArchitecture = JITPlatform.getCurrentTargetArchitecture()
            logger.debug("Target architecture for JIT: \(targetArchitecture)")

            // Set up program code first (needed to extract bytecode for JIT compiler)
            do {
                currentProgramCode = try ProgramCode(blob)
            } catch {
                logger.error("Failed to create ProgramCode: \(error)")
                return VMExecutionResult(exitReason: .panic(.invalidInstructionIndex), gasUsed: gas, outputData: nil)
            }

            // TODO: lookup from cache

            // CRITICAL FIX: Pass the extracted bytecode, not the raw blob!
            // The blob contains headers (jump table count, encode size, code length, etc.)
            // but the JIT compiler expects just the bytecode portion.
            // Calculate total memory size from config for proper bounds checking
            let totalMemorySize = (config.initialHeapPages + config.stackPages) * UInt32(config.pvmMemoryPageSize)

            // Safely unwrap programCode with proper error handling
            guard let programCode = currentProgramCode else {
                logger.error("ProgramCode not available for JIT compilation")
                return VMExecutionResult(exitReason: .panic(.trap), gasUsed: gas, outputData: nil)
            }

            let compiledFuncPtr = try jitCompiler.compile(
                blob: programCode.code,
                initialPC: pc,
                config: config,
                targetArchitecture: targetArchitecture,
                jitMemorySize: totalMemorySize
            )

            // Track compiled function pointer for cleanup in deinit
            compiledFunctionPointers.append(compiledFuncPtr)

            // Retrieve dispatcher jump table for this compiled function
            // This allows JumpInd to work without a PVM jump table
            var dispatcherTableSize: size_t = 0
            let dispatcherTable = getDispatcherTable(compiledFuncPtr, &dispatcherTableSize)

            // Update the JITHostFunctionTable with the dispatcher table
            if let table = dispatcherTable {
                logger.debug("Dispatcher table retrieved: \(dispatcherTableSize) entries")
                jitHostFunctionTablePtr.pointee.dispatcherJumpTable = table
                jitHostFunctionTablePtr.pointee.dispatcherJumpTableSize = UInt32(dispatcherTableSize)
            } else {
                logger.warning("No dispatcher table found for compiled function - JumpInd may fall back to interpreter")
            }

            var registers = Registers(config: config, argumentData: argumentData)

            // Set up the synchronous handler that will bridge to async context if invoked
            // We're capturing the invocationContext into a closure that will be called synchronously
            if let invocationContext = ctx {
                // Initialize the synchronous handler
                // Use [weak self] to avoid retain cycle (cleanup happens in defer block)
                syncHostCallHandler = { [weak self] hostCallIndex, guestRegistersPtr, guestMemoryBasePtr, guestMemorySize, guestGasPtr -> UInt32 in
                    guard let self else {
                        return JITHostCallError.internalErrorInvalidContext.rawValue
                    }

                    guard let programCode = self.currentProgramCode else {
                        self.logger.error("No program code available for host call")
                        return JITHostCallError.internalErrorInvalidContext.rawValue
                    }

                    // Create a VMStateJIT adapter
                    // NOTE: PC is tracked internally by JIT-compiled code, not exposed to host calls.
                    // Using 0 as initialPC. The PC value is typically not needed by host functions,
                    // but if it is, the C++ JIT code needs to be modified to pass it.
                    let vmState = VMStateJIT(
                        jitMemoryBasePtr: guestMemoryBasePtr,
                        jitMemorySize: guestMemorySize,
                        jitRegistersPtr: guestRegistersPtr,
                        jitGasPtr: guestGasPtr,
                        programCode: programCode,
                        initialPC: 0
                    )

                    // Convert async operation to sync using semaphore + lock
                    let semaphore = DispatchSemaphore(value: 0)

                    // Thread-safe result box using class wrapper (required for escaping closure)
                    final class ResultBox: @unchecked Sendable {
                        private let lock = Utils.ReadWriteLock()
                        private var _value: ExecOutcome?

                        func set(_ value: ExecOutcome) {
                            lock.withWriteLock { _value = value }
                        }

                        func get() -> ExecOutcome? {
                            lock.withReadLock { _value }
                        }
                    }

                    let resultBox = ResultBox()

                    // TODO: consider make InvocationContext Sendable
                    let boxedCtx = UncheckedSendableBox(invocationContext)

                    // Kick off the async operation on a detached task
                    Task.detached(priority: Task.currentPriority) {
                        let r = await boxedCtx.value.dispatch(index: hostCallIndex, state: vmState)
                        resultBox.set(r)
                        semaphore.signal()
                    }

                    // Block until async operation completes
                    // ⚠️ CRITICAL WARNING: This blocks a Swift Concurrency thread.
                    //
                    // If too many JIT executions block concurrently (via semaphore.wait()),
                    // the Swift concurrency thread pool may be exhausted, causing deadlock
                    // where the detached task never gets to run because all threads are
                    // blocked waiting.
                    //
                    // MITIGATION: This is acceptable because:
                    // 1. ExecutorBackendJIT is documented as SINGLE-THREADED
                    // 2. ExecutorFrontendInProcess serializes execution
                    // 3. Only one JIT execution should be active at a time
                    //
                    // DO NOT call this executor from multiple concurrent tasks without
                    // external serialization (e.g., an actor or serial queue).
                    semaphore.wait()

                    // Process the result
                    guard let result = resultBox.get() else {
                        self.logger.error("No result from async host function call")
                        return JITHostCallError.hostFunctionThrewError.rawValue
                    }

                    switch result {
                    case .continued:
                        return 0
                    case let .exit(reason):
                        switch reason {
                        case .halt:
                            return JITHostCallError.hostRequestedHalt.rawValue
                        case .outOfGas:
                            return JITHostCallError.gasExhausted.rawValue
                        case let .hostCall(nestedIndex):
                            self.logger.error("Nested host calls not supported: \(nestedIndex)")
                            return JITHostCallError.hostFunctionThrewError.rawValue
                        case let .pageFault(address):
                            self.logger.error("Page fault at address \(address)")
                            return JITHostCallError.pageFault.rawValue
                        case .fallback:
                            self.logger.error("Fallback not supported during host call")
                            return JITHostCallError.hostFunctionThrewError.rawValue
                        case .panic:
                            return JITHostCallError.hostFunctionThrewError.rawValue
                        }
                    }
                }
            } else {
                // Clear the handler if no context provided
                syncHostCallHandler = nil
            }

            // Update the invocation context in the JIT host function table
            jitHostFunctionTablePtr.pointee.invocationContext = nil // We're using the syncHandler now

            // Populate jump table data for JumpInd instruction support
            if let programCode = currentProgramCode {
                // Get jump table data as a pointer
                let jumpTableData = programCode.jumpTable.withUnsafeBytes { rawBufferPointer in
                    rawBufferPointer.baseAddress
                }

                jitHostFunctionTablePtr.pointee.jumpTableData = jumpTableData?.assumingMemoryBound(to: UInt8.self)
                jitHostFunctionTablePtr.pointee.jumpTableSize = UInt32(programCode.jumpTable.count)
                jitHostFunctionTablePtr.pointee.jumpTableEntrySize = programCode.jumpTableEntrySize
                jitHostFunctionTablePtr.pointee.jumpTableEntriesCount = UInt32(programCode.jumpTable.count / Int(programCode.jumpTableEntrySize))
                jitHostFunctionTablePtr.pointee.alignmentFactor = UInt32(config.pvmDynamicAddressAlignmentFactor)
            } else {
                // No jump table available
                jitHostFunctionTablePtr.pointee.jumpTableData = nil
                jitHostFunctionTablePtr.pointee.jumpTableSize = 0
                jitHostFunctionTablePtr.pointee.jumpTableEntrySize = 0
                jitHostFunctionTablePtr.pointee.jumpTableEntriesCount = 0
                jitHostFunctionTablePtr.pointee.alignmentFactor = UInt32(config.pvmDynamicAddressAlignmentFactor)
            }

            // Get pointer to heap-allocated JITHostFunctionTable
            let invocationContextPointer = UnsafeMutableRawPointer(jitHostFunctionTablePtr)

            // Execute the JIT-compiled function
            // The JIT function will use our syncHostCallHandler via the C trampoline
            let (exitReason, memoryBuffer) = try jitExecutor.execute(
                functionPtr: compiledFuncPtr,
                registers: &registers,
                jitMemorySize: totalMemorySize,
                gas: &currentGas,
                initialPC: pc,
                invocationContext: invocationContextPointer
            )

            // Ensure memory is deallocated exactly once using defer
            defer {
                memoryBuffer.deallocate()
            }

            // Clear the invocation context reference after execution
            jitHostFunctionTablePtr.pointee.invocationContext = nil

            // Calculate gas used (handle saturating Gas type correctly)
            let gasUsed: Gas
            if exitReason == .outOfGas {
                // When out of gas, all remaining gas was used
                gasUsed = gas
            } else {
                // Normal execution: subtract remaining from initial
                gasUsed = gas - currentGas
            }

            // Handle fallback case - capture memory before deallocation
            if case let .fallback(fallbackPC, fallbackRegisters, fallbackGasUsed) = exitReason {
                // Copy JIT memory to Data for interpreter
                let jitMemory = Data(bytes: memoryBuffer, count: Int(totalMemorySize))

                logger.debug("JIT fallback to interpreter at PC: \(fallbackPC)")

                // Return result with fallback state and memory
                return VMExecutionResult(
                    exitReason: exitReason,
                    gasUsed: gasUsed,
                    outputData: jitMemory,
                    fallbackState: (fallbackPC, fallbackRegisters, fallbackGasUsed)
                )
            }

            // Get output data from JIT memory (only on halt, following invokePVM pattern)
            let outputData: Data?
            switch exitReason {
            case .halt:
                // Read output address and length from registers r7 and r8
                let outputAddr = UInt32(truncatingIfNeeded: registers[Registers.Index(raw: 7)])
                let outputLen = UInt32(truncatingIfNeeded: registers[Registers.Index(raw: 8)])

                // Validate and read from JIT memory (prevent integer overflow)
                if outputLen == 0 {
                    // Empty output is valid
                    outputData = Data()
                } else if UInt64(outputAddr) + UInt64(outputLen) <= UInt64(totalMemorySize) {
                    outputData = Data(bytes: memoryBuffer.advanced(by: Int(outputAddr)), count: Int(outputLen))
                } else {
                    // Invalid memory access - treat as panic to signal the error
                    logger.error("Invalid output memory range: addr=\(outputAddr), len=\(outputLen), memorySize=\(totalMemorySize)")
                    return VMExecutionResult(
                        exitReason: .panic(.jitMemoryError),
                        gasUsed: gasUsed,
                        outputData: nil
                    )
                }
            default:
                outputData = nil
            }

            logger.debug("JIT execution finished. Reason: \(exitReason). Gas used: \(gasUsed.value)")
            return VMExecutionResult(exitReason: exitReason, gasUsed: gasUsed, outputData: outputData)

        } catch let error as JITCompiler.CompilationError {
            logger.error("JIT compilation failed: \(error)")
            return VMExecutionResult(exitReason: .panic(.trap), gasUsed: gas, outputData: nil)
        } catch let error as JITError {
            logger.error("JIT execution failed with JITError: \(error)")
            return VMExecutionResult(exitReason: error.toExitReason(), gasUsed: gas, outputData: nil)
        } catch {
            logger.error("JIT execution failed with an unexpected error: \(error)")
            return VMExecutionResult(exitReason: .panic(.trap), gasUsed: gas, outputData: nil)
        }
    }
}

// Defines standardized error codes for JIT host function calls.
// These raw values are returned by the host call C trampoline to the JIT-compiled code.
// The JIT-compiled code must check if the returned UInt32 matches any of these error codes.
// If it does, the JIT code should treat it as a VM-level error (e.g., trigger a panic).
// Otherwise, the returned UInt32 is the successful result from the host function.
// These values are chosen to be at the high end of the UInt32 range to minimize
// collision with legitimate success values returned by host functions.

enum JITHostCallError: UInt32 {
    // Indicates an internal error within the JIT host call mechanism,
    // such as the owner context being nil.
    case internalErrorInvalidContext = 0xFFFF_FFFF

    // Indicates that no host function was found registered for the given index.
    case hostFunctionNotFound = 0xFFFF_FFFE

    // Indicates that the registered host function was called but threw a Swift error during its execution.
    case hostFunctionThrewError = 0xFFFF_FFFD

    // Indicates that the VM ran out of gas during host function execution
    case gasExhausted = 0xFFFF_FFFC

    // Indicates that a page fault occurred during host function execution
    case pageFault = 0xFFFF_FFFB

    // Indicates that the host function requested the VM to halt
    case hostRequestedHalt = 0xFFFF_FFFA
}

// Static C-callable trampoline that calls the instance method.
private func dispatchHostCall_C_Trampoline(
    opaqueOwnerContext: UnsafeMutableRawPointer?,
    hostCallIndex: UInt32,
    guestRegistersPtr: UnsafeMutablePointer<UInt64>,
    guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
    guestMemorySize: UInt32,
    guestGasPtr: UnsafeMutablePointer<UInt64>,
    invocationContextPtr: UnsafeMutableRawPointer?
) -> UInt32 {
    guard let ownerCtxPtr = opaqueOwnerContext else {
        return JITHostCallError.internalErrorInvalidContext.rawValue
    }
    let backendInstance = Unmanaged<ExecutorBackendJIT>.fromOpaque(ownerCtxPtr).takeUnretainedValue()

    // Call the instance method that handles the dispatch
    return backendInstance.dispatchHostCall(
        hostCallIndex: hostCallIndex,
        guestRegistersPtr: guestRegistersPtr,
        guestMemoryBasePtr: guestMemoryBasePtr,
        guestMemorySize: guestMemorySize,
        guestGasPtr: guestGasPtr,
        invocationContextPtr: invocationContextPtr
    )
}
