// generated by polka.codes
// JIT compilation backend for PolkaVM executor

import CppHelper
import Foundation
import TracingUtils
import Utils

// MARK: - In-Memory Code Cache

/// Cache entry for compiled JIT code
private struct JITCacheEntry {
    let functionPtr: UnsafeRawPointer
    let dispatcherTable: UnsafeMutablePointer<UnsafeMutableRawPointer?>?
    let dispatcherTableSize: UInt32
    let bytecode: Data // Store actual bytecode for hash collision verification
    let configHash: Int
    let initialPC: UInt32
}

/// Simple in-memory cache for JIT-compiled functions with LRU eviction
/// Key: (bytecodeHash, configHash, initialPC)
private final class JITCodeCache {
    private var cache: [String: JITCacheEntry] = [:]
    private var accessOrder: [String] = [] // Track access order for LRU eviction
    private let logger = Logger(label: "JITCodeCache")
    private let maxCacheSize: Int
    private var hitCount = 0
    private var missCount = 0

    /// Maximum cache size - prevents unbounded memory growth
    /// Each entry can be ~10KB+, so 100 entries = ~1MB max
    private static let defaultMaxSize = 100

    /// Generate cache key from bytecode, config, and PC
    private func makeKey(bytecodeHash: Int, configHash: Int, initialPC: UInt32) -> String {
        "\(bytecodeHash)-\(configHash)-\(initialPC)"
    }

    /// Initialize cache with optional max size
    init(maxSize: Int = defaultMaxSize) {
        maxCacheSize = maxSize
    }

    /// Generate hash from bytecode data
    private func hashBytecode(_ bytecode: Data) -> Int {
        // Simple hash using Fowler-Noll-Vo (FNV-1a) algorithm
        var hash: UInt64 = 14_695_981_039_346_656_037
        for byte in bytecode {
            hash ^= UInt64(byte)
            hash = hash &* 1_099_511_628_211
        }
        return Int(truncatingIfNeeded: hash)
    }

    /// Generate hash from PvmConfig
    private func hashConfig(_ config: PvmConfig) -> Int {
        // Hash relevant config fields that affect JIT compilation
        var hasher = Hasher()
        hasher.combine(config.initialHeapPages)
        hasher.combine(config.stackPages)
        hasher.combine(config.pvmMemoryPageSize)
        hasher.combine(config.pvmDynamicAddressAlignmentFactor)
        return hasher.finalize()
    }

    /// Lookup compiled function in cache
    func lookup(bytecode: Data, config: PvmConfig, initialPC: UInt32) -> JITCacheEntry? {
        let bytecodeHash = hashBytecode(bytecode)
        let configHash = hashConfig(config)
        let key = makeKey(bytecodeHash: bytecodeHash, configHash: configHash, initialPC: initialPC)

        if let entry = cache[key] {
            // CRITICAL: Verify actual bytecode matches to prevent hash collision attacks
            // Hash collisions are extremely unlikely with FNV-1a but not impossible
            if entry.bytecode == bytecode {
                // Update access order for LRU (move to end = most recently used)
                if let index = accessOrder.firstIndex(of: key) {
                    accessOrder.remove(at: index)
                    accessOrder.append(key)
                }

                hitCount += 1
                logger.debug("JIT cache HIT (hits: \(hitCount), misses: \(missCount), ratio: \(hitCount * 100 / (hitCount + missCount))%)")
                return entry
            } else {
                // Hash collision detected - unlikely but possible
                logger.warning("JIT cache hash collision detected - treating as miss")
            }
        }

        missCount += 1
        logger.debug("JIT cache MISS (hits: \(hitCount), misses: \(missCount), ratio: \(hitCount * 100 / (hitCount + missCount))%)")
        return nil
    }

    /// Store compiled function in cache
    func store(
        bytecode: Data,
        config: PvmConfig,
        initialPC: UInt32,
        functionPtr: UnsafeRawPointer,
        dispatcherTable: UnsafeMutablePointer<UnsafeMutableRawPointer?>?,
        dispatcherTableSize: UInt32
    ) {
        let bytecodeHash = hashBytecode(bytecode)
        let configHash = hashConfig(config)
        let key = makeKey(bytecodeHash: bytecodeHash, configHash: configHash, initialPC: initialPC)

        // Evict least recently used entry if cache is full
        if cache.count >= maxCacheSize, let lruKey = accessOrder.first {
            if let evictedEntry = cache.removeValue(forKey: lruKey) {
                // Free dispatcher table and function code for evicted entry
                CppHelper.freeDispatcherTable(UnsafeMutableRawPointer(mutating: evictedEntry.functionPtr))
                CppHelper.releaseJITFunction(UnsafeMutableRawPointer(mutating: evictedEntry.functionPtr))
            }
            accessOrder.removeFirst()
            logger.debug("JIT cache EVICTED entry (cache size: \(cache.count), max: \(maxCacheSize))")
        }

        let entry = JITCacheEntry(
            functionPtr: functionPtr,
            dispatcherTable: dispatcherTable,
            dispatcherTableSize: dispatcherTableSize,
            bytecode: bytecode,
            configHash: configHash,
            initialPC: initialPC
        )

        cache[key] = entry
        accessOrder.append(key) // Mark as most recently used
        logger.debug("JIT cache STORE - Total entries: \(cache.count)")
    }

    /// Clear all cached entries
    func clear() {
        // Free dispatcher tables and function code for all entries
        for entry in cache.values {
            CppHelper.freeDispatcherTable(UnsafeMutableRawPointer(mutating: entry.functionPtr))
            CppHelper.releaseJITFunction(UnsafeMutableRawPointer(mutating: entry.functionPtr))
        }
        cache.removeAll()
        accessOrder.removeAll()
        hitCount = 0
        missCount = 0
        logger.debug("JIT cache CLEARED")
    }

    /// Get cache statistics
    func stats() -> (hits: Int, misses: Int, size: Int) {
        (hitCount, missCount, cache.count)
    }
}

/// ‚ö†Ô∏è CRITICAL: ExecutorBackendJIT Concurrency Model
///
/// This class is designed for **single-threaded execution only** and is NOT
/// thread-safe for concurrent `execute()` calls on the same instance.
///
/// ## Thread Safety Model
///
/// ‚úÖ **SAFE**:
/// - Single-threaded execution of one instance
/// - Multiple instances (each accessed from different thread)
/// - Concurrent `execute()` calls on different instances
///
/// ‚ùå **UNSAFE**:
/// - Concurrent calls to `execute()` on the same instance
/// - Shared access to `syncHostCallHandler` or `currentProgramCode`
///
/// ## Concurrency Architecture
///
/// The JIT executor uses a hybrid approach to support async host functions:
///
/// 1. **Async entry point**: `execute()` is `async` and offloads JIT execution
///    to `DispatchQueue.global()` to avoid blocking Swift concurrency pool threads
///
/// 2. **Sync JIT execution**: The actual JIT code runs synchronously on the
///    DispatchQueue thread, which is **outside** the Swift concurrency pool
///
/// 3. **Host call bridge**: When JIT code needs to call an async Swift function,
///    it uses `semaphore.wait()` to block the DispatchQueue thread while the
///    async operation runs on the Swift concurrency pool
///
/// 4. **Multi-program execution**: The blockchain node can run multiple PVM programs
///    concurrently by spawning multiple ExecutorBackendJIT instances (one per program)
///
/// ## Why DispatchQueue Offloading?
///
/// Without DispatchQueue offloading, the `semaphore.wait()` in the host call bridge
/// would block Swift concurrency pool threads, potentially deadlocking when:
/// - Multiple executions run concurrently
/// - The thread pool has insufficient threads
///
/// By offloading to DispatchQueue.global(), we ensure:
/// - Swift concurrency pool threads remain free for async operations
/// - Only dedicated non-pool threads are blocked by semaphore.wait()
/// - Multiple PVM programs can run concurrently at the node level
///
/// ## Usage Pattern for Node
///
/// ```swift
/// // Node spawns one executor instance per PVM program
/// let executor1 = ExecutorBackendJIT()  // Program 1
/// let executor2 = ExecutorBackendJIT()  // Program 2
///
/// // These run concurrently without blocking each other
/// async let result1 = executor1.execute(...)
/// async let result2 = executor2.execute(...)
/// ```
///
/// ## Internal State Safety
///
/// WARNING: This class has mutable instance state (`syncHostCallHandler`,
/// `currentProgramCode`) that must not be shared across concurrent executions.
/// TODO: Refactor to pass execution-specific state through context object
/// instead of storing in instance properties.
final class ExecutorBackendJIT: ExecutorBackend {
    private let logger = Logger(label: "ExecutorBackendJIT")

    // WARNING: This class is NOT thread-safe for concurrent execute() calls.
    // The syncHostCallHandler and currentProgramCode are mutable instance state
    // that must not be shared across concurrent executions.
    // TODO: Refactor to pass execution-specific state through context object
    // instead of storing in instance properties.

    private let jitCompiler = JITCompiler()
    private let jitExecutor = JITExecutor()

    // Heap-allocated JITHostFunctionTable for C++ interop
    // Allocate as C-compatible struct directly on heap (not wrapped in Swift class)
    // to avoid passing Swift object header to C++ code
    private var jitHostFunctionTablePtr: UnsafeMutablePointer<JITHostFunctionTable>!

    // Store the program code during execution for VMStateJIT
    private var currentProgramCode: ProgramCode?

    // Using a simpler approach to handle host calls that doesn't require async/await
    private var syncHostCallHandler: ((
        UInt32,
        UnsafeMutablePointer<UInt64>,
        UnsafeMutablePointer<UInt8>,
        UInt32,
        UnsafeMutablePointer<UInt64>
    ) -> UInt32)?

    // In-memory code cache for JIT-compiled functions
    private let codeCache = JITCodeCache()

    // TODO: Implement thread safety for JIT execution (similar to interpreter's async execution model)
    // TODO: Add support for debugging JIT-compiled code (instruction tracing, register dumps)
    // TODO: Implement proper memory management for JIT code (code cache eviction policies)
    // TODO: Add support for tiered compilation (interpret first, then JIT hot paths)

    // TODO: The init method should ideally take a PvmConfig or target architecture string
    // to correctly initialize CppHelper. For now, we'll use a placeholder or attempt
    // to get the host architecture if JITPlatformHelper allows without a full config.
    // TODO: Initialize JIT with instruction handlers that match interpreter behavior exactly
    init() {
        // Need to match with JITHostFunctionFn in helper.hh
        // we can't use JITHostFunctionFn directly due to Swift compiler bug
        typealias JITHostFunctionFnSwift = @convention(c) (
            UnsafeMutableRawPointer?,
            UInt32,
            UnsafeMutablePointer<UInt64>,
            UnsafeMutablePointer<UInt8>,
            UInt32,
            UnsafeMutablePointer<UInt64>,
            UnsafeMutableRawPointer?
        ) -> UInt32

        // double unsafeBitCast to workaround Swift compiler bug
        let fnPtr = unsafeBitCast(
            dispatchHostCall_C_Trampoline as JITHostFunctionFnSwift,
            to: UnsafeRawPointer.self
        )

        // Allocate JITHostFunctionTable on heap as C-compatible struct
        jitHostFunctionTablePtr = UnsafeMutablePointer<JITHostFunctionTable>.allocate(capacity: 1)
        jitHostFunctionTablePtr.initialize(to: JITHostFunctionTable(
            dispatchHostCall: unsafeBitCast(fnPtr, to: JITHostFunctionFn.self),
            ownerContext: Unmanaged.passUnretained(self).toOpaque(),
            invocationContext: nil,
            jumpTableData: nil,
            jumpTableSize: 0,
            jumpTableEntrySize: 0,
            jumpTableEntriesCount: 0,
            alignmentFactor: 0,
            dispatcherJumpTable: nil,
            dispatcherJumpTableSize: 0,
            heapEnd: 0 // Initial value, will be set from StandardMemory before execution
        ))
    }

    deinit {
        // Clear the code cache (frees dispatcher tables and function code for all cached entries)
        codeCache.clear()

        // Clean up heap-allocated struct
        jitHostFunctionTablePtr.deinitialize(count: 1)
        jitHostFunctionTablePtr.deallocate()
    }

    // Simple synchronous handler for host functions
    // This is the bridge between the sync world of JIT and the async world of Swift
    fileprivate func dispatchHostCall(
        hostCallIndex: UInt32,
        guestRegistersPtr: UnsafeMutablePointer<UInt64>,
        guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
        guestMemorySize: UInt32,
        guestGasPtr: UnsafeMutablePointer<UInt64>,
        invocationContextPtr _: UnsafeMutableRawPointer?
    ) -> UInt32 { // Return value for guest (e.g., to be put in R0) or error code
        logger.debug("Swift: dispatchHostCall received call for index \(hostCallIndex)")

        // Fixed gas cost for host function call setup
        let hostCallSetupGasCost: UInt64 = 100

        // Check if we have enough gas for the host call setup
        if guestGasPtr.pointee < hostCallSetupGasCost {
            logger.error("Swift: Gas exhausted during host function call setup")
            return JITHostCallError.gasExhausted.rawValue
        }

        // Deduct gas for host call setup
        guestGasPtr.pointee -= hostCallSetupGasCost

        // Use the syncHandler to handle host calls
        if let handler = syncHostCallHandler {
            let result = handler(hostCallIndex, guestRegistersPtr, guestMemoryBasePtr, guestMemorySize, guestGasPtr)

            // Fixed gas cost for host function call teardown
            let hostCallTeardownGasCost: UInt64 = 50

            // Check if we have enough gas for teardown
            if guestGasPtr.pointee < hostCallTeardownGasCost {
                logger.error("Swift: Gas exhausted during host function call teardown")
                return JITHostCallError.gasExhausted.rawValue
            }

            // Deduct gas for host call teardown
            guestGasPtr.pointee -= hostCallTeardownGasCost

            logger.debug("Swift: Host function \(hostCallIndex) executed successfully via sync handler")
            return result
        } else {
            logger.error("Swift: No host function handler available")
            return JITHostCallError.internalErrorInvalidContext.rawValue
        }
    }

    func execute(
        config: PvmConfig,
        blob: Data,
        pc: UInt32,
        gas: Gas,
        argumentData: Data?,
        ctx: (any InvocationContext)?
    ) async -> VMExecutionResult {
        logger.debug("JIT execution request. PC: \(pc), Gas: \(gas.value), Blob size: \(blob.count) bytes.")

        // ‚ö†Ô∏è CRITICAL: Offload JIT execution to DispatchQueue to avoid blocking Swift concurrency pool
        // The semaphore.wait() in host call bridge blocks the thread, which can exhaust
        // the Swift concurrency pool and cause deadlocks when multiple executions run concurrently.
        // By offloading to DispatchQueue.global(), we use non-pool threads for blocking operations.
        //
        // We use UncheckedSendableBox to safely pass non-Sendable values across concurrency boundary.
        // This is safe because:
        // 1. Each execute() call creates its own boxed values
        // 2. The DispatchQueue.async closure captures these boxes exclusively
        // 3. No shared mutable state is accessed concurrently
        let boxedSelf = UncheckedSendableBox(self)
        let boxedConfig = UncheckedSendableBox(config)
        let boxedCtx = UncheckedSendableBox(ctx)
        let boxedBlob = UncheckedSendableBox(blob)
        let boxedArgumentData = UncheckedSendableBox(argumentData)

        return await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let result = try boxedSelf.value.executeSynchronous(
                        config: boxedConfig.value,
                        blob: boxedBlob.value,
                        pc: pc,
                        gas: gas,
                        argumentData: boxedArgumentData.value,
                        ctx: boxedCtx.value
                    )
                    continuation.resume(returning: result)
                } catch {
                    // Handle error and convert to VMExecutionResult
                    let mappedError: VMExecutionResult = if let jitError = error as? JITError {
                        .init(
                            exitReason: jitError.toExitReason(),
                            gasUsed: gas,
                            outputData: nil
                        )
                    } else {
                        .init(
                            exitReason: .panic(.trap),
                            gasUsed: gas,
                            outputData: nil
                        )
                    }
                    continuation.resume(returning: mappedError)
                }
            }
        }
    }

    /// Synchronous JIT execution (runs on DispatchQueue, not Swift concurrency pool)
    private func executeSynchronous(
        config: PvmConfig,
        blob: Data,
        pc: UInt32,
        gas: Gas,
        argumentData: Data?,
        ctx: (any InvocationContext)?
    ) throws -> VMExecutionResult {
        var currentGas = gas // Mutable copy for JIT execution

        do {
            // Ensure cleanup happens on both success and error paths
            defer {
                syncHostCallHandler = nil
                currentProgramCode = nil
            }

            let targetArchitecture = JITPlatform.getCurrentTargetArchitecture()
            logger.debug("Target architecture for JIT: \(targetArchitecture)")

            // CRITICAL FIX: Parse as StandardProgram to get proper memory layout
            // This is required to match interpreter behavior and avoid extra state writes
            let standardProgram: StandardProgram
            do {
                standardProgram = try StandardProgram(blob: blob, argumentData: argumentData)
                currentProgramCode = standardProgram.code
            } catch {
                logger.error("Failed to create StandardProgram: \(error)")
                return VMExecutionResult(
                    exitReason: .panic(.invalidInstructionIndex),
                    gasUsed: gas,
                    outputData: nil,
                    finalRegisters: Registers(),
                    finalPC: 0
                )
            }

            // CRITICAL FIX: Pass the extracted bytecode, not the raw blob!
            // The blob contains headers (jump table count, encode size, code length, etc.)
            // but the JIT compiler expects just the bytecode portion.

            // MMAP SPARSE ALLOCATION: Use 4GB address space with mmap for efficient virtual memory usage
            // With mmap(MAP_NORESERVE), we reserve 4GB of virtual address space without allocating physical memory.
            // The OS only allocates physical pages for regions we actually write to.
            let totalMemorySize: UInt32
            let memoryLayout: JITMemoryLayout?

            do {
                // Create memory layout from StandardProgram for efficient zone initialization
                // Use rebased layout for efficient memory usage
                let layout = try JITMemoryLayout(standardProgram: standardProgram)
                memoryLayout = layout

                // CRITICAL: JIT must use pvmProgramInitStackBaseAddress to match interpreter memory layout
                // The interpreter allows accesses up to this address (uses sparse memory model)
                // Even if program zones don't reach this high, JIT needs same memory size for compatibility.
                // NOTE: This hybrid approach uses compact layout for zone offsets but traditional
                // layout for total memory size. A full transition to compact layout would require
                // changing the interpreter's memory model, which is beyond the current scope.
                totalMemorySize = UInt32(config.pvmProgramInitStackBaseAddress)

                logger.debug("üîç Using pvmProgramInitStackBaseAddress for memory size: 0x\(String(totalMemorySize, radix: 16))")

                let actualUsage = layout.totalSize
                let usageMB = Double(actualUsage) / (1024.0 * 1024.0)
                let totalMB = Double(totalMemorySize) / (1024.0 * 1024.0)

                logger.debug(
                    "‚úÖ Using interpreter-compatible layout: total=\(String(format: "%.2f", totalMB)) MB (data: \(String(format: "%.2f", usageMB)) MB)"
                )
            } catch {
                // Fallback if layout creation fails
                logger.error("Failed to create JITMemoryLayout: \(error)")
                totalMemorySize = UInt32(config.pvmProgramInitStackBaseAddress)
                memoryLayout = nil
            }

            // Safely unwrap programCode with proper error handling
            guard let programCode = currentProgramCode else {
                logger.error("ProgramCode not available for JIT compilation")
                return VMExecutionResult(
                    exitReason: .panic(.trap),
                    gasUsed: gas,
                    outputData: nil,
                    finalRegisters: Registers(),
                    finalPC: 0
                )
            }

            // Get initial memory from StandardProgram for proper initialization
            let initialMemory = standardProgram.initialMemory

            // Check cache for previously compiled function
            // TEMPORARY: Disable cache to force recompilation with correct memory size
            // TODO: Add memory size to cache key to properly enable caching
            let bytecode = programCode.code
            logger
                .info(
                    "üîç JIT bytecode: \(bytecode.prefix(20).map { String(format: "%02x", $0) }.joined(separator: " "))... (total: \(bytecode.count) bytes)"
                )
            logger.debug("üîç JIT initial PC: \(pc)")
            let compiledFuncPtr: UnsafeMutableRawPointer
            let dispatcherTable: UnsafeMutablePointer<UnsafeMutableRawPointer?>?
            let dispatcherTableSize: UInt32

            // TODO: Re-enable JIT caching after debugging (currently disabled for troubleshooting)
            if false, let cachedEntry = codeCache.lookup(bytecode: bytecode, config: config, initialPC: pc) {
                // Cache hit - use cached function pointer
                compiledFuncPtr = UnsafeMutableRawPointer(mutating: cachedEntry.functionPtr)
                dispatcherTable = cachedEntry.dispatcherTable
                dispatcherTableSize = cachedEntry.dispatcherTableSize
                logger.debug("Using cached JIT function")
            } else {
                // Cache miss - compile and cache the function

                // Extract skip table from programCode for variable-length instruction encoding
                // This is CRITICAL for instructions like LoadImmJump, BranchImm, etc.
                let skipTable = programCode.skipValues

                // Extract bitmask for branch validation
                // This ensures JIT only jumps to valid instruction boundaries
                let bitmask = programCode.bitmask

                compiledFuncPtr = try jitCompiler.compile(
                    blob: bytecode,
                    initialPC: pc,
                    config: config,
                    targetArchitecture: targetArchitecture,
                    jitMemorySize: totalMemorySize,
                    skipTable: skipTable,
                    bitmask: bitmask
                )

                // Retrieve dispatcher jump table for this compiled function
                // This allows JumpInd to work without a PVM jump table
                var size: size_t = 0
                let table = getDispatcherTable(compiledFuncPtr, &size)
                dispatcherTable = table
                dispatcherTableSize = UInt32(size)

                // Store in cache for future use
                codeCache.store(
                    bytecode: bytecode,
                    config: config,
                    initialPC: pc,
                    functionPtr: compiledFuncPtr,
                    dispatcherTable: dispatcherTable,
                    dispatcherTableSize: dispatcherTableSize
                )
            }

            // Update the JITHostFunctionTable with the dispatcher table
            if let table = dispatcherTable {
                logger.debug("Dispatcher table retrieved: \(dispatcherTableSize) entries")
                jitHostFunctionTablePtr.pointee.dispatcherJumpTable = table
                jitHostFunctionTablePtr.pointee.dispatcherJumpTableSize = dispatcherTableSize
            } else {
                if JITPlatform.getCurrentTargetArchitecture() == .arm64 {
                    logger.debug("No dispatcher table found for compiled function (expected on ARM64)")
                } else {
                    logger.warning("No dispatcher table found for compiled function - JumpInd may fall back to interpreter")
                }
            }

            // Initialize registers from StandardProgram
            // Always use initialRegisters to match VMStateInterpreter behavior
            // VMStateInterpreter uses program.initialRegisters even when argumentData is nil
            var registers: Registers = standardProgram.initialRegisters

            // Log initial register values for debugging
            logger
                .info(
                    "Initial registers: R0=\(registers[Registers.Index(raw: 0)]), R1=\(registers[Registers.Index(raw: 1)]), R7=\(registers[Registers.Index(raw: 7)]), R8=\(registers[Registers.Index(raw: 8)])"
                )

            // Set up the synchronous handler that will bridge to async context if invoked
            // We're capturing the invocationContext into a closure that will be called synchronously
            if let invocationContext = ctx {
                // Initialize the synchronous handler
                // Use [weak self] to avoid retain cycle (cleanup happens in defer block)
                syncHostCallHandler =
                    { [weak self] hostCallIndex, guestRegistersPtr, guestMemoryBasePtr, guestMemorySize, guestGasPtr -> UInt32 in
                        guard let self else {
                            return JITHostCallError.internalErrorInvalidContext.rawValue
                        }

                        guard let programCode = currentProgramCode else {
                            logger.error("No program code available for host call")
                            return JITHostCallError.internalErrorInvalidContext.rawValue
                        }

                        // Create a VMStateJIT adapter
                        // NOTE: PC is tracked internally by JIT-compiled code, not exposed to host calls.
                        // Using 0 as initialPC. The PC value is typically not needed by host functions,
                        // but if it is, the C++ JIT code needs to be modified to pass it.
                        let vmState = VMStateJIT(
                            jitMemoryBasePtr: guestMemoryBasePtr,
                            jitMemorySize: guestMemorySize,
                            jitRegistersPtr: guestRegistersPtr,
                            jitGasPtr: guestGasPtr,
                            programCode: programCode,
                            initialPC: 0
                        )

                        // Convert async operation to sync using semaphore + lock
                        let semaphore = DispatchSemaphore(value: 0)

                        // Thread-safe result box using class wrapper (required for escaping closure)
                        final class ResultBox: @unchecked Sendable {
                            private let lock = Utils.ReadWriteLock()
                            private var _value: ExecOutcome?

                            func set(_ value: ExecOutcome) {
                                lock.withWriteLock { _value = value }
                            }

                            func get() -> ExecOutcome? {
                                lock.withReadLock { _value }
                            }
                        }

                        let resultBox = ResultBox()

                        // ‚ö†Ô∏è Thread-safety requirement: InvocationContext must be thread-safe
                        // The context is passed to a detached task that may run on a different thread.
                        // Implementations MUST ensure:
                        // 1. Context is NOT shared across concurrent executions (use separate instances)
                        // 2. Context internally synchronizes access to mutable state (locks/actors)
                        // 3. Context does NOT rely on thread-local storage
                        //
                        // The UncheckedSendableBox wrapper allows passing non-Sendable contexts
                        // across concurrency boundaries, but safety depends on proper implementation.
                        let boxedCtx = UncheckedSendableBox(invocationContext)

                        // Kick off the async operation on a detached task
                        Task.detached(priority: Task.currentPriority) {
                            let r = await boxedCtx.value.dispatch(index: hostCallIndex, state: vmState)
                            resultBox.set(r)
                            semaphore.signal()
                        }

                        // Block until async operation completes
                        // ‚úÖ SAFE: This blocks the DispatchQueue thread (NOT Swift concurrency pool)
                        //
                        // The execute() method offloads JIT execution to DispatchQueue.global(),
                        // so this semaphore.wait() blocks a dedicated non-pool thread.
                        // The Swift concurrency pool remains free for the detached task to run.
                        //
                        // This architecture allows:
                        // - Multiple PVM programs to run concurrently (different executor instances)
                        // - Host functions to use async/await without deadlocking the pool
                        semaphore.wait()

                        // Process the result
                        guard let result = resultBox.get() else {
                            logger.error("No result from async host function call")
                            return JITHostCallError.hostFunctionThrewError.rawValue
                        }

                        switch result {
                        case .continued:
                            return 0
                        case let .exit(reason):
                            switch reason {
                            case .halt:
                                return JITHostCallError.hostRequestedHalt.rawValue
                            case .outOfGas:
                                return JITHostCallError.gasExhausted.rawValue
                            case let .hostCall(nestedIndex):
                                logger.error("Nested host calls not supported: \(nestedIndex)")
                                return JITHostCallError.hostFunctionThrewError.rawValue
                            case let .pageFault(address):
                                logger.error("Page fault at address \(address)")
                                return JITHostCallError.pageFault.rawValue
                            case .panic:
                                return JITHostCallError.hostFunctionThrewError.rawValue
                            }
                        }
                    }
            } else {
                // Clear the handler if no context provided
                syncHostCallHandler = nil
            }

            // Update the invocation context in the JIT host function table
            jitHostFunctionTablePtr.pointee.invocationContext = nil // We're using the syncHandler now

            // Get pointer to heap-allocated JITHostFunctionTable
            let invocationContextPointer = UnsafeMutableRawPointer(jitHostFunctionTablePtr)

            // Execute the JIT-compiled function
            // CRITICAL: Must wrap execute call in withUnsafeBytes to ensure jump table pointer remains valid
            let (exitReason, memoryInfo): (ExitReason, MemoryAllocationInfo)
            let memoryBuffer: UnsafeMutablePointer<UInt8> // Extract pointer for use in output reading

            if let programCode = currentProgramCode {
                // Populate jump table data for JumpInd instruction support
                // and execute while the pointer is still valid
                let (er, mi): (ExitReason, MemoryAllocationInfo) = try programCode.jumpTable.withUnsafeBytes { rawBufferPointer in
                    // Set jump table data pointer (valid only within this closure)
                    jitHostFunctionTablePtr.pointee.jumpTableData = rawBufferPointer.baseAddress?.assumingMemoryBound(to: UInt8.self)
                    jitHostFunctionTablePtr.pointee.jumpTableSize = UInt32(programCode.jumpTable.count)
                    jitHostFunctionTablePtr.pointee.jumpTableEntrySize = programCode.jumpTableEntrySize
                    // Guard against division by zero when jumpTableEntrySize is 0 (empty jump table)
                    jitHostFunctionTablePtr.pointee.jumpTableEntriesCount =
                        programCode.jumpTableEntrySize > 0
                            ? UInt32(programCode.jumpTable.count / Int(programCode.jumpTableEntrySize))
                            : 0
                    jitHostFunctionTablePtr.pointee.alignmentFactor = UInt32(config.pvmDynamicAddressAlignmentFactor)

                    // CRITICAL FIX: Initialize heapEnd for JIT sbrk instruction
                    // Get initial heap end from StandardMemory to match interpreter behavior
                    if let stdMem = initialMemory as? StandardMemory {
                        jitHostFunctionTablePtr.pointee.heapEnd = stdMem.heapEnd
                    } else {
                        // Fallback: use heap zone start address from config
                        // This should not happen in normal operation
                        logger.error("initialMemory is not StandardMemory, using default heapEnd")
                        let ZZ = UInt32(config.pvmProgramInitZoneSize)
                        let Z = StandardProgram.alignToZoneSize
                        let heapStart = 2 * ZZ + Z(UInt32(standardProgram.code.code.count), config)
                        jitHostFunctionTablePtr.pointee.heapEnd = heapStart
                    }

                    // Execute the JIT-compiled function while jumpTableData pointer is valid
                    // The JIT function will use our syncHostCallHandler via the C trampoline
                    return try jitExecutor.execute(
                        functionPtr: compiledFuncPtr,
                        registers: &registers,
                        jitMemorySize: totalMemorySize,
                        gas: &currentGas,
                        initialPC: pc,
                        invocationContext: invocationContextPointer,
                        initialMemory: initialMemory,
                        memoryLayout: memoryLayout
                    )
                }
                // Assign values from first execution path
                exitReason = er
                memoryInfo = mi
                memoryBuffer = mi.pointer
            } else {
                // No jump table available
                jitHostFunctionTablePtr.pointee.jumpTableData = nil
                jitHostFunctionTablePtr.pointee.jumpTableSize = 0
                jitHostFunctionTablePtr.pointee.jumpTableEntrySize = 0
                jitHostFunctionTablePtr.pointee.jumpTableEntriesCount = 0
                jitHostFunctionTablePtr.pointee.alignmentFactor = UInt32(config.pvmDynamicAddressAlignmentFactor)

                // CRITICAL FIX: Initialize heapEnd for JIT sbrk instruction
                // Get initial heap end from StandardMemory to match interpreter behavior
                if let stdMem = initialMemory as? StandardMemory {
                    jitHostFunctionTablePtr.pointee.heapEnd = stdMem.heapEnd
                } else {
                    // Fallback: use heap zone start address from config
                    // This should not happen in normal operation
                    logger.error("initialMemory is not StandardMemory, using default heapEnd")
                    let ZZ = UInt32(config.pvmProgramInitZoneSize)
                    let Z = StandardProgram.alignToZoneSize
                    let heapStart = 2 * ZZ + Z(UInt32(standardProgram.code.code.count), config)
                    jitHostFunctionTablePtr.pointee.heapEnd = heapStart
                }

                // Execute without jump table
                let (er, mi) = try jitExecutor.execute(
                    functionPtr: compiledFuncPtr,
                    registers: &registers,
                    jitMemorySize: totalMemorySize,
                    gas: &currentGas,
                    initialPC: pc,
                    invocationContext: invocationContextPointer,
                    initialMemory: initialMemory,
                    memoryLayout: memoryLayout
                )
                // Assign values from second execution path
                exitReason = er
                memoryInfo = mi
                memoryBuffer = mi.pointer
            }

            // Ensure memory is deallocated exactly once using defer
            defer {
                memoryInfo.deallocate()
            }

            // Clear the invocation context reference and jump table data after execution
            // The jumpTableData pointer was only valid within the withUnsafeBytes block above
            jitHostFunctionTablePtr.pointee.invocationContext = nil
            jitHostFunctionTablePtr.pointee.jumpTableData = nil
            jitHostFunctionTablePtr.pointee.jumpTableSize = 0
            jitHostFunctionTablePtr.pointee.jumpTableEntrySize = 0
            jitHostFunctionTablePtr.pointee.jumpTableEntriesCount = 0
            jitHostFunctionTablePtr.pointee.alignmentFactor = 0

            // Calculate gas used (handle saturating Gas type correctly)
            let gasUsed: Gas = if exitReason == .outOfGas {
                // When out of gas, all remaining gas was used
                gas
            } else {
                // Normal execution: subtract remaining from initial
                gas - currentGas
            }

            // Get output data from JIT memory (only on halt, following invokePVM pattern)
            let outputData: Data?
            switch exitReason {
            case .halt:
                // Read output address and length from registers r7 and r8
                let outputAddr = UInt32(truncatingIfNeeded: registers[Registers.Index(raw: 7)])
                let outputLen = UInt32(truncatingIfNeeded: registers[Registers.Index(raw: 8)])

                // Validate and read from JIT memory (prevent integer overflow)
                if outputLen == 0 {
                    // Empty output is valid
                    outputData = Data()
                } else if UInt64(outputAddr) + UInt64(outputLen) <= UInt64(totalMemorySize) {
                    outputData = Data(bytes: memoryBuffer.advanced(by: Int(outputAddr)), count: Int(outputLen))
                } else {
                    // Invalid memory access - treat as panic to signal the error
                    logger.error("Invalid output memory range: addr=\(outputAddr), len=\(outputLen), memorySize=\(totalMemorySize)")
                    return VMExecutionResult(
                        exitReason: .panic(.jitMemoryError),
                        gasUsed: gasUsed,
                        outputData: nil,
                        finalRegisters: Registers(),
                        finalPC: 0
                    )
                }
            default:
                outputData = nil
            }

            logger.debug("JIT execution finished. Reason: \(exitReason). Gas used: \(gasUsed.value)")
            // Note: PC is not tracked by JIT execution (only exit reason matters)
            return VMExecutionResult(
                exitReason: exitReason,
                gasUsed: gasUsed,
                outputData: outputData,
                finalRegisters: registers,
                finalPC: 0 // JIT doesn't track final PC - only exit reason
            )

        } catch let error as JITCompiler.CompilationError {
            logger.error("JIT compilation failed: \(error)")
            // Convert compilation errors to appropriate JIT errors
            let jitError: JITError
            if case .compilationFailed(4) = error {
                // Error code 4 = invalid branch target (not at instruction boundary)
                jitError = .invalidBranchTarget
            } else {
                // For other compilation errors, extract the error code if available
                var errorCode: Int32 = -1
                if case let .compilationFailed(code) = error {
                    errorCode = code
                }
                jitError = .compilationFailed(errorCode)
            }
            return VMExecutionResult(
                exitReason: jitError.toExitReason(),
                gasUsed: gas,
                outputData: nil,
                finalRegisters: Registers(),
                finalPC: 0
            )
        } catch let error as JITError {
            logger.error("JIT execution failed with JITError: \(error)")
            return VMExecutionResult(
                exitReason: error.toExitReason(),
                gasUsed: gas,
                outputData: nil,
                finalRegisters: Registers(),
                finalPC: 0
            )
        } catch {
            logger.error("JIT execution failed with an unexpected error: \(error)")
            return VMExecutionResult(
                exitReason: .panic(.trap),
                gasUsed: gas,
                outputData: nil,
                finalRegisters: Registers(),
                finalPC: 0
            )
        }
    }
}

// Defines standardized error codes for JIT host function calls.
// These raw values are returned by the host call C trampoline to the JIT-compiled code.
// The JIT-compiled code must check if the returned UInt32 matches any of these error codes.
// If it does, the JIT code should treat it as a VM-level error (e.g., trigger a panic).
// Otherwise, the returned UInt32 is the successful result from the host function.
// These values are chosen to be at the high end of the UInt32 range to minimize
// collision with legitimate success values returned by host functions.

enum JITHostCallError: UInt32 {
    // Indicates an internal error within the JIT host call mechanism,
    // such as the owner context being nil.
    case internalErrorInvalidContext = 0xFFFF_FFFF

    // Indicates that no host function was found registered for the given index.
    case hostFunctionNotFound = 0xFFFF_FFFE

    // Indicates that the registered host function was called but threw a Swift error during its execution.
    case hostFunctionThrewError = 0xFFFF_FFFD

    // Indicates that the VM ran out of gas during host function execution
    case gasExhausted = 0xFFFF_FFFC

    // Indicates that a page fault occurred during host function execution
    case pageFault = 0xFFFF_FFFB

    // Indicates that the host function requested the VM to halt
    case hostRequestedHalt = 0xFFFF_FFFA
}

// Static C-callable trampoline that calls the instance method.
private func dispatchHostCall_C_Trampoline(
    opaqueOwnerContext: UnsafeMutableRawPointer?,
    hostCallIndex: UInt32,
    guestRegistersPtr: UnsafeMutablePointer<UInt64>,
    guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
    guestMemorySize: UInt32,
    guestGasPtr: UnsafeMutablePointer<UInt64>,
    invocationContextPtr: UnsafeMutableRawPointer?
) -> UInt32 {
    guard let ownerCtxPtr = opaqueOwnerContext else {
        return JITHostCallError.internalErrorInvalidContext.rawValue
    }
    let backendInstance = Unmanaged<ExecutorBackendJIT>.fromOpaque(ownerCtxPtr).takeUnretainedValue()

    // Call the instance method that handles the dispatch
    return backendInstance.dispatchHostCall(
        hostCallIndex: hostCallIndex,
        guestRegistersPtr: guestRegistersPtr,
        guestMemoryBasePtr: guestMemoryBasePtr,
        guestMemorySize: guestMemorySize,
        guestGasPtr: guestGasPtr,
        invocationContextPtr: invocationContextPtr
    )
}
