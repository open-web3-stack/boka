// generated by polka.codes
// This file implements the JIT (Just-In-Time) compilation backend for the PolkaVM executor.
// It translates PolkaVM bytecode into native machine code at runtime for potentially faster execution.

import asmjit
import CppHelper
import Foundation
import TracingUtils
import Utils

final class ExecutorBackendJIT: ExecutorBackend, @unchecked Sendable {
    private let logger = Logger(label: "ExecutorBackendJIT")

    private let jitCache = JITCache()
    private let jitCompiler = JITCompiler()
    private let jitExecutor = JITExecutor()
    private let jitMemoryManager = JITMemoryManager()

    // Host function handling
    // TODO: The actual HostFunction signature needs to be more robust, likely involving a temporary VMState view.
    public typealias HostFunction = (
        _ guestRegisters: UnsafeMutablePointer<UInt64>,
        _ guestMemoryBase: UnsafeMutablePointer<UInt8>,
        _ guestMemorySize: UInt32,
        _ guestGas: UnsafeMutablePointer<UInt64>
        // TODO: Add specific arguments extracted from registers if needed
    ) throws -> UInt32 // Return value to be placed in a guest register (e.g., R0), or an error indicator.

    private var registeredHostFunctions: [UInt32: HostFunction] = [:]
    // This will hold the JITHostFunctionTable struct itself, and we'll pass a pointer to it.
    private var jitHostFunctionTableStorage: JITHostFunctionTable! // force unwrapped so we can have cyclic reference

    // Overall Plan for ExecutorBackendJIT Implementation:
    //
    // 1. Caching (`JITCache`):
    //    - Manages caching of compiled function pointers.
    //    - Key: `JITCacheKey` (blob hash, PC, target arch, config signature).
    //
    // 2. Platform Helper (`JITPlatformHelper`):
    //    - Determines target architecture.
    //
    // 3. Compilation (`JITCompiler`, `CppHelper`, `asmjit`):
    //    - Translates PolkaVM bytecode to native code via `CppHelper`.
    //
    // 4. Native Function Signature (`JITFunctionSignature` in `JITCompiler.swift`):
    //    - Defines C ABI for JIT-compiled functions.
    //
    // 5. Execution (`JITExecutor`):
    //    - Calls the JIT-compiled native function.
    //
    // 6. Memory Management (`JITMemoryManager`):
    //    - Manages the JIT's flat memory buffer.
    //    - Prepares buffer from PVM `Memory`, reflects changes back.
    //
    // 7. VM State (`Registers`, `Memory`, `Gas`):
    //    - Handled by this class, passed to/from JIT components.
    //
    // 8. `InvocationContext` and Syscalls/Host Functions:
    //    - Implemented via `JITHostFunctionTable` passed as `cInvocationContextPtr`.
    //    - CppHelper's JITed code calls a C++ trampoline, which then calls a Swift C-ABI function.
    //
    // 9. Error Handling (`JITError`):
    //    - Custom error enum for JIT-specific failures.
    //
    // 10. Configuration (`PvmConfig`):
    //     - Drives JIT behavior (enable, cache, memory size, etc.).

    // TODO: The init method should ideally take a PvmConfig or target architecture string
    // to correctly initialize CppHelper. For now, we'll use a placeholder or attempt
    // to get the host architecture if JITPlatformHelper allows without a full config.
    init() {
        // Need to match with JITHostFunctionFn in helper.hh
        // we can't use JITHostFunctionFn directly due to Swift compiler bug
        typealias JITHostFunctionFnSwift = @convention(c) (
            UnsafeMutableRawPointer?,
            UInt32,
            UnsafeMutablePointer<UInt64>,
            UnsafeMutablePointer<UInt8>,
            UInt32,
            UnsafeMutablePointer<UInt64>
        ) -> UInt32

        // double unsafeBitCast to workaround Swift compiler bug
        let fnPtr = unsafeBitCast(
            dispatchHostCall_C_Trampoline as JITHostFunctionFnSwift,
            to: UnsafeRawPointer.self
        )
        jitHostFunctionTableStorage = JITHostFunctionTable(
            dispatchHostCall: unsafeBitCast(fnPtr, to: JITHostFunctionFn.self),
            ownerContext: Unmanaged.passUnretained(self).toOpaque()
        )
    }

    // Public method to register host functions
    public func registerHostFunction(index: UInt32, function: @escaping HostFunction) {
        registeredHostFunctions[index] = function
        logger.info("Registered host function for index \(index)")
    }

    // Instance method to handle the dispatch, called by the C trampoline
    fileprivate func dispatchHostCall(
        hostCallIndex: UInt32,
        guestRegistersPtr: UnsafeMutablePointer<UInt64>,
        guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
        guestMemorySize: UInt32,
        guestGasPtr: UnsafeMutablePointer<UInt64>
    ) -> UInt32 { // Return value for guest (e.g., to be put in R0) or error code
        logger.debug("Swift: Instance dispatchHostCall received call for index \(hostCallIndex)")

        guard let hostFunction = registeredHostFunctions[hostCallIndex] else {
            logger.error("Swift: No host function registered for index \(hostCallIndex)")
            // Return error code for "host function not found".
            return JITHostCallError.hostFunctionNotFound.rawValue
        }

        do {
            // TODO: Implement gas accounting for the host call itself (fixed entry/exit cost).
            // The registered `hostFunction` is responsible for its internal gas consumption
            // by decrementing `guestGasPtr.pointee` as needed.

            let resultFromHostFn = try hostFunction(
                guestRegistersPtr,
                guestMemoryBasePtr,
                guestMemorySize,
                guestGasPtr
            )

            // By convention, the JIT code that calls the host function trampoline
            // will expect the result in a specific register (e.g., x0 on AArch64).
            // The C++ trampoline will place `resultFromHostFn` into this return register.
            logger.debug("Swift: Host function \(hostCallIndex) executed successfully, result: \(resultFromHostFn)")
            return resultFromHostFn
        } catch {
            logger.error("Swift: Host function \(hostCallIndex) threw an error: \(error)")
            // Return error code for "host function threw error".
            return JITHostCallError.hostFunctionThrewError.rawValue
        }
    }

    func execute(
        config: PvmConfig,
        blob: Data,
        pc: UInt32,
        gas: Gas,
        argumentData: Data?,
        ctx _: (any InvocationContext)?
    ) async -> ExitReason {
        logger.info("JIT execution request. PC: \(pc), Gas: \(gas.value), Blob size: \(blob.count) bytes.")
        // TODO: Implement argumentData handling if JIT functions need it directly or for memory setup.

        var currentGas = gas // Mutable copy for JIT execution

        do {
            let targetArchitecture = try JITPlatformHelper.getCurrentTargetArchitecture(config: config)
            logger.debug("Target architecture for JIT: \(targetArchitecture)")

            let jitCacheKey = JITCache.createCacheKey(
                blob: blob,
                initialPC: pc,
                targetArchitecture: targetArchitecture,
                config: config
            )

            let jitTotalMemorySize = jitMemoryManager.getJITTotalMemorySize(config: config)
            var functionPtr: UnsafeMutableRawPointer?
            let functionAddress = await jitCache.getCachedFunction(forKey: jitCacheKey)
            if let address = functionAddress {
                functionPtr = UnsafeMutableRawPointer(bitPattern: address)
                logger.debug("JIT cache hit. Using cached function.")
            } else {
                logger.debug("JIT cache miss. Proceeding to compilation.")
            }

            if functionPtr == nil { // Cache miss or cache disabled
                let compiledFuncPtr = try jitCompiler.compile(
                    blob: blob,
                    initialPC: pc,
                    config: config,
                    targetArchitecture: targetArchitecture,
                    jitMemorySize: jitTotalMemorySize
                )
                functionPtr = compiledFuncPtr

                let functionAddressToCache = UInt(bitPattern: compiledFuncPtr)
                await jitCache.cacheFunction(functionAddressToCache, forKey: jitCacheKey)
                logger.debug("Compilation successful. Function cached.")
            }

            guard let validFunctionPtr = functionPtr else {
                // This case should ideally be caught by errors in compile or cache logic.
                logger.error("Function pointer is unexpectedly nil after cache check/compilation.")
                throw JITError.functionPointerNil
            }

            var registers = Registers()
            // TODO: Initialize registers based on `argumentData` or PVM calling convention.

            var vmMemory: Memory
            do {
                // TODO: Refine StandardMemory initialization based on PvmConfig.
                // These are placeholders and should align with actual PvmConfig structure.
                let pvmPageSize = UInt32(config.pvmMemoryPageSize)
                vmMemory = try StandardMemory(
                    readOnlyData: config.readOnlyDataSegment ?? Data(),
                    readWriteData: config.readWriteDataSegment ?? Data(),
                    argumentData: argumentData ?? Data(),
                    heapEmptyPagesSize: config.initialHeapPages * pvmPageSize,
                    stackSize: config.stackPages * pvmPageSize
                )
            } catch {
                logger.error("Failed to initialize VM memory: \(error)")
                throw JITError.vmInitializationError(details: "StandardMemory init failed: \(error)")
            }

            var jitFlatMemoryBuffer = try jitMemoryManager.prepareJITMemoryBuffer(
                from: vmMemory,
                config: config,
                jitMemorySize: jitTotalMemorySize
            )

            let exitReason = try jitExecutor.execute(
                functionPtr: validFunctionPtr,
                registers: &registers,
                jitFlatMemoryBuffer: &jitFlatMemoryBuffer,
                jitMemorySize: jitTotalMemorySize,
                gas: &currentGas,
                initialPC: pc,
                invocationContext: nil
            )

            try jitMemoryManager.reflectJITMemoryChanges(
                from: jitFlatMemoryBuffer,
                to: &vmMemory,
                config: config,
                jitMemorySize: jitTotalMemorySize
            )

            // TODO: The `currentGas` (updated by JITExecutor) needs to be correctly propagated.
            // The `Executor` protocol's `execute` method returns `ExecOutcome` which includes gas.
            // This backend should return the final gas state.
            // For now, `currentGas` holds the final value. The frontend (ExecutorInProcess)
            // should use this updated gas.
            logger.info("JIT execution finished. Reason: \(exitReason). Remaining gas: \(currentGas.value)")
            // The `gas` parameter to this function is `let`, so we can't modify it directly.
            // The `ExecOutcome` should be constructed with `currentGas`.
            // This implies the return type of this function might need to align with `ExecOutcome` or similar.
            // For now, returning only ExitReason as per current ExecutorBackend protocol.
            // The frontend will need to manage gas based on the `inout` parameter it passes.
            return exitReason

        } catch let error as JITError {
            logger.error("JIT execution failed with JITError: \(error)")
            // TODO: Map JITError to appropriate ExitReason.panic sub-types or a generic JIT panic.
            // Example: return .panic(error.toPanicReason())
            // For now, using a generic trap for any JITError.
            return .panic(.trap) // Placeholder for JITError conversion
        } catch {
            logger.error("JIT execution failed with an unexpected error: \(error)")
            // TODO: Map other errors to ExitReason.panic.
            return .panic(.trap) // Placeholder for unexpected errors
        }
    }
}

//
// The temporary extension PvmConfig from the original file has been removed.
// These properties need to be formally added to the PvmConfig definition.

// Type for a C-callable host function trampoline
// It receives an opaque context (pointer to ExecutorBackendJIT instance),
// guest registers, guest memory, gas, and the host call index.
// Returns a status or result (e.g., value for R0 or an error code).
public typealias PolkaVMHostCallCHandler = @convention(c) (
    _ opaqueOwnerContext: UnsafeMutableRawPointer?, // Points to ExecutorBackendJIT instance
    _ hostCallIndex: UInt32,
    _ guestRegisters: UnsafeMutablePointer<UInt64>, // Guest registers (PolkaVM format)
    _ guestMemoryBase: UnsafeMutablePointer<UInt8>, // Guest memory base
    _ guestMemorySize: UInt32, // Guest memory size (for bounds checks)
    _ guestGas: UnsafeMutablePointer<UInt64> // Guest gas counter
) -> UInt32 // Represents a value to be written to a specific register (e.g. R0 by convention) or a JITHostCallError rawValue.

// Defines standardized error codes for JIT host function calls.
// These raw values are returned by the host call C trampoline to the JIT-compiled code.
// The JIT-compiled code must check if the returned UInt32 matches any of these error codes.
// If it does, the JIT code should treat it as a VM-level error (e.g., trigger a panic).
// Otherwise, the returned UInt32 is the successful result from the host function.
// These values are chosen to be at the high end of the UInt32 range to minimize
// collision with legitimate success values returned by host functions.
enum JITHostCallError: UInt32 {
    // Indicates an internal error within the JIT host call mechanism,
    // such as the owner context being nil.
    case internalErrorInvalidContext = 0xFFFF_FFFF

    // Indicates that no host function was found registered for the given index.
    case hostFunctionNotFound = 0xFFFF_FFFE

    // Indicates that the registered host function was called but threw a Swift error during its execution.
    case hostFunctionThrewError = 0xFFFF_FFFD

    // TODO: Add other specific error codes as needed, e.g., for gas exhaustion during host call setup,
    // argument validation failures before calling the host function, etc.
}

// Static C-callable trampoline that calls the instance method.
private func dispatchHostCall_C_Trampoline(
    opaqueOwnerContext: UnsafeMutableRawPointer?,
    hostCallIndex: UInt32,
    guestRegistersPtr: UnsafeMutablePointer<UInt64>,
    guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
    guestMemorySize: UInt32,
    guestGasPtr: UnsafeMutablePointer<UInt64>
) -> UInt32 {
    guard let ownerCtxPtr = opaqueOwnerContext else {
        // This is a critical error: the context to find the Swift instance is missing.
        // Ideally, log this error through a mechanism available in a static context if possible,
        // or ensure this path is never taken by robust setup.
        // Logger(label: "ExecutorBackendJIT_StaticTrampoline").error("dispatchHostCall_C_Trampoline: opaqueOwnerContext is nil.")
        // Return a specific error code indicating context failure.
        // This UInt32 will be checked by the JITed code. If it's this sentinel,
        // the JITed code should trigger a VM panic.
        // Return a specific error code indicating context failure.
        // The JITed code should check this and trigger a VM panic.
        return JITHostCallError.internalErrorInvalidContext.rawValue
    }
    let backendInstance = Unmanaged<ExecutorBackendJIT>.fromOpaque(ownerCtxPtr).takeUnretainedValue()

    // Call the instance method that actually handles the dispatch.
    return backendInstance.dispatchHostCall(
        hostCallIndex: hostCallIndex,
        guestRegistersPtr: guestRegistersPtr,
        guestMemoryBasePtr: guestMemoryBasePtr,
        guestMemorySize: guestMemorySize,
        guestGasPtr: guestGasPtr
    )
}
