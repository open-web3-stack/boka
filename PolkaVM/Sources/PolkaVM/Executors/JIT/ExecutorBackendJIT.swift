// generated by polka.codes
// JIT compilation backend for PolkaVM executor

import asmjit
import CppHelper
import Foundation
import TracingUtils
import Utils

// TODO: Build a cache system for generated code

final class ExecutorBackendJIT: ExecutorBackend {
    private let logger = Logger(label: "ExecutorBackendJIT")

    private let jitCompiler = JITCompiler()
    private let jitExecutor = JITExecutor()

    // This will hold the JITHostFunctionTable struct itself, and we'll pass a pointer to it.
    private var jitHostFunctionTableStorage: JITHostFunctionTable! // force unwrapped so we can have cyclic reference

    // Store the program code during execution for VMStateJIT
    private var currentProgramCode: ProgramCode?

    // We need a class wrapper for JITHostFunctionTable to avoid dangling pointer issues
    private class JITHostFunctionTableWrapper {
        var table: JITHostFunctionTable

        init(table: JITHostFunctionTable) {
            self.table = table
        }
    }

    // Wrapper to store the JITHostFunctionTable in a class for proper reference semantics
    private var jitHostFunctionTableWrapper: JITHostFunctionTableWrapper!

    // Using a simpler approach to handle host calls that doesn't require async/await
    private var syncHostCallHandler: ((
        UInt32,
        UnsafeMutablePointer<UInt64>,
        UnsafeMutablePointer<UInt8>,
        UInt32,
        UnsafeMutablePointer<UInt64>
    ) -> UInt32)?

    // TODO: Implement thread safety for JIT execution (similar to interpreter's async execution model)
    // TODO: Add support for debugging JIT-compiled code (instruction tracing, register dumps)
    // TODO: Implement proper memory management for JIT code (code cache eviction policies)
    // TODO: Add support for tiered compilation (interpret first, then JIT hot paths)

    // TODO: The init method should ideally take a PvmConfig or target architecture string
    // to correctly initialize CppHelper. For now, we'll use a placeholder or attempt
    // to get the host architecture if JITPlatformHelper allows without a full config.
    // TODO: Initialize JIT with instruction handlers that match interpreter behavior exactly
    init() {
        // Need to match with JITHostFunctionFn in helper.hh
        // we can't use JITHostFunctionFn directly due to Swift compiler bug
        typealias JITHostFunctionFnSwift = @convention(c) (
            UnsafeMutableRawPointer?,
            UInt32,
            UnsafeMutablePointer<UInt64>,
            UnsafeMutablePointer<UInt8>,
            UInt32,
            UnsafeMutablePointer<UInt64>,
            UnsafeMutableRawPointer?
        ) -> UInt32

        // double unsafeBitCast to workaround Swift compiler bug
        let fnPtr = unsafeBitCast(
            dispatchHostCall_C_Trampoline as JITHostFunctionFnSwift,
            to: UnsafeRawPointer.self
        )
        jitHostFunctionTableStorage = JITHostFunctionTable(
            dispatchHostCall: unsafeBitCast(fnPtr, to: JITHostFunctionFn.self),
            ownerContext: Unmanaged.passUnretained(self).toOpaque(),
            invocationContext: nil
        )

        // Create a wrapper for the table
        jitHostFunctionTableWrapper = JITHostFunctionTableWrapper(table: jitHostFunctionTableStorage)
    }

    // Simple synchronous handler for host functions
    // This is the bridge between the sync world of JIT and the async world of Swift
    fileprivate func dispatchHostCall(
        hostCallIndex: UInt32,
        guestRegistersPtr: UnsafeMutablePointer<UInt64>,
        guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
        guestMemorySize: UInt32,
        guestGasPtr: UnsafeMutablePointer<UInt64>,
        invocationContextPtr _: UnsafeMutableRawPointer?
    ) -> UInt32 { // Return value for guest (e.g., to be put in R0) or error code
        logger.debug("Swift: dispatchHostCall received call for index \(hostCallIndex)")

        // Fixed gas cost for host function call setup
        let hostCallSetupGasCost: UInt64 = 100

        // Check if we have enough gas for the host call setup
        if guestGasPtr.pointee < hostCallSetupGasCost {
            logger.error("Swift: Gas exhausted during host function call setup")
            return JITHostCallError.gasExhausted.rawValue
        }

        // Deduct gas for host call setup
        guestGasPtr.pointee -= hostCallSetupGasCost

        // Use the syncHandler to handle host calls
        if let handler = syncHostCallHandler {
            let result = handler(hostCallIndex, guestRegistersPtr, guestMemoryBasePtr, guestMemorySize, guestGasPtr)

            // Fixed gas cost for host function call teardown
            let hostCallTeardownGasCost: UInt64 = 50

            // Check if we have enough gas for teardown
            if guestGasPtr.pointee < hostCallTeardownGasCost {
                logger.error("Swift: Gas exhausted during host function call teardown")
                return JITHostCallError.gasExhausted.rawValue
            }

            // Deduct gas for host call teardown
            guestGasPtr.pointee -= hostCallTeardownGasCost

            logger.debug("Swift: Host function \(hostCallIndex) executed successfully via sync handler")
            return result
        } else {
            logger.error("Swift: No host function handler available")
            return JITHostCallError.internalErrorInvalidContext.rawValue
        }
    }

    func execute(
        config: PvmConfig,
        blob: Data,
        pc: UInt32,
        gas: Gas,
        argumentData: Data?,
        ctx: (any InvocationContext)?
    ) async -> ExitReason {
        logger.debug("JIT execution request. PC: \(pc), Gas: \(gas.value), Blob size: \(blob.count) bytes.")

        var currentGas = gas // Mutable copy for JIT execution

        do {
            let targetArchitecture = JITPlatform.getCurrentTargetArchitecture()
            logger.debug("Target architecture for JIT: \(targetArchitecture)")

            // TODO: lookup from cache

            let compiledFuncPtr = try jitCompiler.compile(
                blob: blob,
                initialPC: pc,
                config: config,
                targetArchitecture: targetArchitecture,
                jitMemorySize: UInt32.max // TODO:
            )

            var registers = Registers(config: config, argumentData: argumentData)

            let jitTotalMemorySize = UInt32.max

            // Set up program code for host function calls
            do {
                currentProgramCode = try ProgramCode(blob)
            } catch {
                logger.error("Failed to create ProgramCode: \(error)")
                return .panic(.invalidInstructionIndex)
            }

            // Set up the synchronous handler that will bridge to async context if invoked
            // We're capturing the invocationContext into a closure that will be called synchronously
            if let invocationContext = ctx {
                // Initialize the synchronous handler
                syncHostCallHandler = { hostCallIndex, guestRegistersPtr, guestMemoryBasePtr, guestMemorySize, guestGasPtr -> UInt32 in
                    guard let programCode = self.currentProgramCode else {
                        self.logger.error("No program code available for host call")
                        return JITHostCallError.internalErrorInvalidContext.rawValue
                    }

                    // Create a VMStateJIT adapter
                    let vmState = VMStateJIT(
                        jitMemoryBasePtr: guestMemoryBasePtr,
                        jitMemorySize: guestMemorySize,
                        jitRegistersPtr: guestRegistersPtr,
                        jitGasPtr: guestGasPtr,
                        programCode: programCode,
                        initialPC: 0 // TODO: track real PC
                    )

                    // We need to convert the async operation to sync
                    // Create a placeholder synchronization mechanism
                    let semaphore = DispatchSemaphore(value: 0)
                    var asyncResult: ExecOutcome?

                    // Kick off the async operation but wait for it to complete
                    Task {
                        asyncResult = await invocationContext.dispatch(index: hostCallIndex, state: vmState)
                        semaphore.signal()
                    }

                    // Wait for the async operation to complete
                    semaphore.wait()

                    // Process the async result and return appropriate status
                    if let result = asyncResult {
                        switch result {
                        case .continued:
                            return 0 // Success
                        case let .exit(reason):
                            switch reason {
                            case .halt:
                                return JITHostCallError.hostRequestedHalt.rawValue
                            case .outOfGas:
                                return JITHostCallError.gasExhausted.rawValue
                            case let .hostCall(nestedIndex):
                                self.logger.error("Nested host calls not supported: \(nestedIndex)")
                                return JITHostCallError.hostFunctionThrewError.rawValue
                            case let .pageFault(address):
                                self.logger.error("Page fault at address \(address)")
                                return JITHostCallError.pageFault.rawValue
                            case .panic:
                                return JITHostCallError.hostFunctionThrewError.rawValue
                            }
                        }
                    } else {
                        self.logger.error("No result from async host function call")
                        return JITHostCallError.hostFunctionThrewError.rawValue
                    }
                }
            } else {
                // Clear the handler if no context provided
                syncHostCallHandler = nil
            }

            // Update the invocation context in the JIT host function table
            jitHostFunctionTableWrapper.table.invocationContext = nil // We're using the syncHandler now

            // Get a pointer to the JITHostFunctionTableWrapper
            let invocationContextPointer = Unmanaged.passUnretained(jitHostFunctionTableWrapper).toOpaque()

            // Execute the JIT-compiled function
            // The JIT function will use our syncHostCallHandler via the C trampoline
            let exitReason = try jitExecutor.execute(
                functionPtr: compiledFuncPtr,
                registers: &registers,
                jitMemorySize: jitTotalMemorySize,
                gas: &currentGas,
                initialPC: pc,
                invocationContext: invocationContextPointer
            )

            // Clear the references after execution
            syncHostCallHandler = nil
            currentProgramCode = nil
            jitHostFunctionTableWrapper.table.invocationContext = nil

            logger.debug("JIT execution finished. Reason: \(exitReason). Remaining gas: \(currentGas.value)")
            return exitReason

        } catch let error as JITCompiler.CompilationError {
            logger.error("JIT compilation failed: \(error)")
            return .panic(.trap)
        } catch let error as JITError {
            logger.error("JIT execution failed with JITError: \(error)")
            return error.toExitReason()
        } catch {
            logger.error("JIT execution failed with an unexpected error: \(error)")
            return .panic(.trap) // Generic trap for unexpected errors
        }
    }
}

// Defines standardized error codes for JIT host function calls.
// These raw values are returned by the host call C trampoline to the JIT-compiled code.
// The JIT-compiled code must check if the returned UInt32 matches any of these error codes.
// If it does, the JIT code should treat it as a VM-level error (e.g., trigger a panic).
// Otherwise, the returned UInt32 is the successful result from the host function.
// These values are chosen to be at the high end of the UInt32 range to minimize
// collision with legitimate success values returned by host functions.

enum JITHostCallError: UInt32 {
    // Indicates an internal error within the JIT host call mechanism,
    // such as the owner context being nil.
    case internalErrorInvalidContext = 0xFFFF_FFFF

    // Indicates that no host function was found registered for the given index.
    case hostFunctionNotFound = 0xFFFF_FFFE

    // Indicates that the registered host function was called but threw a Swift error during its execution.
    case hostFunctionThrewError = 0xFFFF_FFFD

    // Indicates that the VM ran out of gas during host function execution
    case gasExhausted = 0xFFFF_FFFC

    // Indicates that a page fault occurred during host function execution
    case pageFault = 0xFFFF_FFFB

    // Indicates that the host function requested the VM to halt
    case hostRequestedHalt = 0xFFFF_FFFA
}

// Static C-callable trampoline that calls the instance method.
private func dispatchHostCall_C_Trampoline(
    opaqueOwnerContext: UnsafeMutableRawPointer?,
    hostCallIndex: UInt32,
    guestRegistersPtr: UnsafeMutablePointer<UInt64>,
    guestMemoryBasePtr: UnsafeMutablePointer<UInt8>,
    guestMemorySize: UInt32,
    guestGasPtr: UnsafeMutablePointer<UInt64>,
    invocationContextPtr: UnsafeMutableRawPointer?
) -> UInt32 {
    guard let ownerCtxPtr = opaqueOwnerContext else {
        return JITHostCallError.internalErrorInvalidContext.rawValue
    }
    let backendInstance = Unmanaged<ExecutorBackendJIT>.fromOpaque(ownerCtxPtr).takeUnretainedValue()

    // Call the instance method that handles the dispatch
    return backendInstance.dispatchHostCall(
        hostCallIndex: hostCallIndex,
        guestRegistersPtr: guestRegistersPtr,
        guestMemoryBasePtr: guestMemoryBasePtr,
        guestMemorySize: guestMemorySize,
        guestGasPtr: guestGasPtr,
        invocationContextPtr: invocationContextPtr
    )
}
