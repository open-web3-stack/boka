// generated by polka.codes
// VMState implementation for JIT execution environment

import Foundation
import TracingUtils
import Utils

/// VMStateJIT adapts the raw JIT execution environment (registers, memory pointers, etc.)
/// to conform to the VMState protocol, allowing InvocationContext.dispatch to be used
/// with JIT-compiled code.
final class VMStateJIT: VMState, @unchecked Sendable {
    private let logger = Logger(label: "VMStateJIT")

    private let jitMemoryBasePtr: UnsafeMutablePointer<UInt8>
    private let jitMemorySize: UInt32
    private let jitRegistersPtr: UnsafeMutablePointer<UInt64>
    private let jitGasPtr: UnsafeMutablePointer<UInt64>
    private let programCode: ProgramCode

    // Track current program counter
    private var pcValue: UInt32

    // Memory view instances - created lazily for efficiency
    private lazy var readonlyMemoryView: ReadonlyMemory = {
        do {
            return try createReadonlyMemoryView()
        } catch {
            logger.error("Failed to create ReadonlyMemory: \(error)")
            // Return an empty memory as a fallback - shouldn't happen in practice
            // Creating empty memory should not fail, but use try? for safety
            guard let memory = try? GeneralMemory(pageMap: [], chunks: []) else {
                fatalError("Failed to create empty GeneralMemory - this should never happen")
            }
            return ReadonlyMemory(memory)
        }
    }()

    private lazy var generalMemoryView: GeneralMemory = {
        do {
            return try createGeneralMemoryView()
        } catch {
            logger.error("Failed to create GeneralMemory: \(error)")
            // Return an empty memory as a fallback - shouldn't happen in practice
            // Creating empty memory should not fail, but use try? for safety
            guard let memory = try? GeneralMemory(pageMap: [], chunks: []) else {
                fatalError("Failed to create empty GeneralMemory - this should never happen")
            }
            return memory
        }
    }()

    init(
        jitMemoryBasePtr: UnsafeMutablePointer<UInt8>,
        jitMemorySize: UInt32,
        jitRegistersPtr: UnsafeMutablePointer<UInt64>,
        jitGasPtr: UnsafeMutablePointer<UInt64>,
        programCode: ProgramCode,
        initialPC: UInt32
    ) {
        self.jitMemoryBasePtr = jitMemoryBasePtr
        self.jitMemorySize = jitMemorySize
        self.jitRegistersPtr = jitRegistersPtr
        self.jitGasPtr = jitGasPtr
        self.programCode = programCode
        pcValue = initialPC

        logger.debug("VMStateJIT initialized with memSize: \(jitMemorySize), initialPC: \(initialPC)")
    }

    // MARK: - VMState Protocol Implementation

    var program: ProgramCode {
        programCode
    }

    var pc: UInt32 {
        pcValue
    }

    // Register Operations

    func getRegisters() -> Registers {
        var registers = Registers()

        // Copy all register values from JIT registers array
        for i in 0 ..< 13 { // There are 13 registers in Registers
            let regValue = jitRegistersPtr[Int(i)]
            registers[Registers.Index(raw: UInt8(i))] = regValue
        }

        return registers
    }

    func readRegister<T: FixedWidthInteger>(_ index: Registers.Index) -> T {
        // Read a register value from the JIT registers array
        T(truncatingIfNeeded: jitRegistersPtr[Int(index.value)])
    }

    func readRegister<T: FixedWidthInteger>(_ index: Registers.Index, _ index2: Registers.Index) -> (T, T) {
        // Read two register values from the JIT registers array
        let value1 = T(truncatingIfNeeded: jitRegistersPtr[Int(index.value)])
        let value2 = T(truncatingIfNeeded: jitRegistersPtr[Int(index2.value)])
        return (value1, value2)
    }

    func readRegisters<T: FixedWidthInteger>(in range: Range<UInt8>) -> [T] {
        // Read register values in the specified range
        range.map { T(truncatingIfNeeded: jitRegistersPtr[Int($0)]) }
    }

    func writeRegister(_ index: Registers.Index, _ value: some FixedWidthInteger) {
        // Write a value to a JIT register
        jitRegistersPtr[Int(index.value)] = UInt64(truncatingIfNeeded: value)
    }

    // Memory Operations

    func getMemory() -> ReadonlyMemory {
        readonlyMemoryView
    }

    func getMemoryUnsafe() -> GeneralMemory {
        generalMemoryView
    }

    // Create a memory view that directly accesses the JIT-managed memory
    private func createReadonlyMemoryView() throws -> ReadonlyMemory {
        try ReadonlyMemory(createGeneralMemoryView())
    }

    private func createGeneralMemoryView() throws -> GeneralMemory {
        // Create a single page map entry covering the entire memory range
        let pageMap: [(address: UInt32, length: UInt32, writable: Bool)] = [(0, jitMemorySize, true)]

        // Create direct chunk access to the memory buffer
        // We create a Data view of the memory for GeneralMemory
        let memoryData = Data(bytes: jitMemoryBasePtr, count: Int(jitMemorySize))

        // Create a GeneralMemory instance with the page map and data chunks
        return try GeneralMemory(
            pageMap: pageMap,
            chunks: [(0, memoryData)]
        )
    }

    func isMemoryReadable(address: some FixedWidthInteger, length: Int) -> Bool {
        // Check if the memory range is valid for reading
        let addr = UInt32(truncatingIfNeeded: address)
        return addr + UInt32(length) <= jitMemorySize
    }

    func isMemoryWritable(address: some FixedWidthInteger, length: Int) -> Bool {
        // Check if the memory range is valid for writing
        let addr = UInt32(truncatingIfNeeded: address)
        return addr + UInt32(length) <= jitMemorySize
    }

    func readMemory(address: some FixedWidthInteger) throws -> UInt8 {
        // Read a byte from JIT memory
        let addr = UInt32(truncatingIfNeeded: address)
        guard isMemoryReadable(address: addr, length: 1) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        return jitMemoryBasePtr[Int(addr)]
    }

    func readMemory(address: some FixedWidthInteger, length: Int) throws -> Data {
        // Read multiple bytes from JIT memory into a Data object
        let addr = UInt32(truncatingIfNeeded: address)
        guard isMemoryReadable(address: addr, length: length) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        return Data(bytes: jitMemoryBasePtr.advanced(by: Int(addr)), count: length)
    }

    func writeMemory(address: some FixedWidthInteger, value: UInt8) throws {
        // Write a byte to JIT memory
        let addr = UInt32(truncatingIfNeeded: address)
        guard isMemoryWritable(address: addr, length: 1) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        jitMemoryBasePtr[Int(addr)] = value
    }

    func writeMemory(address: some FixedWidthInteger, values: some Sequence<UInt8>) throws {
        // Write multiple bytes to JIT memory
        let addr = UInt32(truncatingIfNeeded: address)
        let valueArray = Array(values)
        guard isMemoryWritable(address: addr, length: valueArray.count) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        for (offset, value) in valueArray.enumerated() {
            jitMemoryBasePtr[Int(addr) + offset] = value
        }
    }

    func writeMemory(address: some FixedWidthInteger, values: Data) throws {
        let addr = UInt32(truncatingIfNeeded: address)
        guard isMemoryWritable(address: addr, length: values.count) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        values.withUnsafeBytes { bytes in
            let sourcePtr = bytes.bindMemory(to: UInt8.self).baseAddress!
            memcpy(jitMemoryBasePtr.advanced(by: Int(addr)), sourcePtr, values.count)
        }
    }

    func sbrk(_: UInt32) throws -> UInt32 {
        // In JIT mode, memory allocation would need to be handled by the JIT runtime
        // This would require coordination with the memory sandbox mechanism
        // TODO: Implement proper memory allocation that works with JIT sandbox
        logger.error("sbrk not implemented in JIT mode")
        throw VMError.invalidInstructionMemoryAccess
    }

    // VM State Control

    func getGas() -> GasInt {
        // Get the current gas value from the JIT gas pointer
        GasInt(jitGasPtr.pointee)
    }

    func consumeGas(_ amount: Gas) {
        // Deduct gas from the JIT gas counter
        jitGasPtr.pointee -= amount.value
    }

    func increasePC(_ amount: UInt32) {
        // Increment the PC by the specified amount
        pcValue += amount
    }

    func updatePC(_ newPC: UInt32) {
        // Set the PC to the specified value
        pcValue = newPC
    }

    // Execution Control

    func withExecutingInst<R>(_ block: () throws -> R) rethrows -> R {
        // In JIT mode, most execution happens in compiled code
        // This is mainly for compatibility with the VMState protocol
        try block()
    }
}
