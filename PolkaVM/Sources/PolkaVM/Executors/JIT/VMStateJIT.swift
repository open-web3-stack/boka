// generated by polka.codes
// VMState implementation for JIT execution environment

import Foundation
import TracingUtils
import Utils

/// VMStateJIT adapts the raw JIT execution environment (registers, memory pointers, etc.)
/// to conform to the VMState protocol, allowing InvocationContext.dispatch to be used
/// with JIT-compiled code.
final class VMStateJIT: VMState, @unchecked Sendable {
    private let logger = Logger(label: "VMStateJIT")

    private let jitMemoryBasePtr: UnsafeMutablePointer<UInt8>
    private let jitMemorySize: UInt32
    private let jitRegistersPtr: UnsafeMutablePointer<UInt64>
    private let jitGasPtr: UnsafeMutablePointer<UInt64>
    private let programCode: ProgramCode

    private var pcValue: UInt32

    init(
        jitMemoryBasePtr: UnsafeMutablePointer<UInt8>,
        jitMemorySize: UInt32,
        jitRegistersPtr: UnsafeMutablePointer<UInt64>,
        jitGasPtr: UnsafeMutablePointer<UInt64>,
        programCode: ProgramCode,
        initialPC: UInt32
    ) {
        self.jitMemoryBasePtr = jitMemoryBasePtr
        self.jitMemorySize = jitMemorySize
        self.jitRegistersPtr = jitRegistersPtr
        self.jitGasPtr = jitGasPtr
        self.programCode = programCode
        pcValue = initialPC
    }

    // MARK: - VMState Protocol Implementation

    var program: ProgramCode {
        programCode
    }

    var pc: UInt32 {
        pcValue
    }

    // Register Operations

    func getRegisters() -> Registers {
        let registers = Registers()
        // TODO: Properly copy all registers from JIT memory
        return registers
    }

    func readRegister<T: FixedWidthInteger>(_ index: Registers.Index) -> T {
        // Read a register value from the JIT registers array
        T(truncatingIfNeeded: jitRegistersPtr[Int(index.value)])
    }

    func readRegister<T: FixedWidthInteger>(_ index: Registers.Index, _ index2: Registers.Index) -> (T, T) {
        // Read two register values from the JIT registers array
        let value1 = T(truncatingIfNeeded: jitRegistersPtr[Int(index.value)])
        let value2 = T(truncatingIfNeeded: jitRegistersPtr[Int(index2.value)])
        return (value1, value2)
    }

    func readRegisters<T: FixedWidthInteger>(in range: Range<UInt8>) -> [T] {
        // Read register values in the specified range
        range.map { T(truncatingIfNeeded: jitRegistersPtr[Int($0)]) }
    }

    func writeRegister(_ index: Registers.Index, _ value: some FixedWidthInteger) {
        // Write a value to a JIT register
        jitRegistersPtr[Int(index.value)] = UInt64(truncatingIfNeeded: value)
    }

    // Memory Operations

    func getMemory() -> ReadonlyMemory {
        // Create a read-only view of the JIT memory
        // TODO: Implement proper ReadonlyMemory wrapper around JIT memory
        let pageMap: [(address: UInt32, length: UInt32, writable: Bool)] = [(0, jitMemorySize, true)]
        let chunks: [(address: UInt32, data: Data)] = []
        do {
            return try ReadonlyMemory(GeneralMemory(pageMap: pageMap, chunks: chunks))
        } catch {
            logger.error("Failed to create ReadonlyMemory: \(error)")
            // Return an empty memory as a fallback
            return ReadonlyMemory(try! GeneralMemory(pageMap: [], chunks: []))
        }
    }

    func getMemoryUnsafe() -> GeneralMemory {
        // Create a GeneralMemory wrapper around the JIT memory
        // TODO: Implement proper GeneralMemory wrapper around JIT memory
        let pageMap: [(address: UInt32, length: UInt32, writable: Bool)] = [(0, jitMemorySize, true)]
        let chunks: [(address: UInt32, data: Data)] = []
        do {
            return try GeneralMemory(pageMap: pageMap, chunks: chunks)
        } catch {
            logger.error("Failed to create GeneralMemory: \(error)")
            // Return an empty memory as a fallback
            return try! GeneralMemory(pageMap: [], chunks: [])
        }
    }

    func isMemoryReadable(address: some FixedWidthInteger, length: Int) -> Bool {
        // Check if the memory range is valid for reading
        let addr = UInt32(truncatingIfNeeded: address)
        return addr + UInt32(length) <= jitMemorySize
    }

    func isMemoryWritable(address: some FixedWidthInteger, length: Int) -> Bool {
        // Check if the memory range is valid for writing
        let addr = UInt32(truncatingIfNeeded: address)
        return addr + UInt32(length) <= jitMemorySize
    }

    func readMemory(address: some FixedWidthInteger) throws -> UInt8 {
        // Read a byte from JIT memory
        let addr = UInt32(truncatingIfNeeded: address)
        guard isMemoryReadable(address: addr, length: 1) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        return jitMemoryBasePtr[Int(addr)]
    }

    func readMemory(address: some FixedWidthInteger, length: Int) throws -> Data {
        // Read multiple bytes from JIT memory into a Data object
        let addr = UInt32(truncatingIfNeeded: address)
        guard isMemoryReadable(address: addr, length: length) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        return Data(bytes: jitMemoryBasePtr.advanced(by: Int(addr)), count: length)
    }

    func writeMemory(address: some FixedWidthInteger, value: UInt8) throws {
        // Write a byte to JIT memory
        let addr = UInt32(truncatingIfNeeded: address)
        guard isMemoryWritable(address: addr, length: 1) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        jitMemoryBasePtr[Int(addr)] = value
    }

    func writeMemory(address: some FixedWidthInteger, values: some Sequence<UInt8>) throws {
        // Write multiple bytes to JIT memory
        let addr = UInt32(truncatingIfNeeded: address)
        let valueArray = Array(values)
        guard isMemoryWritable(address: addr, length: valueArray.count) else {
            throw VMError.invalidInstructionMemoryAccess
        }
        for (offset, value) in valueArray.enumerated() {
            jitMemoryBasePtr[Int(addr) + offset] = value
        }
    }

    func sbrk(_: UInt32) throws -> UInt32 {
        // TODO: Implement memory allocation
        // For now, throw an error as this is not directly supported
        throw VMError.invalidInstructionMemoryAccess
    }

    // VM State Control

    func getGas() -> GasInt {
        // Get the current gas value from the JIT gas pointer
        GasInt(jitGasPtr.pointee)
    }

    func consumeGas(_ amount: Gas) {
        // Deduct gas from the JIT gas counter
        jitGasPtr.pointee -= amount.value
    }

    func increasePC(_ amount: UInt32) {
        // Increment the PC by the specified amount
        pcValue += amount
    }

    func updatePC(_ newPC: UInt32) {
        // Set the PC to the specified value
        pcValue = newPC
    }

    // Execution Control

    func withExecutingInst<R>(_ block: () throws -> R) rethrows -> R {
        // Execute the block
        try block()
    }
}
