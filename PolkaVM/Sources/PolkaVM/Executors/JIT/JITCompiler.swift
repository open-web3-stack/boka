// generated by polka.codes
// JIT compiler for PolkaVM

import CppHelper
import Foundation
import TracingUtils
import Utils

/// JIT compiler for PolkaVM
final class JITCompiler {
    private let logger = Logger(label: "JITCompiler")

    // Errors that can occur during JIT compilation
    enum CompilationError: Error, Equatable {
        case invalidBlob
        case compilationFailed(Int32)
        case unsupportedArchitecture
        case allocationFailed
        case exportFailed(Int32)
        case metadataStorageFailed(Int32)

        // Equatable conformance
        static func == (lhs: CompilationError, rhs: CompilationError) -> Bool {
            switch (lhs, rhs) {
            case (.invalidBlob, .invalidBlob),
                 (.unsupportedArchitecture, .unsupportedArchitecture),
                 (.allocationFailed, .allocationFailed):
                true
            case let (.compilationFailed(lhsCode), .compilationFailed(rhsCode)):
                lhsCode == rhsCode
            case let (.exportFailed(lhsCode), .exportFailed(rhsCode)):
                lhsCode == rhsCode
            case let (.metadataStorageFailed(lhsCode), .metadataStorageFailed(rhsCode)):
                lhsCode == rhsCode
            default:
                false
            }
        }
    }

    /// Compile VM code into executable machine code
    /// - Parameters:
    ///   - blob: The program code blob
    ///   - initialPC: The initial program counter
    ///   - config _: The VM configuration
    ///   - targetArchitecture: The target architecture
    ///   - jitMemorySize: The total memory size for JIT operations
    ///   - skipTable: Instruction skip values from ProgramCode.skip(pc) for variable-length encoding
    ///   - bitmask: Instruction boundary bitmask from ProgramCode.bitmask
    /// - Returns: Pointer to the compiled function
    func compile(
        blob: Data,
        initialPC: UInt32,
        config _: PvmConfig,
        targetArchitecture: JITPlatform,
        jitMemorySize: UInt32,
        skipTable: [UInt32], // NEW: skip table for variable-length instructions
        bitmask: Data // NEW: bitmask for instruction boundary validation
    ) throws -> UnsafeMutableRawPointer {
        logger.debug("Starting JIT compilation. Blob size: \(blob.count), Initial PC: \(initialPC), Target: \(targetArchitecture)")

        // Check if blob is valid
        guard !blob.isEmpty else {
            logger.error("Invalid empty code blob")
            throw CompilationError.invalidBlob
        }

        // Buffer for the output function pointer
        var compiledFuncPtr: UnsafeMutableRawPointer?

        var resultCode: Int32 = 0

        // Get base pointer from blob
        let maybeBasePointer = blob.withUnsafeBytes { bufferPtr in
            bufferPtr.baseAddress?.assumingMemoryBound(to: UInt8.self)
        }

        // Ensure we have a valid base pointer
        guard let basePointer = maybeBasePointer else {
            logger.error("Failed to get base address of buffer")
            throw CompilationError.invalidBlob
        }

        // Compile based on architecture
        // Using label-based compilation for maximum performance
        // This enables proper control flow (branches, loops) with direct jumps
        switch targetArchitecture {
        case .x86_64:
            logger.debug("Compiling for x86_64 architecture (labeled compilation)")
            try bitmask.withUnsafeBytes { bitmaskPtr in
                guard let bitmaskBytes = bitmaskPtr.baseAddress?.assumingMemoryBound(to: UInt8.self) else {
                    throw CompilationError.invalidBlob
                }
                resultCode = compilePolkaVMCode_x64_labeled(
                    basePointer,
                    blob.count,
                    initialPC,
                    jitMemorySize,
                    skipTable,
                    skipTable.count,
                    bitmaskBytes, bitmask.count,
                    &compiledFuncPtr
                )
            }

        case .arm64:
            logger.debug("Compiling for Arm64 architecture (labeled compilation)")
            try bitmask.withUnsafeBytes { bitmaskPtr in
                guard let bitmaskBytes = bitmaskPtr.baseAddress?.assumingMemoryBound(to: UInt8.self) else {
                    throw CompilationError.invalidBlob
                }
                resultCode = compilePolkaVMCode_a64_labeled(
                    basePointer,
                    blob.count,
                    initialPC,
                    jitMemorySize,
                    skipTable,
                    skipTable.count,
                    bitmaskBytes, bitmask.count,
                    &compiledFuncPtr
                )
            }
        }

        // Check compilation result
        if resultCode != 0 {
            logger.error("JIT compilation failed with code: \(resultCode)")
            throw CompilationError.compilationFailed(resultCode)
        }

        // Ensure we have a valid function pointer
        guard let funcPtr = compiledFuncPtr else {
            logger.error("Failed to obtain compiled function pointer")
            throw CompilationError.allocationFailed
        }

        logger.debug("JIT compilation successful. Function pointer: \(funcPtr)")

        // TODO: Implement code caching mechanism to avoid recompiling the same code
        // TODO: Add memory management for JIT code (evict old code when memory pressure is high)

        return funcPtr
    }
}

// MARK: - Export/Import API for Persistent Caching

extension JITCompiler {
    /// Compiled code information for export
    public struct CompiledCodeInfo {
        public let functionPtr: UnsafeRawPointer
        public let dispatcherTable: UnsafeMutablePointer<UnsafeMutableRawPointer?>?
        public let dispatcherTableSize: Int
        public let hasDispatcherTable: Bool

        public init(
            functionPtr: UnsafeRawPointer,
            dispatcherTable: UnsafeMutablePointer<UnsafeMutableRawPointer?>?,
            dispatcherTableSize: Int,
            hasDispatcherTable: Bool
        ) {
            self.functionPtr = functionPtr
            self.dispatcherTable = dispatcherTable
            self.dispatcherTableSize = dispatcherTableSize
            self.hasDispatcherTable = hasDispatcherTable
        }
    }

    /// Get compiled code information
    /// Retrieves metadata about compiled code needed for caching
    ///
    /// - Parameter functionPtr: Compiled function pointer
    /// - Returns: CompiledCodeInfo containing metadata
    /// - Throws: CompilationError if info cannot be retrieved
    public static func getCompiledCodeInfo(
        functionPtr: UnsafeRawPointer
    ) throws -> CompiledCodeInfo {
        var dispatcherTable: UnsafeMutablePointer<UnsafeMutableRawPointer?>?
        var dispatcherTableSize: size_t = 0
        var hasDispatcherTable: Int32 = 0

        let result = CppHelper.getCompiledCodeInfo(
            UnsafeMutableRawPointer(mutating: functionPtr),
            &dispatcherTable,
            &dispatcherTableSize,
            &hasDispatcherTable
        )

        guard result == 0 else {
            throw CompilationError.exportFailed(result)
        }

        return CompiledCodeInfo(
            functionPtr: functionPtr,
            dispatcherTable: dispatcherTable,
            dispatcherTableSize: Int(dispatcherTableSize),
            hasDispatcherTable: hasDispatcherTable != 0
        )
    }

    /// Store compiled code metadata
    /// Associates bytecode hash with compiled function for cache lookup
    ///
    /// - Parameters:
    ///   - bytecodeHash: Hash of the bytecode (for cache key)
    ///   - functionPtr: Compiled function pointer
    ///   - codeSize: Size of compiled code
    /// - Throws: CompilationError if metadata cannot be stored
    public static func setCompiledCodeMetadata(
        bytecodeHash: UInt64,
        functionPtr: UnsafeRawPointer,
        codeSize: Int
    ) throws {
        let result = CppHelper.setCompiledCodeMetadata(
            bytecodeHash,
            UnsafeMutableRawPointer(mutating: functionPtr),
            size_t(codeSize)
        )

        guard result == 0 else {
            throw CompilationError.metadataStorageFailed(result)
        }
    }

    // NOTE: Full export/import of compiled machine code requires deeper AsmJit integration
    // This is a placeholder for future implementation
    // For now, users can:
    // 1. Store bytecode hash -> function pointer mapping
    // 2. Serialize bytecode to disk
    // 3. Load bytecode and recompile on next run
    //
    // This provides most of the caching benefit (avoiding recompilation)
    // while avoiding the complexity of serializing machine code
}
