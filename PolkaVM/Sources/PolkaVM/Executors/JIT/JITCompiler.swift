// generated by polka.codes
// JIT compilation logic interfacing with CppHelper

import CppHelper
import Foundation
import TracingUtils
import Utils

// TODO: Add optimization level support in PvmConfig
// TODO: Implement proper error mapping from C++ error codes
// TODO: Add instruction-specific compilation strategies based on interpreter profiling data
// TODO: Implement memory access pattern optimizations based on interpreter memory usage

// Type alias for the C ABI of JIT-compiled functions.
// This signature is platform-agnostic from the Swift side.
typealias JITFunctionSignature = @convention(c) (
    _ registers: UnsafeMutablePointer<UInt64>, // PVM_REGISTER_COUNT elements
    _ memoryBase: UnsafeMutablePointer<UInt8>, // Start of the JIT's flat memory buffer
    _ memorySize: UInt32, // Size of the flat memory buffer
    _ gas: UnsafeMutablePointer<UInt64>, // Pointer to current gas value
    _ initialPC: UInt32, // Entry point for this JITed block
    _ invocationContext: UnsafeMutableRawPointer? // Opaque pointer for syscalls/host functions
) -> Int32 // Raw value of ExitReason

final class JITCompiler {
    private let logger = Logger(label: "JITCompiler")
    // private let cppHelper: CppHelper // Removed

    init() { // cppHelper parameter removed
        // self.cppHelper = cppHelper // Removed
        logger.info("JITCompiler initialized.")
    }

    // TODO: Update CppHelper interface to support optimization levels
    // TODO: Add support for passing PvmConfig settings to C++ compiler
    // TODO: Implement proper nullability annotations in C++ interface (_Nullable/_Nonnull)
    // TODO: Add support for instruction-specific optimizations (e.g., specialized handlers for hot instructions)
    // TODO: Implement branch prediction hints based on interpreter execution patterns
    // TODO: Add support for memory access pattern optimizations (prefetching, alignment)
    // TODO: Ensure gas accounting in JIT-compiled code matches interpreter exactly for each instruction type
    func compile(
        blob: Data,
        initialPC: UInt32,
        config _: PvmConfig, // Used for JIT options like optimization level
        targetArchitecture: String,
        jitMemorySize: UInt32 // Passed to C++ for context, e.g., memory sandboxing setup
    ) throws -> UnsafeMutableRawPointer {
        logger.debug("""
        Starting JIT compilation:
          Code size: \(blob.count) bytes
          Initial PC: \(initialPC)
          Target Arch: \(targetArchitecture)
          JIT Memory Size (for context): \(jitMemorySize / (1024 * 1024))MB
        """)

        var funcOut: UnsafeMutableRawPointer? = nil
        let compileResult: Int32 = try blob.withUnsafeBytes { rawBufferPointer -> Int32 in
            guard let baseAddress = rawBufferPointer.baseAddress else {
                logger.error("Failed to get base address of blob data for JIT compilation.")
                throw JITError.failedToGetBlobBaseAddress
            }
            let uint8Ptr = baseAddress.assumingMemoryBound(to: UInt8.self)

            logger.debug("""
            Calling CppHelper compile function for arch: \(targetArchitecture) with:
              blob.count: \(blob.count)
              initialPC: \(initialPC)
              jitMemorySize: \(jitMemorySize)
            """)

            // Call the appropriate C function based on targetArchitecture
            if targetArchitecture.contains("aarch64") || targetArchitecture.contains("arm64") {
                return compilePolkaVMCode_a64(
                    uint8Ptr,
                    blob.count,
                    initialPC,
                    jitMemorySize,
                    &funcOut
                )
            } else if targetArchitecture.contains("x86_64") || targetArchitecture.contains("amd64") {
                return compilePolkaVMCode_x64(
                    uint8Ptr,
                    blob.count,
                    initialPC,
                    jitMemorySize,
                    &funcOut
                )
            } else {
                logger.error("Unsupported target architecture for JIT compilation: \(targetArchitecture)")
                throw JITError.targetArchUnsupported(arch: targetArchitecture)
            }
        }

        if compileResult == 0, let validFuncOut = funcOut {
            logger.info("C++ JIT compilation succeeded. Function pointer: \(validFuncOut)")
            return validFuncOut
        } else {
            let errorDetails = "C++ JIT compilation failed with result code: \(compileResult)."
            logger.error("\(errorDetails) Function pointer: \(String(describing: funcOut))")
            // TODO: Map C++ error codes (compileResult) to more descriptive JITError cases.
            // For now, using a generic JITError.compilationFailed or a new CppHelperError.
            throw JITError.cppHelperError(code: compileResult, details: "Compilation failed for \(targetArchitecture)")
        }
    }
}
