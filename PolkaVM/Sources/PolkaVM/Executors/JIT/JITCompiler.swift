// generated by polka.codes
// This file implements the JIT compilation logic, interfacing with CppHelper.

import CppHelper // Assuming CppHelper is a module or accessible type
import Foundation
import TracingUtils
import Utils // For Logger

// TODO: Ensure PvmConfig is accessible.

// Type alias for the C ABI of JIT-compiled functions.
// This signature is platform-agnostic from the Swift side.
typealias JITFunctionSignature = @convention(c) (
    _ registers: UnsafeMutablePointer<UInt64>, // PVM_REGISTER_COUNT elements
    _ memoryBase: UnsafeMutablePointer<UInt8>, // Start of the JIT's flat memory buffer
    _ memorySize: UInt32, // Size of the flat memory buffer
    _ gas: UnsafeMutablePointer<UInt64>, // Pointer to current gas value
    _ initialPC: UInt32, // Entry point for this JITed block
    _ invocationContext: UnsafeMutableRawPointer? // Opaque pointer for syscalls/host functions
) -> Int32 // Raw value of ExitReason

final class JITCompiler {
    private let logger = Logger(label: "JITCompiler")
    // private let cppHelper: CppHelper // Removed

    init() { // cppHelper parameter removed
        // self.cppHelper = cppHelper // Removed
        logger.info("JITCompiler initialized.")
    }

    // TODO: Update CppHelper.compilePolkaVMCode signature in CppHelper.hh and CppHelper.cpp
    // Expected C++ signature might be:
    // int32_t compilePolkaVMCode(
    //     const uint8_t* code,
    //     size_t codeSize,
    //     uint32_t initialPC,
    //     const char* targetArch, // e.g., "aarch64-apple-darwin"
    //     uint32_t jitMemorySize, // For memory sandboxing context
    //     // const CppPvmConfig* pvmConfig, // Pass relevant parts of PvmConfig (TODO)
    //     // int optimizationLevel, // TODO
    //     void** ppFuncOut // Output for the function pointer
    // );
    func compile(
        blob: Data,
        initialPC: UInt32,
        config _: PvmConfig, // Used for JIT options like optimization level
        targetArchitecture: String,
        jitMemorySize: UInt32 // Passed to C++ for context, e.g., memory sandboxing setup
    ) throws -> UnsafeMutableRawPointer {
        logger.debug("""
        Starting JIT compilation:
          Code size: \(blob.count) bytes
          Initial PC: \(initialPC)
          Target Arch: \(targetArchitecture)
          JIT Memory Size (for context): \(jitMemorySize / (1024 * 1024))MB
        """)

        var funcOut: UnsafeMutableRawPointer? = nil
        let compileResult: Int32 = try blob.withUnsafeBytes { rawBufferPointer -> Int32 in
            guard let baseAddress = rawBufferPointer.baseAddress else {
                logger.error("Failed to get base address of blob data for JIT compilation.")
                throw JITError.failedToGetBlobBaseAddress
            }
            let uint8Ptr = baseAddress.assumingMemoryBound(to: UInt8.self)

            logger.debug("""
            Calling CppHelper compile function for arch: \(targetArchitecture) with:
              blob.count: \(blob.count)
              initialPC: \(initialPC)
              jitMemorySize: \(jitMemorySize)
            """)

            // Call the appropriate C function based on targetArchitecture
            if targetArchitecture.contains("aarch64") || targetArchitecture.contains("arm64") {
                return compilePolkaVMCode_a64(
                    uint8Ptr,
                    blob.count,
                    initialPC,
                    jitMemorySize,
                    &funcOut
                )
            } else if targetArchitecture.contains("x86_64") || targetArchitecture.contains("amd64") {
                return compilePolkaVMCode_x64(
                    uint8Ptr,
                    blob.count,
                    initialPC,
                    jitMemorySize,
                    &funcOut
                )
            } else {
                logger.error("Unsupported target architecture for JIT compilation: \(targetArchitecture)")
                throw JITError.targetArchUnsupported(arch: targetArchitecture)
            }
        }

        if compileResult == 0, let validFuncOut = funcOut {
            logger.info("C++ JIT compilation succeeded. Function pointer: \(validFuncOut)")
            return validFuncOut
        } else {
            let errorDetails = "C++ JIT compilation failed with result code: \(compileResult)."
            logger.error("\(errorDetails) Function pointer: \(String(describing: funcOut))")
            // TODO: Map C++ error codes (compileResult) to more descriptive JITError cases.
            // For now, using a generic JITError.compilationFailed or a new CppHelperError.
            throw JITError.cppHelperError(code: compileResult, details: "Compilation failed for \(targetArchitecture)")
        }
    }
}
