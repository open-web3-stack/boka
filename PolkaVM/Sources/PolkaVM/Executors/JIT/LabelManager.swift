// generated by polka.codes
// Label and fixup management for PVM JIT compiler

import Foundation
import TracingUtils

/// Manages labels and fixups for jump targets during JIT compilation
///
/// This is a simplified version that works without direct AsmJit dependencies.
/// The actual AsmJit labels will be managed in the C++ layer.
final class LabelManager {
    private let logger = Logger(label: "LabelManager")
    private var pcToLabelId: [UInt32: UInt32] = [:]
    private var definedLabels: Set<UInt32> = []
    private var nextLabelId: UInt32 = 0
    private var pendingFixups: [(pc: UInt32, targetLabelId: UInt32, offset: UInt32)] = []

    /// Creates a new label manager
    init() {
        // logger.debug("LabelManager initialized")  // Temporarily disabled
    }

    /// Gets or creates a label ID for the given program counter
    /// - Parameter pc: Program counter
    /// - Returns: The label ID for this PC
    func getOrCreateLabelId(for pc: UInt32) -> UInt32 {
        if let existing = pcToLabelId[pc] {
            return existing
        }

        let labelId = nextLabelId
        nextLabelId += 1
        pcToLabelId[pc] = labelId
        // logger.debug("Created label \(labelId) for PC 0x\(String(pc, radix: 16))")  // Temporarily disabled
        return labelId
    }

    /// Marks a label as defined at the current position
    /// - Parameter labelId: The label ID to mark as defined
    func defineLabel(_ labelId: UInt32) {
        if !definedLabels.contains(labelId) {
            definedLabels.insert(labelId)
            // logger.debug("Defined label \(labelId)")  // Temporarily disabled
        }
    }

    /// Gets a label ID for a PC if it exists
    /// - Parameter pc: Program counter
    /// - Returns: The label ID if it exists, nil otherwise
    func getLabelId(for pc: UInt32) -> UInt32? {
        pcToLabelId[pc]
    }

    /// Checks if a label has been defined
    /// - Parameter labelId: The label ID to check
    /// - Returns: True if the label is defined
    func isLabelDefined(_ labelId: UInt32) -> Bool {
        definedLabels.contains(labelId)
    }

    /// Adds a pending fixup for a forward jump
    /// - Parameters:
    ///   - pc: The program counter of the jump instruction
    ///   - targetLabelId: The target label ID (may not be defined yet)
    ///   - offset: The offset in the code where the fixup should be applied
    func addFixup(pc: UInt32, targetLabelId: UInt32, offset: UInt32) {
        pendingFixups.append((pc, targetLabelId, offset))
        // logger.debug("Added fixup for PC 0x\(String(pc, radix: 16)) to label \(targetLabelId)")  // Temporarily disabled
    }

    /// Gets all pending fixups
    /// - Returns: Array of pending fixups
    func getPendingFixups() -> [(pc: UInt32, targetLabelId: UInt32, offset: UInt32)] {
        pendingFixups
    }

    /// Clears pending fixups after they've been resolved
    func clearPendingFixups() {
        pendingFixups.removeAll()
        // logger.debug("Cleared \(pendingFixups.count) fixups")  // Temporarily disabled
    }

    /// Gets the total number of labels
    var count: Int {
        pcToLabelId.count
    }
}
