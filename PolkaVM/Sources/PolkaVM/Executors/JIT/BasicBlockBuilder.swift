// generated by polka.codes
// Basic block builder for PVM JIT compiler

import Foundation
import TracingUtils

/// Builds basic blocks from PVM bytecode for JIT compilation
///
/// Uses existing `BASIC_BLOCK_INSTRUCTIONS` set from Instructions.swift
/// to identify block boundaries.
final class BasicBlockBuilder {
    private let logger = Logger(label: "BasicBlockBuilder")
    private let program: ProgramCode

    /// Represents a basic block in the PVM program
    struct BasicBlock {
        let startPC: UInt32
        var instructions: [(opcode: UInt8, data: Data)] = []
        var isJumpTarget = false
        var gasCost: UInt64 = 0
    }

    init(program: ProgramCode) {
        self.program = program
    }

    /// Builds basic blocks from the program
    /// - Returns: Dictionary mapping PC to BasicBlock
    func build() -> [UInt32: BasicBlock] {
        // logger.debug("Building basic blocks for program")  // Temporarily disabled

        var blocks: [UInt32: BasicBlock] = [:]
        var currentBlock: BasicBlock?
        var currentPC = 0

        // Track which PCs are jump targets (will be filled in second pass)
        // TODO: Implement jump target parsing from instruction data
        // var jumpTargets: Set<UInt32> = []

        // Get basic block ending instructions - cache opcodes as constants to avoid C++ layer access
        // TODO: Import BASIC_BLOCK_INSTRUCTIONS from Instructions.swift properly
        let blockEndingOpcodes: Set<UInt8> = [0, 4, 5, 6, 80, 81, 82, 83]
        // 0: Trap, 4: Jump, 5: JumpInd, 6: LoadImmJump, 80: BranchEqImm, 81: BranchNeImm, 82: BranchEq, 83: BranchNe

        // First pass: identify all blocks and their instructions
        while currentPC < program.code.count {
            let opcode = program.code[relative: currentPC]

            // Start a new block if needed
            if currentBlock == nil {
                currentBlock = BasicBlock(startPC: UInt32(currentPC))
                blocks[UInt32(currentPC)] = currentBlock!
            }

            // Get instruction length using C++ implementation
            let instructionLength = getInstructionLength(opcode: opcode, at: currentPC, in: program)

            // Read instruction data
            let endPC = min(currentPC + instructionLength, program.code.count)
            let instructionData = Data(program.code[relative: currentPC ..< endPC])
            currentBlock!.instructions.append((opcode, instructionData))

            // Check if this ends a basic block
            if blockEndingOpcodes.contains(opcode) {
                // Finalize current block
                blocks[currentBlock!.startPC] = currentBlock!
                currentBlock = nil

                // If this is a branch, record the target as a jump target
                if opcode >= 80, opcode <= 90 {
                    // BranchImm instructions - target is encoded in instruction
                    // For now, we'll mark all subsequent PCs as potential targets
                    // TODO: Parse branch target from instruction data
                }
            }

            currentPC += instructionLength
        }

        // Finalize last block if exists
        if let block = currentBlock {
            blocks[block.startPC] = block
        }

        // Second pass: mark jump targets
        for (_, block) in blocks {
            for (opcode, _) in block.instructions {
                if opcode == 80 || // BranchEqImm
                    opcode == 81 || // BranchNeImm
                    opcode == 4 || // Jump
                    opcode == 6
                { // LoadImmJump
                    // TODO: Parse target offset and mark as jump target
                    // For now, skip this as we need to implement instruction parsing
                }
            }
        }

        // logger.debug("Built \(blocks.count) basic blocks")  // Temporarily disabled
        return blocks
    }

    /// Gets the length of an instruction in bytes
    /// - Parameter opcode: The instruction opcode
    /// - Returns: Instruction length in bytes
    private func getInstructionLength(opcode: UInt8, at pc: Int, in program: ProgramCode) -> Int {
        // Simplified instruction length calculation
        // TODO: Use proper instruction parsing from ProgramCode or C++ layer
        //
        // NOTE: This is a simplified implementation that may be incorrect for
        // multi-byte instructions. For accurate size detection, use the C++
        // get_instruction_size() function. This implementation is only suitable
        // for basic testing and analysis of simple programs.

        // Argless instructions (1 byte) - use hardcoded opcodes to avoid C++ access
        // 0: Trap, 1: Fallthrough
        let argless: Set<UInt8> = [0, 1]

        // Immediate instructions (variable length)
        // For now, return a conservative estimate
        if argless.contains(opcode) {
            return 1
        }

        // Most instructions are 3-10 bytes (1 opcode + args)
        // Return a conservative estimate that's safer than the old 5-byte default
        // For production use, proper instruction decoding is required
        return 3  // Conservative estimate for register-to-register instructions
    }
}
