// generated by polka.codes
// Basic block builder for PVM JIT compiler

import Foundation
import TracingUtils

/// Builds basic blocks from PVM bytecode for JIT compilation
///
/// Uses existing `BASIC_BLOCK_INSTRUCTIONS` set from Instructions.swift
/// to identify block boundaries.
final class BasicBlockBuilder {
    private let logger = Logger(label: "BasicBlockBuilder")
    private let program: ProgramCode

    /// Represents a basic block in the PVM program
    struct BasicBlock {
        let startPC: UInt32
        var instructions: [(opcode: UInt8, data: Data)] = []
        var isJumpTarget = false
        var gasCost: UInt64 = 0
    }

    init(program: ProgramCode) {
        self.program = program
    }

    /// Builds basic blocks from the program
    /// - Returns: Dictionary mapping PC to BasicBlock
    func build() -> [UInt32: BasicBlock] {
        // logger.debug("Building basic blocks for program")  // Temporarily disabled

        var blocks: [UInt32: BasicBlock] = [:]
        var currentBlock: BasicBlock?
        var currentPC = 0

        // Track which PCs are jump targets (will be filled in second pass)
        // TODO: Implement jump target parsing from instruction data
        // var jumpTargets: Set<UInt32> = []

        // Get basic block ending instructions - cache opcodes as constants to avoid C++ layer access
        // TODO: Import BASIC_BLOCK_INSTRUCTIONS from Instructions.swift properly
        // Block-ending opcodes matching instruction_dispatcher.cpp implementation
        // NOTE: Halt/Fallthrough (opcode 1) is NOT included - it continues to next instruction for basic block purposes
        let blockEndingOpcodes: Set<UInt8> = [
            PVMOpcodes.trap.rawValue,
            // PVMOpcodes.halt.rawValue,  // NOT included - halt/fallthrough continues to next instruction
            PVMOpcodes.jump.rawValue,
            PVMOpcodes.jumpInd.rawValue,
            PVMOpcodes.loadImmJump.rawValue,
            PVMOpcodes.loadImmJumpInd.rawValue,
            // Branch instructions (all variants)
            PVMOpcodes.branchEq.rawValue,
            PVMOpcodes.branchNe.rawValue,
            PVMOpcodes.branchLtU.rawValue,
            PVMOpcodes.branchLtS.rawValue,
            PVMOpcodes.branchGeU.rawValue,
            PVMOpcodes.branchGeS.rawValue,
            // Branch immediate instructions (all variants)
            PVMOpcodes.branchEqImm.rawValue,
            PVMOpcodes.branchNeImm.rawValue,
            PVMOpcodes.branchLtUImm.rawValue,
            PVMOpcodes.branchLeUImm.rawValue,
            PVMOpcodes.branchGeUImm.rawValue,
            PVMOpcodes.branchGtUImm.rawValue,
            PVMOpcodes.branchLtSImm.rawValue,
            PVMOpcodes.branchLeSImm.rawValue,
            PVMOpcodes.branchGeSImm.rawValue,
            PVMOpcodes.branchGtSImm.rawValue
        ]

        // First pass: identify all blocks and their instructions
        while currentPC < program.code.count {
            let opcode = program.code[relative: currentPC]

            // Start a new block if needed
            if currentBlock == nil {
                currentBlock = BasicBlock(startPC: UInt32(currentPC))
                blocks[UInt32(currentPC)] = currentBlock!
            }

            // Get instruction length using C++ implementation
            let instructionLength = getInstructionLength(opcode: opcode, at: currentPC, in: program)

            // Handle unknown opcodes - return 0 signals error
            if instructionLength == 0 {
                // Unknown opcode - stop parsing at this point
                // This is safer than continuing with incorrect sizes
                // logger.warning("Unknown opcode \(opcode) at PC \(currentPC), stopping block parsing")
                break
            }

            // Read instruction data
            let endPC = min(currentPC + instructionLength, program.code.count)
            let instructionData = Data(program.code[relative: currentPC ..< endPC])
            currentBlock!.instructions.append((opcode, instructionData))

            // Check if this ends a basic block
            if blockEndingOpcodes.contains(opcode) {
                // Finalize current block
                blocks[currentBlock!.startPC] = currentBlock!
                currentBlock = nil

                // If this is a branch, record the target as a jump target
                if opcode == PVMOpcodes.branchEq.rawValue || opcode == PVMOpcodes.branchNe.rawValue {
                    // BranchEq/Ne instructions - target is encoded in instruction
                    // For now, we'll mark all subsequent PCs as potential targets
                    // TODO: Parse branch target from instruction data
                }
            }

            currentPC += instructionLength
        }

        // Finalize last block if exists
        if let block = currentBlock {
            blocks[block.startPC] = block
        }

        // Second pass: mark jump targets
        for (_, block) in blocks {
            for (opcode, _) in block.instructions {
                if opcode == PVMOpcodes.branchEq.rawValue ||
                    opcode == PVMOpcodes.branchNe.rawValue ||
                    opcode == PVMOpcodes.jump.rawValue ||
                    opcode == PVMOpcodes.jumpInd.rawValue ||
                    opcode == PVMOpcodes.loadImmJump.rawValue
                {
                    // TODO: Parse target offset and mark as jump target
                    // For now, skip this as we need to implement instruction parsing
                }
            }
        }

        // logger.debug("Built \(blocks.count) basic blocks")  // Temporarily disabled
        return blocks
    }

    /// Gets the length of an instruction in bytes
    /// - Parameters:
    ///   - opcode: The instruction opcode
    ///   - pc: The program counter
    ///   - program: The program code
    /// - Returns: Instruction length in bytes, or 0 if unknown
    private func getInstructionLength(opcode: UInt8, at pc: Int, in program: ProgramCode) -> Int {
        // Simplified instruction length calculation
        // WARNING: This is a basic implementation with limited opcode support.
        // It is NOT suitable for production use with arbitrary bytecode.
        //
        // CRITICAL LIMITATIONS:
        // - Only handles a small subset of known opcodes
        // - Returns 0 for unknown opcodes (signals error)
        // - For accurate size detection, use the C++ get_instruction_size() function
        //
        // Known opcodes and their sizes:
        // 0: Trap = 1 byte
        // 1: Fallthrough = 1 byte
        // 20: LoadImm64 = 10 bytes
        // 30-33: StoreImm[U8/U16/U32/U64] = 6/7/9/13 bytes
        // Instruction size reference (from helper.cpp get_instruction_size):
        // 1 byte: Trap, Halt
        // 2 bytes: JumpInd
        // 3 bytes: Add/Sub/Mul/Div/Rem/Shift 32/64-bit, Bitwise (And/Xor/Or)
        // 4 bytes: 3-register instructions (MulUpper*, SetLt*, Cmov*, Rot*, Min/Max)
        // 5 bytes: Jump
        // 6 bytes: LoadImm, Load*, Store*
        // 7 bytes: BranchEq/Ne/LtU/LtS/GeU/GeS, StoreImmIndU8, StoreInd*, LoadInd*, AddImm32 (etc)
        // 9 bytes: StoreImmIndU32
        // 10 bytes: LoadImmU64, LoadImmJump, StoreImmIndU64, AddImm64 (etc)
        // 13 bytes: StoreImmU64
        // 14 bytes: BranchImm instructions

        switch opcode {
        // 1-byte instructions
        case PVMOpcodes.trap.rawValue, PVMOpcodes.halt.rawValue:
            return 1

        // 2-byte instructions
        case PVMOpcodes.jumpInd.rawValue:
            return 2

        // 3-byte instructions (arithmetic, bitwise)
        case PVMOpcodes.add32.rawValue, PVMOpcodes.sub32.rawValue,
             PVMOpcodes.mul32.rawValue, PVMOpcodes.divU32.rawValue,
             PVMOpcodes.divS32.rawValue, PVMOpcodes.remU32.rawValue,
             PVMOpcodes.remS32.rawValue,
             PVMOpcodes.shloL32.rawValue, PVMOpcodes.shloR32.rawValue, PVMOpcodes.sharR32.rawValue:
            return 3

        case PVMOpcodes.add64.rawValue, PVMOpcodes.sub64.rawValue,
             PVMOpcodes.mul64.rawValue, PVMOpcodes.divU64.rawValue,
             PVMOpcodes.divS64.rawValue, PVMOpcodes.remU64.rawValue,
             PVMOpcodes.remS64.rawValue,
             PVMOpcodes.shloL64.rawValue, PVMOpcodes.shloR64.rawValue, PVMOpcodes.sharR64.rawValue:
            return 3

        case PVMOpcodes.and.rawValue, PVMOpcodes.xor.rawValue, PVMOpcodes.or.rawValue:
            return 3

        // 4-byte instructions (3-register format)
        case PVMOpcodes.mulUpperSS.rawValue, PVMOpcodes.mulUpperUU.rawValue,
             PVMOpcodes.mulUpperSU.rawValue,
             PVMOpcodes.setLtU.rawValue, PVMOpcodes.setLtS.rawValue,
             PVMOpcodes.cmovIz.rawValue, PVMOpcodes.cmovNz.rawValue,
             PVMOpcodes.rotL64.rawValue, PVMOpcodes.rotR64.rawValue,
             PVMOpcodes.rotL32.rawValue, PVMOpcodes.rotR32.rawValue,
             PVMOpcodes.max.rawValue, PVMOpcodes.maxU.rawValue,
             PVMOpcodes.min.rawValue, PVMOpcodes.minU.rawValue:
            return 4

        // 5-byte instructions
        case PVMOpcodes.jump.rawValue:
            return 5

        // 6-byte instructions
        case PVMOpcodes.loadImm.rawValue,
             PVMOpcodes.loadU8.rawValue, PVMOpcodes.loadI8.rawValue,
             PVMOpcodes.loadU16.rawValue, PVMOpcodes.loadI16.rawValue,
             PVMOpcodes.loadU32.rawValue, PVMOpcodes.loadI32.rawValue,
             PVMOpcodes.loadU64.rawValue:
            return 6

        case PVMOpcodes.storeU8.rawValue, PVMOpcodes.storeU16.rawValue,
             PVMOpcodes.storeU32.rawValue, PVMOpcodes.storeU64.rawValue,
             PVMOpcodes.storeImmU8.rawValue:
            return 6

        // 7-byte instructions
        case PVMOpcodes.branchEq.rawValue, PVMOpcodes.branchNe.rawValue,
             PVMOpcodes.branchLtU.rawValue, PVMOpcodes.branchLtS.rawValue,
             PVMOpcodes.branchGeU.rawValue, PVMOpcodes.branchGeS.rawValue:
            return 7

        // 7-byte instructions (continued)
        case PVMOpcodes.storeImmIndU8.rawValue:
            return 7

        // 8-byte instructions
        case PVMOpcodes.storeImmIndU16.rawValue:
            return 8

        // 9-byte instructions
        case PVMOpcodes.storeImmIndU32.rawValue,
             PVMOpcodes.storeImmU32.rawValue:
            return 9

        // 10-byte instructions
        case PVMOpcodes.loadImmU64.rawValue,
             PVMOpcodes.loadImmJump.rawValue,
             PVMOpcodes.storeImmIndU64.rawValue:
            return 10

        // 11-byte instructions
        case PVMOpcodes.loadImmJumpInd.rawValue:
            return 11

        // 11-byte instructions (64-bit immediate)
        case PVMOpcodes.addImm64.rawValue,
             PVMOpcodes.mulImm64.rawValue,
             PVMOpcodes.shloLImm64.rawValue,
             PVMOpcodes.shloRImm64.rawValue,
             PVMOpcodes.sharRImm64.rawValue,
             PVMOpcodes.negAddImm64.rawValue,
             PVMOpcodes.shloLImmAlt64.rawValue,
             PVMOpcodes.shloRImmAlt64.rawValue,
             PVMOpcodes.sharRImmAlt64.rawValue,
             PVMOpcodes.rotR64Imm.rawValue,
             PVMOpcodes.rotR64ImmAlt.rawValue,
             PVMOpcodes.rotR32Imm.rawValue,
             PVMOpcodes.rotR32ImmAlt.rawValue:
            return 11

        // 13-byte instructions
        case PVMOpcodes.storeImmU64.rawValue:
            return 13

        // 14-byte instructions (BranchImm)
        case PVMOpcodes.branchEqImm.rawValue,
             PVMOpcodes.branchNeImm.rawValue,
             PVMOpcodes.branchLtUImm.rawValue,
             PVMOpcodes.branchLeUImm.rawValue,
             PVMOpcodes.branchGeUImm.rawValue,
             PVMOpcodes.branchGtUImm.rawValue,
             PVMOpcodes.branchLtSImm.rawValue,
             PVMOpcodes.branchLeSImm.rawValue,
             PVMOpcodes.branchGeSImm.rawValue,
             PVMOpcodes.branchGtSImm.rawValue:
            return 14

        // Store/Load Indirect (7 bytes)
        case PVMOpcodes.storeIndU8.rawValue, PVMOpcodes.storeIndU16.rawValue,
             PVMOpcodes.storeIndU32.rawValue, PVMOpcodes.storeIndU64.rawValue,
             PVMOpcodes.loadIndU8.rawValue, PVMOpcodes.loadIndI8.rawValue,
             PVMOpcodes.loadIndU16.rawValue, PVMOpcodes.loadIndI16.rawValue,
             PVMOpcodes.loadIndU32.rawValue, PVMOpcodes.loadIndI32.rawValue,
             PVMOpcodes.loadIndU64.rawValue:
            return 7

        // 32-bit immediate (7 bytes)
        case PVMOpcodes.addImm32.rawValue,
             PVMOpcodes.andImm.rawValue,
             PVMOpcodes.xorImm.rawValue,
             PVMOpcodes.orImm.rawValue,
             PVMOpcodes.mulImm32.rawValue,
             PVMOpcodes.setLtUImm.rawValue,
             PVMOpcodes.setLtSImm.rawValue,
             PVMOpcodes.shloLImm32.rawValue,
             PVMOpcodes.shloRImm32.rawValue,
             PVMOpcodes.sharRImm32.rawValue,
             PVMOpcodes.negAddImm32.rawValue,
             PVMOpcodes.setGtUImm.rawValue,
             PVMOpcodes.setGtSImm.rawValue,
             PVMOpcodes.shloLImmAlt32.rawValue,
             PVMOpcodes.shloRImmAlt32.rawValue,
             PVMOpcodes.sharRImmAlt32.rawValue,
             PVMOpcodes.cmovIzImm.rawValue,
             PVMOpcodes.cmovNzImm.rawValue:
            return 7

        case PVMOpcodes.andInv.rawValue, PVMOpcodes.orInv.rawValue, PVMOpcodes.xnor.rawValue:
            return 3

        case PVMOpcodes.ecalli.rawValue:
            return 5  // 1 byte opcode + 4 bytes callIndex

        default:
            // Unknown opcode - return 0 to signal error
            // This is safer than guessing a wrong size
            return 0
        }
    }
}
