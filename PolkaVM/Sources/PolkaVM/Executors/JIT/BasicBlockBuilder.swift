// generated by polka.codes
// Basic block builder for PVM JIT compiler

import CppHelper
import Foundation
import TracingUtils

/// Builds basic blocks from PVM bytecode for JIT compilation
///
/// Uses existing `BASIC_BLOCK_INSTRUCTIONS` set from Instructions.swift
/// to identify block boundaries.
final class BasicBlockBuilder {
    private let logger = Logger(label: "BasicBlockBuilder")
    private let program: ProgramCode

    /// Represents a basic block in the PVM program
    struct BasicBlock {
        let startPC: UInt32
        var instructions: [(opcode: UInt8, data: Data)] = []
        var isJumpTarget = false
        var gasCost: UInt64 = 0
    }

    init(program: ProgramCode) {
        self.program = program
    }

    /// Builds basic blocks from the program
    /// - Returns: Dictionary mapping PC to BasicBlock
    func build() -> [UInt32: BasicBlock] {
        // logger.debug("Building basic blocks for program")  // Temporarily disabled

        var blocks: [UInt32: BasicBlock] = [:]
        var currentBlock: BasicBlock?
        var currentPC = 0

        // Track which PCs are jump targets (will be filled in second pass)
        // TODO: Implement jump target parsing from instruction data
        // var jumpTargets: Set<UInt32> = []

        // Use the canonical BASIC_BLOCK_INSTRUCTIONS constant from Instructions.swift
        // This ensures consistency across the codebase for basic block detection
        let blockEndingOpcodes = BASIC_BLOCK_INSTRUCTIONS

        // First pass: identify all blocks and their instructions
        while currentPC < program.code.count {
            let opcode = program.code[relative: currentPC]

            // Start a new block if needed
            if currentBlock == nil {
                currentBlock = BasicBlock(startPC: UInt32(currentPC))
                blocks[UInt32(currentPC)] = currentBlock!
            }

            // Get instruction length using C++ implementation
            let instructionLength = program.code.withUnsafeBytes { bytes -> UInt32 in
                guard let baseAddress = bytes.baseAddress else {
                    return 0 // Empty code - signal error
                }
                return get_instruction_size(
                    baseAddress.assumingMemoryBound(to: UInt8.self),
                    UInt32(currentPC),
                    program.code.count
                )
            }

            // Handle unknown opcodes - return 0 signals error
            if instructionLength == 0 {
                // Unknown opcode - stop parsing at this point
                // This is safer than continuing with incorrect sizes
                // logger.warning("Unknown opcode \(opcode) at PC \(currentPC), stopping block parsing")
                break
            }

            // Read instruction data
            let endPC = min(currentPC + Int(instructionLength), program.code.count)
            let instructionData = Data(program.code[relative: currentPC ..< endPC])
            currentBlock!.instructions.append((opcode, instructionData))

            // Check if this ends a basic block
            if blockEndingOpcodes.contains(opcode) {
                // Finalize current block
                blocks[currentBlock!.startPC] = currentBlock!
                currentBlock = nil

                // If this is a branch, record the target as a jump target
                if opcode == PVMOpcodes.branchEq.rawValue || opcode == PVMOpcodes.branchNe.rawValue {
                    // BranchEq/Ne instructions - target is encoded in instruction
                    // For now, we'll mark all subsequent PCs as potential targets
                    // TODO: Parse branch target from instruction data
                }
            }

            currentPC += Int(instructionLength)
        }

        // Finalize last block if exists
        if let block = currentBlock {
            blocks[block.startPC] = block
        }

        // Second pass: mark jump targets
        for (_, block) in blocks {
            for (opcode, _) in block.instructions {
                if opcode == PVMOpcodes.branchEq.rawValue ||
                    opcode == PVMOpcodes.branchNe.rawValue ||
                    opcode == PVMOpcodes.jump.rawValue ||
                    opcode == PVMOpcodes.jumpInd.rawValue ||
                    opcode == PVMOpcodes.loadImmJump.rawValue
                {
                    // TODO: Parse target offset and mark as jump target
                    // For now, skip this as we need to implement instruction parsing
                }
            }
        }

        // logger.debug("Built \(blocks.count) basic blocks")  // Temporarily disabled
        return blocks
    }
}
