// generated by polka.codes
// Basic block builder for PVM JIT compiler

import CppHelper
import Foundation
import TracingUtils

/// Builds basic blocks from PVM bytecode for JIT compilation
///
/// Uses existing `BASIC_BLOCK_INSTRUCTIONS` set from Instructions.swift
/// to identify block boundaries.
final class BasicBlockBuilder {
    private let logger = Logger(label: "BasicBlockBuilder")
    private let program: ProgramCode

    /// Represents a basic block in the PVM program
    struct BasicBlock {
        let startPC: UInt32
        var instructions: [(opcode: UInt8, data: Data)] = []
        var isJumpTarget = false
        var gasCost: UInt64 = 0
    }

    init(program: ProgramCode) {
        self.program = program
    }

    /// Builds basic blocks from the program
    /// - Returns: Dictionary mapping PC to BasicBlock
    func build() -> [UInt32: BasicBlock] {
        // logger.debug("Building basic blocks for program")  // Temporarily disabled

        var blocks: [UInt32: BasicBlock] = [:]
        var currentBlock: BasicBlock?
        var currentPC = 0

        // Track which PCs are jump targets (will be filled in second pass)
        // TODO: Implement jump target parsing from instruction data
        // var jumpTargets: Set<UInt32> = []

        // Get basic block ending instructions - cache opcodes as constants to avoid C++ layer access
        // TODO: Import BASIC_BLOCK_INSTRUCTIONS from Instructions.swift properly
        // Block-ending opcodes matching instruction_dispatcher.cpp implementation
        // NOTE: Halt/Fallthrough (opcode 1) is NOT included - it continues to next instruction for basic block purposes
        let blockEndingOpcodes: Set<UInt8> = [
            PVMOpcodes.trap.rawValue,
            // PVMOpcodes.halt.rawValue,  // NOT included - halt/fallthrough continues to next instruction
            PVMOpcodes.jump.rawValue,
            PVMOpcodes.jumpInd.rawValue,
            PVMOpcodes.loadImmJump.rawValue,
            PVMOpcodes.loadImmJumpInd.rawValue,
            // Branch instructions (all variants)
            PVMOpcodes.branchEq.rawValue,
            PVMOpcodes.branchNe.rawValue,
            PVMOpcodes.branchLtU.rawValue,
            PVMOpcodes.branchLtS.rawValue,
            PVMOpcodes.branchGeU.rawValue,
            PVMOpcodes.branchGeS.rawValue,
            // Branch immediate instructions (all variants)
            PVMOpcodes.branchEqImm.rawValue,
            PVMOpcodes.branchNeImm.rawValue,
            PVMOpcodes.branchLtUImm.rawValue,
            PVMOpcodes.branchLeUImm.rawValue,
            PVMOpcodes.branchGeUImm.rawValue,
            PVMOpcodes.branchGtUImm.rawValue,
            PVMOpcodes.branchLtSImm.rawValue,
            PVMOpcodes.branchLeSImm.rawValue,
            PVMOpcodes.branchGeSImm.rawValue,
            PVMOpcodes.branchGtSImm.rawValue,
        ]

        // First pass: identify all blocks and their instructions
        while currentPC < program.code.count {
            let opcode = program.code[relative: currentPC]

            // Start a new block if needed
            if currentBlock == nil {
                currentBlock = BasicBlock(startPC: UInt32(currentPC))
                blocks[UInt32(currentPC)] = currentBlock!
            }

            // Get instruction length using C++ implementation
            let instructionLength = get_instruction_size(
                program.code.withUnsafeBytes { $0.baseAddress!.assumingMemoryBound(to: UInt8.self) },
                UInt32(currentPC),
                program.code.count
            )

            // Handle unknown opcodes - return 0 signals error
            if instructionLength == 0 {
                // Unknown opcode - stop parsing at this point
                // This is safer than continuing with incorrect sizes
                // logger.warning("Unknown opcode \(opcode) at PC \(currentPC), stopping block parsing")
                break
            }

            // Read instruction data
            let endPC = min(currentPC + Int(instructionLength), program.code.count)
            let instructionData = Data(program.code[relative: currentPC ..< endPC])
            currentBlock!.instructions.append((opcode, instructionData))

            // Check if this ends a basic block
            if blockEndingOpcodes.contains(opcode) {
                // Finalize current block
                blocks[currentBlock!.startPC] = currentBlock!
                currentBlock = nil

                // If this is a branch, record the target as a jump target
                if opcode == PVMOpcodes.branchEq.rawValue || opcode == PVMOpcodes.branchNe.rawValue {
                    // BranchEq/Ne instructions - target is encoded in instruction
                    // For now, we'll mark all subsequent PCs as potential targets
                    // TODO: Parse branch target from instruction data
                }
            }

            currentPC += Int(instructionLength)
        }

        // Finalize last block if exists
        if let block = currentBlock {
            blocks[block.startPC] = block
        }

        // Second pass: mark jump targets
        for (_, block) in blocks {
            for (opcode, _) in block.instructions {
                if opcode == PVMOpcodes.branchEq.rawValue ||
                    opcode == PVMOpcodes.branchNe.rawValue ||
                    opcode == PVMOpcodes.jump.rawValue ||
                    opcode == PVMOpcodes.jumpInd.rawValue ||
                    opcode == PVMOpcodes.loadImmJump.rawValue
                {
                    // TODO: Parse target offset and mark as jump target
                    // For now, skip this as we need to implement instruction parsing
                }
            }
        }

        // logger.debug("Built \(blocks.count) basic blocks")  // Temporarily disabled
        return blocks
    }
}
