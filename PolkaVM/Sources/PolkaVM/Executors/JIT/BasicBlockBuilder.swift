// generated by polka.codes
// Basic block builder for PVM JIT compiler

import Foundation
import TracingUtils

/// Builds basic blocks from PVM bytecode for JIT compilation
///
/// Uses existing `BASIC_BLOCK_INSTRUCTIONS` set from Instructions.swift
/// to identify block boundaries.
final class BasicBlockBuilder {
    private let logger = Logger(label: "BasicBlockBuilder")
    private let program: ProgramCode

    /// Represents a basic block in the PVM program
    struct BasicBlock {
        let startPC: UInt32
        var instructions: [(opcode: UInt8, data: Data)] = []
        var isJumpTarget = false
        var gasCost: UInt64 = 0
    }

    init(program: ProgramCode) {
        self.program = program
    }

    /// Builds basic blocks from the program
    /// - Returns: Dictionary mapping PC to BasicBlock
    func build() -> [UInt32: BasicBlock] {
        // logger.debug("Building basic blocks for program")  // Temporarily disabled

        var blocks: [UInt32: BasicBlock] = [:]
        var currentBlock: BasicBlock?
        var currentPC = 0

        // Track which PCs are jump targets (will be filled in second pass)
        // TODO: Implement jump target parsing from instruction data
        // var jumpTargets: Set<UInt32> = []

        // Get basic block ending instructions - cache opcodes as constants to avoid C++ layer access
        // TODO: Import BASIC_BLOCK_INSTRUCTIONS from Instructions.swift properly
        let blockEndingOpcodes: Set<UInt8> = [0, 4, 5, 6, 80, 81, 82, 83]
        // 0: Trap, 4: Jump, 5: JumpInd, 6: LoadImmJump, 80: BranchEqImm, 81: BranchNeImm, 82: BranchEq, 83: BranchNe

        // First pass: identify all blocks and their instructions
        while currentPC < program.code.count {
            let opcode = program.code[relative: currentPC]

            // Start a new block if needed
            if currentBlock == nil {
                currentBlock = BasicBlock(startPC: UInt32(currentPC))
                blocks[UInt32(currentPC)] = currentBlock!
            }

            // Get instruction length using C++ implementation
            let instructionLength = getInstructionLength(opcode: opcode, at: currentPC, in: program)

            // Handle unknown opcodes - return 0 signals error
            if instructionLength == 0 {
                // Unknown opcode - stop parsing at this point
                // This is safer than continuing with incorrect sizes
                // logger.warning("Unknown opcode \(opcode) at PC \(currentPC), stopping block parsing")
                break
            }

            // Read instruction data
            let endPC = min(currentPC + instructionLength, program.code.count)
            let instructionData = Data(program.code[relative: currentPC ..< endPC])
            currentBlock!.instructions.append((opcode, instructionData))

            // Check if this ends a basic block
            if blockEndingOpcodes.contains(opcode) {
                // Finalize current block
                blocks[currentBlock!.startPC] = currentBlock!
                currentBlock = nil

                // If this is a branch, record the target as a jump target
                if opcode >= 80, opcode <= 90 {
                    // BranchImm instructions - target is encoded in instruction
                    // For now, we'll mark all subsequent PCs as potential targets
                    // TODO: Parse branch target from instruction data
                }
            }

            currentPC += instructionLength
        }

        // Finalize last block if exists
        if let block = currentBlock {
            blocks[block.startPC] = block
        }

        // Second pass: mark jump targets
        for (_, block) in blocks {
            for (opcode, _) in block.instructions {
                if opcode == 80 || // BranchEqImm
                    opcode == 81 || // BranchNeImm
                    opcode == 4 || // Jump
                    opcode == 6
                { // LoadImmJump
                    // TODO: Parse target offset and mark as jump target
                    // For now, skip this as we need to implement instruction parsing
                }
            }
        }

        // logger.debug("Built \(blocks.count) basic blocks")  // Temporarily disabled
        return blocks
    }

    /// Gets the length of an instruction in bytes
    /// - Parameters:
    ///   - opcode: The instruction opcode
    ///   - pc: The program counter
    ///   - program: The program code
    /// - Returns: Instruction length in bytes, or 0 if unknown
    private func getInstructionLength(opcode: UInt8, at pc: Int, in program: ProgramCode) -> Int {
        // Simplified instruction length calculation
        // WARNING: This is a basic implementation with limited opcode support.
        // It is NOT suitable for production use with arbitrary bytecode.
        //
        // CRITICAL LIMITATIONS:
        // - Only handles a small subset of known opcodes
        // - Returns 0 for unknown opcodes (signals error)
        // - For accurate size detection, use the C++ get_instruction_size() function
        //
        // Known opcodes and their sizes:
        // 0: Trap = 1 byte
        // 1: Fallthrough = 1 byte
        // 20: LoadImm64 = 10 bytes
        // 30-33: StoreImm[U8/U16/U32/U64] = 6/7/9/13 bytes
        // 40: Jump = 5 bytes (IMPORTANT: block-ending instruction)
        // 50: JumpInd = 2 bytes
        // 51: LoadImm = 6 bytes
        // 52-58: Load[U8/I8/U16/I16/U32/I32/U64] = 6 bytes each
        // 59-62: Store[U8/U16/U32/U64] = 6 bytes each
        // 170-171: Branch[Eq/Ne] = 9 bytes each
        // 190-196: 32-bit arithmetic = 3 bytes each
        // 200-202: 64-bit arithmetic = 3 bytes each
        // 210-212: And/Xor/Or = 3 bytes each

        switch opcode {
        case 0, 1:  // Trap, Fallthrough
            return 1
        case 20:  // LoadImm64
            return 10
        case 30:  // StoreImmU8
            return 6
        case 31:  // StoreImmU16
            return 7
        case 32:  // StoreImmU32
            return 9
        case 33:  // StoreImmU64
            return 13
        case 40:  // Jump (CRITICAL: 5 bytes, block-ending)
            return 5
        case 50:  // JumpInd
            return 2
        case 51:  // LoadImm
            return 6
        case 52, 53, 54, 55, 56, 57, 58:  // LoadU8, LoadI8, LoadU16, LoadI16, LoadU32, LoadI32, LoadU64
            return 6
        case 59, 60, 61, 62:  // StoreU8, StoreU16, StoreU32, StoreU64
            return 6
        case 170, 171:  // BranchEq, BranchNe
            return 9
        case 190, 191, 192, 193, 194, 195, 196:  // 32-bit arithmetic
            return 3
        case 200, 201, 202:  // 64-bit arithmetic
            return 3
        case 210, 211, 212:  // And, Xor, Or
            return 3
        default:
            // Unknown opcode - return 0 to signal error
            // This is safer than guessing a wrong size
            return 0
        }
    }
}
