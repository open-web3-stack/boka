// generated by polka.codes
// Basic block builder for PVM JIT compiler

import Foundation
import TracingUtils

/// Builds basic blocks from PVM bytecode for JIT compilation
///
/// Uses existing `BASIC_BLOCK_INSTRUCTIONS` set from Instructions.swift
/// to identify block boundaries.
final class BasicBlockBuilder {
    private let logger = Logger(label: "BasicBlockBuilder")
    private let program: ProgramCode

    /// Represents a basic block in the PVM program
    struct BasicBlock {
        let startPC: UInt32
        var instructions: [(opcode: UInt8, data: Data)] = []
        var isJumpTarget = false
        var gasCost: UInt64 = 0
    }

    init(program: ProgramCode) {
        self.program = program
    }

    /// Builds basic blocks from the program
    /// - Returns: Dictionary mapping PC to BasicBlock
    func build() -> [UInt32: BasicBlock] {
        // logger.debug("Building basic blocks for program")  // Temporarily disabled

        var blocks: [UInt32: BasicBlock] = [:]
        var currentBlock: BasicBlock?
        var currentPC = 0

        // Track which PCs are jump targets (will be filled in second pass)
        // TODO: Implement jump target parsing from instruction data
        // var jumpTargets: Set<UInt32> = []

        // Get basic block ending instructions - cache opcodes as constants to avoid C++ layer access
        // TODO: Import BASIC_BLOCK_INSTRUCTIONS from Instructions.swift properly
        // Block-ending opcodes matching instruction_dispatcher.cpp implementation
        let blockEndingOpcodes: Set<UInt8> = [
            PVMOpcodes.trap.rawValue,
            PVMOpcodes.jump.rawValue,
            PVMOpcodes.jumpInd.rawValue,
            PVMOpcodes.loadImmJump.rawValue,
            PVMOpcodes.branchEq.rawValue,
            PVMOpcodes.branchNe.rawValue
        ]

        // First pass: identify all blocks and their instructions
        while currentPC < program.code.count {
            let opcode = program.code[relative: currentPC]

            // Start a new block if needed
            if currentBlock == nil {
                currentBlock = BasicBlock(startPC: UInt32(currentPC))
                blocks[UInt32(currentPC)] = currentBlock!
            }

            // Get instruction length using C++ implementation
            let instructionLength = getInstructionLength(opcode: opcode, at: currentPC, in: program)

            // Handle unknown opcodes - return 0 signals error
            if instructionLength == 0 {
                // Unknown opcode - stop parsing at this point
                // This is safer than continuing with incorrect sizes
                // logger.warning("Unknown opcode \(opcode) at PC \(currentPC), stopping block parsing")
                break
            }

            // Read instruction data
            let endPC = min(currentPC + instructionLength, program.code.count)
            let instructionData = Data(program.code[relative: currentPC ..< endPC])
            currentBlock!.instructions.append((opcode, instructionData))

            // Check if this ends a basic block
            if blockEndingOpcodes.contains(opcode) {
                // Finalize current block
                blocks[currentBlock!.startPC] = currentBlock!
                currentBlock = nil

                // If this is a branch, record the target as a jump target
                if opcode == PVMOpcodes.branchEq.rawValue || opcode == PVMOpcodes.branchNe.rawValue {
                    // BranchEq/Ne instructions - target is encoded in instruction
                    // For now, we'll mark all subsequent PCs as potential targets
                    // TODO: Parse branch target from instruction data
                }
            }

            currentPC += instructionLength
        }

        // Finalize last block if exists
        if let block = currentBlock {
            blocks[block.startPC] = block
        }

        // Second pass: mark jump targets
        for (_, block) in blocks {
            for (opcode, _) in block.instructions {
                if opcode == PVMOpcodes.branchEq.rawValue ||
                    opcode == PVMOpcodes.branchNe.rawValue ||
                    opcode == PVMOpcodes.jump.rawValue ||
                    opcode == PVMOpcodes.jumpInd.rawValue ||
                    opcode == PVMOpcodes.loadImmJump.rawValue
                {
                    // TODO: Parse target offset and mark as jump target
                    // For now, skip this as we need to implement instruction parsing
                }
            }
        }

        // logger.debug("Built \(blocks.count) basic blocks")  // Temporarily disabled
        return blocks
    }

    /// Gets the length of an instruction in bytes
    /// - Parameters:
    ///   - opcode: The instruction opcode
    ///   - pc: The program counter
    ///   - program: The program code
    /// - Returns: Instruction length in bytes, or 0 if unknown
    private func getInstructionLength(opcode: UInt8, at pc: Int, in program: ProgramCode) -> Int {
        // Simplified instruction length calculation
        // WARNING: This is a basic implementation with limited opcode support.
        // It is NOT suitable for production use with arbitrary bytecode.
        //
        // CRITICAL LIMITATIONS:
        // - Only handles a small subset of known opcodes
        // - Returns 0 for unknown opcodes (signals error)
        // - For accurate size detection, use the C++ get_instruction_size() function
        //
        // Known opcodes and their sizes:
        // 0: Trap = 1 byte
        // 1: Fallthrough = 1 byte
        // 20: LoadImm64 = 10 bytes
        // 30-33: StoreImm[U8/U16/U32/U64] = 6/7/9/13 bytes
        // 40: Jump = 5 bytes (IMPORTANT: block-ending instruction)
        // 50: JumpInd = 2 bytes
        // 51: LoadImm = 6 bytes
        // 52-58: Load[U8/I8/U16/I16/U32/I32/U64] = 6 bytes each
        // 59-62: Store[U8/U16/U32/U64] = 6 bytes each
        // 80: LoadImmJump = 10 bytes
        // 170-171: Branch[Eq/Ne] = 7 bytes each (1 opcode + 2 regs + 4 offset)
        // 190-196: 32-bit arithmetic = 3 bytes each
        // 200-202: 64-bit arithmetic = 3 bytes each
        // 210-212: And/Xor/Or = 3 bytes each

        switch opcode {
        case PVMOpcodes.trap.rawValue, PVMOpcodes.halt.rawValue:
            return 1
        case PVMOpcodes.loadImmU64.rawValue:
            return 10
        case PVMOpcodes.storeImmU8.rawValue:
            return 6
        case PVMOpcodes.storeImmU16.rawValue:
            return 7
        case PVMOpcodes.storeImmU32.rawValue:
            return 9
        case PVMOpcodes.storeImmU64.rawValue:
            return 13
        case PVMOpcodes.jump.rawValue:
            return 5
        case PVMOpcodes.jumpInd.rawValue:
            return 2
        case PVMOpcodes.loadImm.rawValue:
            return 6
        case PVMOpcodes.loadU8.rawValue, PVMOpcodes.loadI8.rawValue,
             PVMOpcodes.loadU16.rawValue, PVMOpcodes.loadI16.rawValue,
             PVMOpcodes.loadU32.rawValue, PVMOpcodes.loadI32.rawValue,
             PVMOpcodes.loadU64.rawValue:
            return 6
        case PVMOpcodes.storeU8.rawValue, PVMOpcodes.storeU16.rawValue,
             PVMOpcodes.storeU32.rawValue, PVMOpcodes.storeU64.rawValue:
            return 6
        case PVMOpcodes.loadImmJump.rawValue:
            return 10
        case PVMOpcodes.branchEq.rawValue, PVMOpcodes.branchNe.rawValue:
            return 7
        case PVMOpcodes.add32.rawValue, PVMOpcodes.sub32.rawValue,
             PVMOpcodes.mul32.rawValue, PVMOpcodes.divU32.rawValue,
             PVMOpcodes.divS32.rawValue, PVMOpcodes.remU32.rawValue,
             PVMOpcodes.remS32.rawValue:
            return 3
        case PVMOpcodes.add64.rawValue, PVMOpcodes.sub64.rawValue,
             PVMOpcodes.mul64.rawValue, PVMOpcodes.divU64.rawValue,
             PVMOpcodes.divS64.rawValue, PVMOpcodes.remU64.rawValue,
             PVMOpcodes.remS64.rawValue:
            return 3
        case PVMOpcodes.and.rawValue, PVMOpcodes.xor.rawValue, PVMOpcodes.or.rawValue:
            return 3
        default:
            // Unknown opcode - return 0 to signal error
            // This is safer than guessing a wrong size
            return 0
        }
    }
}
