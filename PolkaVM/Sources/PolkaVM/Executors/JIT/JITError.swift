// generated by polka.codes
// Error types for JIT compilation and execution

import Foundation

enum JITError: Error, CustomStringConvertible {
    case compilationFailed(details: String)
    case executionFailed(details: String)
    case invalidReturnCode(code: Int32)
    case memoryAccessViolation(address: UInt32, size: UInt32)
    case gasExhausted
    case hostFunctionError(index: UInt32, details: String)
    case targetArchUnsupported(arch: String)
    case vmInitializationError(details: String)
    case functionPointerNil
    case failedToGetBlobBaseAddress
    case failedToGetFlatMemoryBaseAddress
    case flatMemoryBufferSizeMismatch(expected: Int, actual: Int)
    case cppHelperError(code: Int32, details: String)
    case invalidArgument(description: String)
    case memoryAllocationFailed(size: UInt32, context: String)

    var description: String {
        switch self {
        case let .compilationFailed(details):
            "JIT compilation failed: \(details)"
        case let .executionFailed(details):
            "JIT execution failed: \(details)"
        case let .invalidReturnCode(code):
            "Invalid return code from JIT function: \(code)"
        case let .memoryAccessViolation(address, size):
            "Memory access violation at address \(address) with size \(size)"
        case .gasExhausted:
            "Gas exhausted during JIT execution"
        case let .hostFunctionError(index, details):
            "Host function error at index \(index): \(details)"
        case let .targetArchUnsupported(arch):
            "Unsupported target architecture for JIT: \(arch)"
        case let .vmInitializationError(details):
            "VM initialization error: \(details)"
        case .functionPointerNil:
            "Function pointer is nil after compilation or cache lookup"
        case .failedToGetBlobBaseAddress:
            "Failed to get base address of blob data for JIT compilation"
        case .failedToGetFlatMemoryBaseAddress:
            "Failed to get base address of JIT flat memory buffer"
        case let .flatMemoryBufferSizeMismatch(expected, actual):
            "JIT flat memory buffer size mismatch: expected \(expected), got \(actual)"
        case let .cppHelperError(code, details):
            "C++ helper error (code \(code)): \(details)"
        case let .invalidArgument(description):
            "Invalid argument: \(description)"
        case let .memoryAllocationFailed(size, context):
            "Memory allocation failed for size \(size): \(context)"
        }
    }

    // Maps JITError to appropriate ExitReason
    func toExitReason() -> ExitReason {
        switch self {
        case .gasExhausted:
            .outOfGas
        case let .memoryAccessViolation(address, _):
            .pageFault(address)
        case let .hostFunctionError(index, _):
            .hostCall(index)
        case .compilationFailed:
            .panic(.jitCompilationFailed)
        case .executionFailed:
            .panic(.jitExecutionError)
        case .invalidReturnCode:
            .panic(.jitExecutionError)
        case .targetArchUnsupported:
            .panic(.jitCompilationFailed)
        case .vmInitializationError:
            .panic(.jitMemoryError)
        case .functionPointerNil:
            .panic(.jitInvalidFunctionPointer)
        case .failedToGetBlobBaseAddress, .failedToGetFlatMemoryBaseAddress:
            .panic(.jitMemoryError)
        case .flatMemoryBufferSizeMismatch:
            .panic(.jitMemoryError)
        case .cppHelperError:
            .panic(.jitExecutionError)
        case .invalidArgument:
            .panic(.jitCompilationFailed)
        case .memoryAllocationFailed:
            .panic(.jitMemoryError)
        }
    }
}
