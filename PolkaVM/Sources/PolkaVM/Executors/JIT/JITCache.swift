// generated by polka.codes
// JIT code cache for PolkaVM

import CryptoKit
import Foundation
import TracingUtils
import Utils

/// Cache for JIT-compiled code
final class JITCache: @unchecked Sendable {
    private let logger = Logger(label: "JITCache")

    /// Cache entry type
    private struct CacheEntry {
        let functionAddress: UInt
        let timestamp: Date

        init(functionAddress: UInt) {
            self.functionAddress = functionAddress
            timestamp = Date()
        }
    }

    /// Thread-safe cache storage using actor
    private actor CacheStorage {
        /// Cache of compiled functions
        private var cache: [String: CacheEntry] = [:]

        /// Add a function to the cache
        /// - Parameters:
        ///   - address: The function address
        ///   - key: The cache key
        func add(address: UInt, forKey key: String) {
            cache[key] = CacheEntry(functionAddress: address)
        }

        /// Get a function from the cache
        /// - Parameter key: The cache key
        /// - Returns: The function address if found, nil otherwise
        func get(forKey key: String) -> UInt? {
            cache[key]?.functionAddress
        }

        /// Remove a function from the cache
        /// - Parameter key: The cache key
        func remove(forKey key: String) {
            cache.removeValue(forKey: key)
        }

        /// Clear the cache
        func clear() {
            cache.removeAll()
        }
    }

    /// Cache storage
    private let storage = CacheStorage()

    /// Create a cache key for a program
    /// - Parameters:
    ///   - blob: The program code blob
    ///   - initialPC: The initial program counter
    ///   - targetArchitecture: The target architecture
    ///   - config: The VM configuration
    /// - Returns: The cache key
    static func createCacheKey(
        blob: Data,
        initialPC: UInt32,
        targetArchitecture: String,
        config: PvmConfig
    ) -> String {
        // Combine program blob with other relevant parameters
        var keyData = Data()
        keyData.append(blob)
        keyData.append(withUnsafeBytes(of: initialPC) { Data($0) })
        keyData.append(targetArchitecture.data(using: .utf8) ?? Data())

        // Add VM configuration hash elements
        keyData.append(withUnsafeBytes(of: config.initialHeapPages) { Data($0) })
        keyData.append(withUnsafeBytes(of: config.stackPages) { Data($0) })
        keyData.append(withUnsafeBytes(of: config.pvmMemoryPageSize) { Data($0) })

        // Create a SHA-256 hash for the key
        let hash = SHA256.hash(data: keyData)
        return hash.map { String(format: "%02x", $0) }.joined()
    }

    /// Cache a compiled function
    /// - Parameters:
    ///   - address: The function address
    ///   - key: The cache key
    func cacheFunction(_ address: UInt, forKey key: String) async {
        logger.debug("Caching function with address \(address) for key \(key)")
        await storage.add(address: address, forKey: key)
    }

    /// Get a cached function
    /// - Parameter key: The cache key
    /// - Returns: The function address if found, nil otherwise
    func getCachedFunction(forKey key: String) async -> UInt? {
        let address = await storage.get(forKey: key)
        if let address {
            logger.debug("Cache hit for key \(key)")
        } else {
            logger.debug("Cache miss for key \(key)")
        }
        return address
    }

    /// Remove a function from the cache
    /// - Parameter key: The cache key
    func removeFunction(forKey key: String) async {
        logger.debug("Removing function for key \(key)")
        await storage.remove(forKey: key)
    }

    /// Clear the cache
    func clearCache() async {
        logger.debug("Clearing JIT cache")
        await storage.clear()
    }
}
