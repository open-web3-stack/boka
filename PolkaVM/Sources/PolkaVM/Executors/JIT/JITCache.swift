// generated by polka.codes
// Caching mechanism for JIT-compiled functions

import CryptoKit
import Foundation
import TracingUtils

// TODO: Add cache size limits and eviction policies
// TODO: Implement persistent caching across VM instances
struct JITCacheKey: Hashable, Equatable, Sendable {
    let blobSHA256: String // SHA256 hex string of the bytecode
    let initialPC: UInt32
    let targetArchitecture: String // e.g., "aarch64-apple-darwin"
    let configSignature: String // A string representing relevant PvmConfig settings that affect JIT output

    // TODO: Add PVM version to cache key for compatibility across versions
    // TODO: Include optimization level in cache key when implemented
}

actor JITCache {
    private let logger = Logger(label: "JITCache")
    private var compiledCache: [JITCacheKey: UInt] = [:] // Store pointer as UInt

    private var cacheHits: UInt64 = 0
    private var cacheMisses: UInt64 = 0

    init() {
        logger.info("JITCache initialized.")
    }

    func getCachedFunction(forKey key: JITCacheKey) -> UInt? {
        if let cachedFuncAddress = compiledCache[key] {
            cacheHits += 1
            logger.debug("JIT cache hit for key. Hits: \(cacheHits), Misses: \(cacheMisses).")
            return cachedFuncAddress
        }
        cacheMisses += 1
        logger.debug("JIT cache miss for key. Hits: \(cacheHits), Misses: \(cacheMisses).")
        return nil
    }

    func cacheFunction(_ functionAddress: UInt, forKey key: JITCacheKey) {
        compiledCache[key] = functionAddress
        logger.debug("JIT function cached for key.")
    }

    func getStatistics() -> (hits: UInt64, misses: UInt64) {
        (cacheHits, cacheMisses)
    }

    func clearCache() {
        compiledCache.removeAll()
        cacheHits = 0
        cacheMisses = 0
        logger.info("JITCache cleared.")
    }

    // Helper to create a config signature string from PvmConfig.
    // This should be kept in sync with factors that affect JIT compilation.
    static func createConfigSignature(config: PvmConfig) -> String {
        // Ensure consistent ordering and formatting.
        var components: [String] = []
        components.append("pvmPageSize:\(config.pvmMemoryPageSize)")

        // Sort components to ensure consistent signature regardless of construction order.
        return components.sorted().joined(separator: ";")
    }

    static func createCacheKey(
        blob: Data,
        initialPC: UInt32,
        targetArchitecture: String,
        config: PvmConfig
    ) -> JITCacheKey {
        let blobSHA256 = SHA256.hash(data: blob).compactMap { String(format: "%02x", $0) }.joined()
        let configSignature = createConfigSignature(config: config)

        return JITCacheKey(
            blobSHA256: blobSHA256,
            initialPC: initialPC,
            targetArchitecture: targetArchitecture,
            configSignature: configSignature
        )
    }
}
