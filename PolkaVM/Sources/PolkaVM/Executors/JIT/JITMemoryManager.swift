// generated by polka.codes
// This file manages the flat memory buffer used by JIT-compiled code,
// including its preparation from and reflection to the PVM's Memory model.

import Foundation
import TracingUtils

// TODO: Ensure PvmConfig and Memory are accessible. May require imports.

final class JITMemoryManager {
    private let logger = Logger(label: "JITMemoryManager")

    init() {
        logger.info("JITMemoryManager initialized.")
    }

    func getJITTotalMemorySize(config _: PvmConfig) -> UInt32 {
        let maxAllowedSize = UInt32.max // PVM's 32-bit addressing limit

        let effectiveSize = maxAllowedSize // TODO: add ability to configure jitMaxMemorySize

        logger.info("JIT total memory size configured to: \(effectiveSize / (1024 * 1024))MB (Raw: \(effectiveSize) bytes)")
        return effectiveSize
    }

    func prepareJITMemoryBuffer(from sourcePvmMemory: Memory, config _: PvmConfig, jitMemorySize: UInt32) throws -> Data {
        logger
            .debug(
                "Preparing JIT flat memory buffer. Requested size: \(jitMemorySize / (1024 * 1024))MB. PVM memory type: \(type(of: sourcePvmMemory))"
            )
        guard jitMemorySize > 0 else {
            throw JITError.invalidArgument(description: "jitMemorySize must be positive. Was \(jitMemorySize).")
        }

        let flatBuffer = Data(repeating: 0, count: Int(jitMemorySize)) // Changed var to let
        guard flatBuffer.count == Int(jitMemorySize) else {
            // This should ideally not happen if Data(repeating:count:) succeeds and count is representable by Int.
            throw JITError.memoryAllocationFailed(
                size: jitMemorySize,
                context: "Failed to allocate JIT flat buffer of \(jitMemorySize) bytes."
            )
        }

        // TODO: Implement the actual copying logic from `sourcePvmMemory` to `flatBuffer`.
        // This needs to iterate through the segments/pages of `sourcePvmMemory` and copy them
        // into the correct offsets in `flatBuffer`.
        // PVM uses 32-bit addressing. The `jitMemorySize` is the total accessible space for JIT.
        //
        // Example sketch for copying (needs to be adapted to Memory protocol capabilities):
        // For each readable segment/page in `sourcePvmMemory`:
        //   let pvmAddress: UInt32 = segment.startAddress
        //   let segmentLength: UInt32 = segment.length
        //   if pvmAddress < jitMemorySize { // Ensure segment start is within JIT buffer
        //     let bytesToCopyInSegment = min(segmentLength, jitMemorySize - pvmAddress) // Don't read past JIT buffer end
        //     if bytesToCopyInSegment > 0 {
        //       do {
        //         let dataToCopy = try sourcePvmMemory.read(address: pvmAddress, count: bytesToCopyInSegment)
        //         // Ensure dataToCopy.count matches bytesToCopyInSegment
        //         flatBuffer.replaceSubrange(Int(pvmAddress)..<Int(pvmAddress + bytesToCopyInSegment), with: dataToCopy)
        //       } catch {
        //         logger.error("Failed to read from PVM memory at \(pvmAddress) for \(bytesToCopyInSegment) bytes: \(error)")
        //         throw JITError.memoryCopyFailed(reason: "Failed to read from PVM memory during JIT buffer preparation: \(error)")
        //       }
        //     }
        //   }
        //
        // This is a simplified sketch. `StandardMemory` might offer more direct ways to access its underlying data.
        // If `sourcePvmMemory` is `StandardMemory`, one might access its internal buffers more directly if safe.
        logger
            .warning(
                "TODO: `prepareJITMemoryBuffer` needs robust implementation. Currently returns a zeroed buffer. Actual memory content from PVM Memory is not copied."
            )

        return flatBuffer
    }

    func reflectJITMemoryChanges(
        from jitFlatMemoryBuffer: Data,
        to _: inout Memory,
        config _: PvmConfig,
        jitMemorySize: UInt32
    ) throws {
        logger.debug("Reflecting JIT memory changes back to PVM memory. Buffer size: \(jitFlatMemoryBuffer.count) bytes.")
        guard jitFlatMemoryBuffer.count == Int(jitMemorySize) else {
            throw JITError.flatMemoryBufferSizeMismatch(expected: Int(jitMemorySize), actual: jitFlatMemoryBuffer.count)
        }

        // TODO: Implement actual change reflection from `jitFlatMemoryBuffer` to `targetPvmMemory`.
        // Strategy:
        // 1. (Ideal) If CppHelper/JIT can provide a list of dirty pages/regions:
        //    Iterate through dirty regions. For each region [addr, addr+len) in `jitFlatMemoryBuffer`,
        //    write `jitFlatMemoryBuffer[addr..<addr+len]` to `targetPvmMemory` at `addr`.
        // 2. (Simpler) Iterate through all writable segments defined in `targetPvmMemory`.
        //    For each writable segment [pvmAddr, pvmAddr+pvmLen):
        //      if pvmAddr < jitMemorySize: // Ensure segment start is within JIT buffer
        //        let bytesToWriteInSegment = min(pvmLen, jitMemorySize - pvmAddr) // Don't write past JIT buffer end
        //        if bytesToWriteInSegment > 0 {
        //          let dataSlice = jitFlatMemoryBuffer.subdata(in: Int(pvmAddr)..<Int(pvmAddr + bytesToWriteInSegment))
        //          do {
        //            try targetPvmMemory.write(address: pvmAddr, data: dataSlice)
        //          } catch {
        //            logger.error("Failed to write to PVM memory at \(pvmAddr) for \(bytesToWriteInSegment) bytes: \(error)")
        //            throw JITError.memoryCopyFailed(reason: "Failed to write to PVM memory during JIT memory reflection: \(error)")
        //          }
        //        }
        // This needs careful handling of memory permissions and PVM memory model specifics.
        logger
            .warning(
                "TODO: `reflectJITMemoryChanges` needs robust implementation. JIT memory modifications are not saved back to PVM Memory."
            )
    }
}
