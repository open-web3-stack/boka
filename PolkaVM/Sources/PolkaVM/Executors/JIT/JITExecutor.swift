// generated by polka.codes
// JIT executor for PolkaVM

import CppHelper
import Foundation
import TracingUtils
import Utils

/// Possible errors that can occur during JIT execution
enum JITError: Error, CustomStringConvertible {
    case invalidFunctionPointer
    case executionFailed(Int32)
    case compilationFailed(Int32)
    case unsupportedArchitecture
    case memoryAllocationFailed
    case outOfGas
    case hostFunctionError
    case pageFault(UInt32)
    case unhandledException

    var description: String {
        switch self {
        case .invalidFunctionPointer:
            "Invalid JIT-compiled function pointer"
        case let .executionFailed(code):
            "JIT execution failed with code: \(code)"
        case let .compilationFailed(code):
            "JIT compilation failed with code: \(code)"
        case .unsupportedArchitecture:
            "Unsupported architecture for JIT compilation"
        case .memoryAllocationFailed:
            "Failed to allocate memory for JIT execution"
        case .outOfGas:
            "Out of gas during JIT execution"
        case .hostFunctionError:
            "Error in host function call during JIT execution"
        case let .pageFault(address):
            "Page fault at address 0x\(String(address, radix: 16))"
        case .unhandledException:
            "Unhandled exception during JIT execution"
        }
    }

    func toExitReason() -> ExitReason {
        switch self {
        case .outOfGas:
            .outOfGas
        case let .pageFault(address):
            .pageFault(address)
        case .hostFunctionError:
            .panic(.trap) // Using trap instead of hostFunctionThrewError which doesn't exist
        default:
            .panic(.trap)
        }
    }
}

/// JIT executor for PolkaVM
/// Responsible for executing JIT-compiled machine code
final class JITExecutor {
    private let logger = Logger(label: "JITExecutor")

    /// Execute a JIT-compiled function
    /// - Parameters:
    ///   - functionPtr: Pointer to the JIT-compiled function
    ///   - registers: VM registers
    ///   - jitMemorySize: Total memory size
    ///   - gas: Gas counter
    ///   - initialPC: Initial program counter
    ///   - invocationContext: Context for host function calls
    /// - Returns: A tuple of exit reason and memory buffer pointer (caller must deallocate)
    func execute(
        functionPtr: UnsafeMutableRawPointer,
        registers: inout Registers,
        jitMemorySize: UInt32,
        gas: inout Gas,
        initialPC: UInt32,
        invocationContext: UnsafeMutableRawPointer?
    ) throws -> (ExitReason, UnsafeMutablePointer<UInt8>) {
        // Create a flat memory buffer for the JIT execution
        logger.debug("Setting up JIT execution environment")

        // Prepare VM memory
        // TODO: Implement proper memory sandboxing by reserving 4GB address space with PROT_NONE
        //       and then enabling access only to pages that should be accessible to the guest
        let memoryBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: Int(jitMemorySize))

        // Initialize memory to zeros
        memoryBuffer.initialize(repeating: 0, count: Int(jitMemorySize))

        // Execute the JIT-compiled function
        logger.debug("Executing JIT-compiled function with initial PC: \(initialPC), Gas: \(gas.value)")

        var exitCode: Int32
        var gasValue = gas.value // Local copy since we can't modify gas.value directly

        // Use withUnsafeMutableRegistersPointer to safely get a pointer to register values
        exitCode = registers.withUnsafeMutableRegistersPointer { regPtr in
            // Create a type for the compiled function matching the expected C ABI
            typealias JITCompiledFunction = @convention(c) (
                UnsafeMutablePointer<UInt64>, // VM registers array
                UnsafeMutablePointer<UInt8>, // VM memory base
                UInt32, // VM memory size
                UnsafeMutablePointer<UInt64>, // VM gas counter
                UInt32, // Initial PC
                UnsafeMutableRawPointer? // Context pointer
            ) -> Int32

            // Cast the raw function pointer to the expected type
            let compiledFunc = unsafeBitCast(functionPtr, to: JITCompiledFunction.self)

            // Call the compiled function
            return compiledFunc(
                regPtr,
                memoryBuffer,
                jitMemorySize,
                &gasValue,
                initialPC,
                invocationContext
            )
        }

        // Create a new Gas instance with updated value
        gas = Gas(gasValue)

        // Convert exit code to ExitReason
        logger.debug("JIT execution completed with exit code: \(exitCode)")

        // Translate exit code to ExitReason
        // TODO: Define proper exit codes in the C++ side and ensure they match with Swift expectations
        let exitReason: ExitReason
        switch exitCode {
        case 0:
            exitReason = .halt
        case 1:
            exitReason = .outOfGas
        case 2:
            // Fallback to interpreter with current state
            // Extract PC (r15) and all register values
            let fallbackPC = UInt32(registers[Registers.Index(raw: 15)])  // r15 = PC
            var fallbackRegisters: [UInt64] = []
            for i: UInt8 in 0..<16 {
                fallbackRegisters.append(registers[Registers.Index(raw: i)])
            }
            let gasUsed = gas.value  // Gas remaining after JIT execution
            exitReason = .fallback(pc: fallbackPC, registers: fallbackRegisters, gasUsed: gasUsed)
        case 3:
            // For a page fault, we would need to extract the faulting address from registers
            exitReason = .pageFault(UInt32(registers[Registers.Index(raw: 0)]))
        case -1:
            exitReason = .panic(.trap)
        default:
            logger.error("Unknown JIT exit code: \(exitCode)")
            exitReason = .panic(.trap)
        }

        return (exitReason, memoryBuffer)
    }
}
