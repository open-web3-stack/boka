// generated by polka.codes
// JIT executor for PolkaVM

import CppHelper
import Foundation
import Glibc
import TracingUtils
import Utils

/// Possible errors that can occur during JIT execution
enum JITError: Error, CustomStringConvertible {
    case invalidFunctionPointer
    case executionFailed(Int32)
    case compilationFailed(Int32)
    case unsupportedArchitecture
    case memoryAllocationFailed
    case outOfGas
    case hostFunctionError
    case pageFault(UInt32)
    case unhandledException

    var description: String {
        switch self {
        case .invalidFunctionPointer:
            "Invalid JIT-compiled function pointer"
        case let .executionFailed(code):
            "JIT execution failed with code: \(code)"
        case let .compilationFailed(code):
            "JIT compilation failed with code: \(code)"
        case .unsupportedArchitecture:
            "Unsupported architecture for JIT compilation"
        case .memoryAllocationFailed:
            "Failed to allocate memory for JIT execution"
        case .outOfGas:
            "Out of gas during JIT execution"
        case .hostFunctionError:
            "Error in host function call during JIT execution"
        case let .pageFault(address):
            "Page fault at address 0x\(String(address, radix: 16))"
        case .unhandledException:
            "Unhandled exception during JIT execution"
        }
    }

    func toExitReason() -> ExitReason {
        switch self {
        case .outOfGas:
            .outOfGas
        case let .pageFault(address):
            .pageFault(address)
        case .hostFunctionError:
            .panic(.trap) // Using trap instead of hostFunctionThrewError which doesn't exist
        default:
            .panic(.trap)
        }
    }
}

/// Memory allocation information for proper deallocation
struct MemoryAllocationInfo {
    let pointer: UnsafeMutablePointer<UInt8>
    let size: Int
    let usesMmap: Bool

    /// Deallocate the memory using the appropriate method
    func deallocate() {
        if usesMmap {
            munmap(pointer, size)
        } else {
            pointer.deallocate()
        }
    }
}

/// JIT executor for PolkaVM
/// Responsible for executing JIT-compiled machine code
final class JITExecutor {
    private let logger = Logger(label: "JITExecutor")

    /// Execute a JIT-compiled function
    /// - Parameters:
    ///   - functionPtr: Pointer to the JIT-compiled function
    ///   - registers: VM registers
    ///   - jitMemorySize: Total memory size
    ///   - gas: Gas counter
    ///   - initialPC: Initial program counter
    ///   - invocationContext: Context for host function calls
    ///   - initialMemory: Initial memory state from StandardProgram (for proper zone initialization)
    ///   - memoryLayout: Optional rebased memory layout for efficient memory initialization
    /// - Returns: A tuple of exit reason and memory allocation info (caller must deallocate)
    func execute(
        functionPtr: UnsafeMutableRawPointer,
        registers: inout Registers,
        jitMemorySize: UInt32,
        gas: inout Gas,
        initialPC: UInt32,
        invocationContext: UnsafeMutableRawPointer?,
        initialMemory: (any Memory)? = nil,
        memoryLayout: JITMemoryLayout? = nil
    ) throws -> (ExitReason, MemoryAllocationInfo) {
        // Create a flat memory buffer for the JIT execution
        logger.debug("Setting up JIT execution environment")

        // Prepare VM memory
        // Use compact layout: allocate only what's needed, but use original addresses
        // This means buffer[0xFF000000] actually needs to exist!
        let memoryBuffer: UnsafeMutablePointer<UInt8>
        let usesMmap = false // Don't use mmap for now

        // Allocate compact buffer
        logger.info("Allocating compact buffer: \(jitMemorySize) bytes")
        memoryBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: Int(jitMemorySize))

        // MEMORY INITIALIZATION: Copy data to appropriate addresses
        // We use original addresses (e.g., 0xFF000000 for stack), NOT rebased offsets
        if let layout = memoryLayout {
            // Copy zone data to original addresses in the buffer
            logger.info("Copying zones to original addresses")

            // First, zero-initialize the entire buffer
            memoryBuffer.initialize(repeating: 0, count: Int(jitMemorySize))

            // Copy zones using layout for efficient initialization
            var totalCopied = 0
            for zone in layout.zones {
                logger.info("  Zone: base=0x\(String(zone.originalBase, radix: 16)), size=\(zone.size), dataCount=\(zone.data.count)")

                // Copy zone data to its original address
                zone.data.withUnsafeBytes { rawBuffer in
                    if let baseAddress = rawBuffer.baseAddress {
                        let destPtr = memoryBuffer.advanced(by: Int(zone.originalBase))
                        memcpy(destPtr, baseAddress, zone.data.count)
                        totalCopied += zone.data.count
                        logger.debug(
                            "  Copied zone: \(zone.data.count) bytes to original address 0x\(String(zone.originalBase, radix: 16))"
                        )
                    }
                }
            }
            logger.info("✅ Initialized JIT memory: \(totalCopied) bytes copied to original addresses")
        } else if let initialMemory {
            // Fallback: Copy from initialMemory (old method - scans entire address space)
            logger.warning("⚠️ Using legacy memory initialization (no rebased layout provided)")
            // First, zero-initialize the entire buffer
            memoryBuffer.initialize(repeating: 0, count: Int(jitMemorySize))

            // Copy memory zones from initialMemory to flat JIT buffer
            // The JIT uses a flat memory model, so we need to copy all zone data
            // We copy in chunks for efficiency
            let memorySize = UInt32(jitMemorySize)
            var address: UInt32 = 0
            let chunkSize = 4096 // Copy in 4KB chunks
            var totalCopied = 0

            while address < memorySize {
                let remainingSize = Int(memorySize - address)
                let currentChunkSize = min(chunkSize, remainingSize)

                do {
                    let data = try initialMemory.read(address: address, length: currentChunkSize)
                    if !data.isEmpty {
                        data.withUnsafeBytes { rawBuffer in
                            if let baseAddress = rawBuffer.baseAddress {
                                memcpy(memoryBuffer.advanced(by: Int(address)), baseAddress, data.count)
                            }
                        }
                        totalCopied += data.count
                        logger.debug("  Copied \(data.count) bytes at address \(address)")
                    }
                } catch {
                    // Address not readable - already zero-initialized
                    logger.debug("  Address \(address) not readable (gap in memory)")
                }

                address += UInt32(currentChunkSize)
            }
            logger.info("✅ Initialized JIT memory from StandardProgram zones: \(totalCopied) bytes copied out of \(jitMemorySize) total")
        } else {
            // Initialize memory to zeros (fallback behavior)
            if usesMmap {
                // For mmap, only initialize likely-used pages
                logger.warning("⚠️ Initializing mmap memory to zeros (no initial memory provided)")
            } else {
                memoryBuffer.initialize(repeating: 0, count: Int(jitMemorySize))
            }
            logger.warning("⚠️ Initialized JIT memory to zeros (no initial memory provided) - this may cause test failures!")
        }

        // Execute the JIT-compiled function
        logger.debug("Executing JIT-compiled function with initial PC: \(initialPC), Gas: \(gas.value)")
        logger.info("JIT memory size: \(jitMemorySize), memoryBuffer: \(memoryBuffer)")

        var exitCode: Int32
        var gasValue = gas.value // Local copy since we can't modify gas.value directly

        // Use withUnsafeMutableRegistersPointer to safely get a pointer to register values
        exitCode = registers.withUnsafeMutableRegistersPointer { regPtr in
            // Create a type for the compiled function matching the expected C ABI
            typealias JITCompiledFunction = @convention(c) (
                UnsafeMutablePointer<UInt64>, // VM registers array
                UnsafeMutablePointer<UInt8>, // VM memory base
                UInt32, // VM memory size
                UnsafeMutablePointer<UInt64>, // VM gas counter
                UInt32, // Initial PC
                UnsafeMutableRawPointer? // Context pointer
            ) -> Int32

            // Cast the raw function pointer to the expected type
            let compiledFunc = unsafeBitCast(functionPtr, to: JITCompiledFunction.self)

            // Call the compiled function
            return compiledFunc(
                regPtr,
                memoryBuffer,
                jitMemorySize,
                &gasValue,
                initialPC,
                invocationContext
            )
        }

        // Create a new Gas instance with updated value
        gas = Gas(gasValue)

        // Convert exit code to ExitReason
        logger.debug("JIT execution completed with exit code: \(exitCode)")

        // Translate exit code to ExitReason
        let exitReason: ExitReason

        if let jitExit = JITExitCode(rawValue: exitCode) {
            switch jitExit {
            case .halt:
                exitReason = .halt
            case .outOfGas:
                exitReason = .outOfGas
            case .fallback:
                // Previously fallback, now deprecated - treat as panic
                logger.error("JIT returned exit code 2 (fallback deprecated) - treating as panic")
                exitReason = .panic(.trap)
            case .pageFault:
                // Page fault from bounds checking
                // For a page fault, we would need to extract the faulting address from registers
                exitReason = .pageFault(UInt32(truncatingIfNeeded: registers[Registers.Index(raw: 0)]))
            case .trap:
                exitReason = .panic(.trap)
            case .hostRequestedHalt:
                exitReason = .halt
            case .hostPageFault:
                // Page fault from host call - extract faulting address from R0
                exitReason = .pageFault(UInt32(truncatingIfNeeded: registers[Registers.Index(raw: 0)]))
            case .gasExhausted:
                exitReason = .outOfGas
            case .hostFunctionThrewError:
                // Map to jitExecutionError
                exitReason = .panic(.jitExecutionError)
            case .hostFunctionNotFound:
                // Map to jitInvalidFunctionPointer
                exitReason = .panic(.jitInvalidFunctionPointer)
            }
        } else {
            logger.error("Unknown JIT exit code: \(exitCode)")
            exitReason = .panic(.trap)
        }

        // Return exit reason and memory allocation info for proper deallocation
        let memoryInfo = MemoryAllocationInfo(
            pointer: memoryBuffer,
            size: Int(jitMemorySize),
            usesMmap: usesMmap
        )

        return (exitReason, memoryInfo)
    }
}
