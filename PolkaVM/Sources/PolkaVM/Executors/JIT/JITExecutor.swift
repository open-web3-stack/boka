// generated by polka.codes
// JIT executor for PolkaVM

import CppHelper
import Foundation
import TracingUtils
import Utils

/// Possible errors that can occur during JIT execution
enum JITError: Error, CustomStringConvertible {
    case invalidFunctionPointer
    case executionFailed(Int32)
    case compilationFailed(Int32)
    case unsupportedArchitecture
    case memoryAllocationFailed
    case outOfGas
    case hostFunctionError
    case pageFault(UInt32)
    case unhandledException

    var description: String {
        switch self {
        case .invalidFunctionPointer:
            "Invalid JIT-compiled function pointer"
        case let .executionFailed(code):
            "JIT execution failed with code: \(code)"
        case let .compilationFailed(code):
            "JIT compilation failed with code: \(code)"
        case .unsupportedArchitecture:
            "Unsupported architecture for JIT compilation"
        case .memoryAllocationFailed:
            "Failed to allocate memory for JIT execution"
        case .outOfGas:
            "Out of gas during JIT execution"
        case .hostFunctionError:
            "Error in host function call during JIT execution"
        case let .pageFault(address):
            "Page fault at address 0x\(String(address, radix: 16))"
        case .unhandledException:
            "Unhandled exception during JIT execution"
        }
    }

    func toExitReason() -> ExitReason {
        switch self {
        case .outOfGas:
            .outOfGas
        case let .pageFault(address):
            .pageFault(address)
        case .hostFunctionError:
            .panic(.trap) // Using trap instead of hostFunctionThrewError which doesn't exist
        default:
            .panic(.trap)
        }
    }
}

/// JIT executor for PolkaVM
/// Responsible for executing JIT-compiled machine code
final class JITExecutor {
    private let logger = Logger(label: "JITExecutor")

    /// Execute a JIT-compiled function
    /// - Parameters:
    ///   - functionPtr: Pointer to the JIT-compiled function
    ///   - registers: VM registers
    ///   - jitMemorySize: Total memory size
    ///   - gas: Gas counter
    ///   - initialPC: Initial program counter
    ///   - invocationContext: Context for host function calls
    ///   - initialMemory: Initial memory state from StandardProgram (for proper zone initialization)
    ///   - memoryLayout: Optional rebased memory layout for efficient memory initialization
    /// - Returns: A tuple of exit reason and memory buffer pointer (caller must deallocate)
    func execute(
        functionPtr: UnsafeMutableRawPointer,
        registers: inout Registers,
        jitMemorySize: UInt32,
        gas: inout Gas,
        initialPC: UInt32,
        invocationContext: UnsafeMutableRawPointer?,
        initialMemory: (any Memory)? = nil,
        memoryLayout: JITMemoryLayout? = nil
    ) throws -> (ExitReason, UnsafeMutablePointer<UInt8>) {
        // Create a flat memory buffer for the JIT execution
        logger.debug("Setting up JIT execution environment")

        // Prepare VM memory
        // TODO: Implement proper memory sandboxing by reserving 4GB address space with PROT_NONE
        //       and then enabling access only to pages that should be accessible to the guest
        let memoryBuffer = UnsafeMutablePointer<UInt8>.allocate(capacity: Int(jitMemorySize))

        // MEMORY REBASING: Use rebased memory layout for efficient initialization
        if let layout = memoryLayout {
            // Zero-initialize the entire buffer
            memoryBuffer.initialize(repeating: 0, count: Int(jitMemorySize))

            // Copy zones using rebased layout (much faster than scanning 4GB)
            var totalCopied = 0
            for zone in layout.zones {
                // Copy zone data to its rebased offset
                zone.data.withUnsafeBytes { rawBuffer in
                    if let baseAddress = rawBuffer.baseAddress {
                        memcpy(memoryBuffer.advanced(by: Int(zone.baseOffset)), baseAddress, zone.data.count)
                        totalCopied += zone.data.count
                        logger
                            .debug(
                                "  Copied zone: \(zone.data.count) bytes at offset \(zone.baseOffset) (original address: 0x\(String(zone.originalBase, radix: 16)))"
                            )
                    }
                }
            }
            logger.info("✅ Initialized JIT memory using rebased layout: \(totalCopied) bytes copied into \(jitMemorySize) byte buffer")
        } else if let initialMemory {
            // Fallback: Copy from initialMemory (old method - scans entire address space)
            logger.warning("⚠️ Using legacy memory initialization (no rebased layout provided)")
            // First, zero-initialize the entire buffer
            memoryBuffer.initialize(repeating: 0, count: Int(jitMemorySize))

            // Copy memory zones from initialMemory to flat JIT buffer
            // The JIT uses a flat memory model, so we need to copy all zone data
            // We copy in chunks for efficiency
            let memorySize = UInt32(jitMemorySize)
            var address: UInt32 = 0
            let chunkSize = 4096 // Copy in 4KB chunks
            var totalCopied = 0

            while address < memorySize {
                let remainingSize = Int(memorySize - address)
                let currentChunkSize = min(chunkSize, remainingSize)

                do {
                    let data = try initialMemory.read(address: address, length: currentChunkSize)
                    if !data.isEmpty {
                        data.withUnsafeBytes { rawBuffer in
                            if let baseAddress = rawBuffer.baseAddress {
                                memcpy(memoryBuffer.advanced(by: Int(address)), baseAddress, data.count)
                            }
                        }
                        totalCopied += data.count
                        logger.debug("  Copied \(data.count) bytes at address \(address)")
                    }
                } catch {
                    // Address not readable - already zero-initialized
                    logger.debug("  Address \(address) not readable (gap in memory)")
                }

                address += UInt32(currentChunkSize)
            }
            logger.info("✅ Initialized JIT memory from StandardProgram zones: \(totalCopied) bytes copied out of \(jitMemorySize) total")
        } else {
            // Initialize memory to zeros (fallback behavior)
            memoryBuffer.initialize(repeating: 0, count: Int(jitMemorySize))
            logger.warning("⚠️ Initialized JIT memory to zeros (no initial memory provided) - this may cause test failures!")
        }

        // Execute the JIT-compiled function
        logger.debug("Executing JIT-compiled function with initial PC: \(initialPC), Gas: \(gas.value)")

        var exitCode: Int32
        var gasValue = gas.value // Local copy since we can't modify gas.value directly

        // Use withUnsafeMutableRegistersPointer to safely get a pointer to register values
        exitCode = registers.withUnsafeMutableRegistersPointer { regPtr in
            // Create a type for the compiled function matching the expected C ABI
            typealias JITCompiledFunction = @convention(c) (
                UnsafeMutablePointer<UInt64>, // VM registers array
                UnsafeMutablePointer<UInt8>, // VM memory base
                UInt32, // VM memory size
                UnsafeMutablePointer<UInt64>, // VM gas counter
                UInt32, // Initial PC
                UnsafeMutableRawPointer? // Context pointer
            ) -> Int32

            // Cast the raw function pointer to the expected type
            let compiledFunc = unsafeBitCast(functionPtr, to: JITCompiledFunction.self)

            // Call the compiled function
            return compiledFunc(
                regPtr,
                memoryBuffer,
                jitMemorySize,
                &gasValue,
                initialPC,
                invocationContext
            )
        }

        // Create a new Gas instance with updated value
        gas = Gas(gasValue)

        // Convert exit code to ExitReason
        logger.debug("JIT execution completed with exit code: \(exitCode)")

        // Translate exit code to ExitReason
        let exitReason: ExitReason

        if let jitExit = JITExitCode(rawValue: exitCode) {
            switch jitExit {
            case .halt:
                exitReason = .halt
            case .outOfGas:
                exitReason = .outOfGas
            case .fallback:
                // Previously fallback, now deprecated - treat as panic
                logger.error("JIT returned exit code 2 (fallback deprecated) - treating as panic")
                exitReason = .panic(.trap)
            case .pageFault:
                // Page fault from bounds checking
                // For a page fault, we would need to extract the faulting address from registers
                exitReason = .pageFault(UInt32(truncatingIfNeeded: registers[Registers.Index(raw: 0)]))
            case .trap:
                exitReason = .panic(.trap)
            case .hostRequestedHalt:
                exitReason = .halt
            case .hostPageFault:
                // Page fault from host call - extract faulting address from R0
                exitReason = .pageFault(UInt32(truncatingIfNeeded: registers[Registers.Index(raw: 0)]))
            case .gasExhausted:
                exitReason = .outOfGas
            case .hostFunctionThrewError:
                // Map to jitExecutionError
                exitReason = .panic(.jitExecutionError)
            case .hostFunctionNotFound:
                // Map to jitInvalidFunctionPointer
                exitReason = .panic(.jitInvalidFunctionPointer)
            }
        } else {
            logger.error("Unknown JIT exit code: \(exitCode)")
            exitReason = .panic(.trap)
        }

        return (exitReason, memoryBuffer)
    }
}
