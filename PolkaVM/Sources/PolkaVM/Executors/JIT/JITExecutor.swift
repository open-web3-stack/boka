// generated by polka.codes
// Execution logic for JIT-compiled functions

import Foundation
import TracingUtils
import Utils

// TODO: Add performance metrics collection (instruction counts, execution time, memory access patterns)
// TODO: Implement proper error handling for JIT execution failures
// TODO: Add support for instruction tracing to match interpreter's debug capabilities
// TODO: Implement memory access tracking for profiling and optimization

final class JITExecutor {
    private let logger = Logger(label: "JITExecutor")

    init() {
        logger.info("JITExecutor initialized.")
    }

    func execute(
        functionPtr: UnsafeMutableRawPointer,
        registers: inout Registers,
        jitFlatMemoryBuffer: inout Data, // The flat memory buffer for JIT
        jitMemorySize: UInt32,
        gas: inout Gas,
        initialPC: UInt32,
        invocationContext: UnsafeMutableRawPointer? // Opaque C context for host calls
    ) throws -> ExitReason {
        logger.debug("Preparing to call JIT-compiled function at \(functionPtr).")

        guard jitFlatMemoryBuffer.count == Int(jitMemorySize) else {
            logger
                .error(
                    "JIT flat memory buffer size (\(jitFlatMemoryBuffer.count)) does not match expected JIT total memory size (\(jitMemorySize))."
                )
            throw JITError.flatMemoryBufferSizeMismatch(expected: Int(jitMemorySize), actual: jitFlatMemoryBuffer.count)
        }

        let jitFunction = unsafeBitCast(functionPtr, to: JITFunctionSignature.self)

        var gasValue = gas.value // Extract the raw UInt64 value for the C function

        let exitReasonRawValue: Int32 = try jitFlatMemoryBuffer.withUnsafeMutableBytes { flatMemoryBufferPointer -> Int32 in
            guard let flatMemoryBaseAddress = flatMemoryBufferPointer.baseAddress?.assumingMemoryBound(to: UInt8.self) else {
                logger.error("Failed to get base address of JIT flat memory buffer.")
                throw JITError.failedToGetFlatMemoryBaseAddress
            }

            // Ensure the buffer pointer we got is not for a zero-sized buffer if jitMemorySize is > 0
            if jitMemorySize > 0, flatMemoryBufferPointer.baseAddress == nil {
                logger.error("JIT flat memory buffer base address is nil for a non-zero expected size (\(jitMemorySize)).")
                throw JITError.failedToGetFlatMemoryBaseAddress
            }

            return registers.withUnsafeMutableRegistersPointer { regPtr in
                withUnsafeMutablePointer(to: &gasValue) { gasPtr -> Int32 in
                    logger.debug("""
                    Calling JIT function with:
                      Registers ptr: \(String(describing: regPtr))
                      Memory ptr: \(String(describing: flatMemoryBaseAddress))
                      Memory size: \(jitMemorySize)
                      Gas ptr (to UInt64): \(String(describing: gasPtr))
                      Initial PC: \(initialPC)
                      InvocationContext ptr: \(String(describing: invocationContext))
                    """)
                    return jitFunction(regPtr, flatMemoryBaseAddress, jitMemorySize, gasPtr, initialPC, invocationContext)
                }
            }
        }

        gas = Gas(gasValue) // Update Gas struct with the (potentially) modified value.

        logger.debug("JIT function returned raw ExitReason value: \(exitReasonRawValue)")

        // TODO: Add detailed performance metrics collection here (similar to interpreter's tracing)
        // TODO: Implement proper gas accounting verification (ensure JIT and interpreter use same gas model)
        // TODO: Add memory access pattern analysis for future optimization

        guard let exitReason = ExitReason.fromInt32(exitReasonRawValue) else {
            logger.error("Invalid ExitReason raw value returned from JIT function: \(exitReasonRawValue)")
            throw JITError.invalidReturnCode(code: exitReasonRawValue)
        }

        return exitReason
    }
}
