// generated by polka.codes
// Unit tests for JIT recompiler components
//
// NOTE: Tests that depend on incomplete C++ code have been removed.

import Foundation
@testable import PolkaVM
import Testing
import Utils

struct JITComponentTests {
    /// Helper function to create a valid blob with given code
    private func createBlob(code: Data) -> Data {
        var blob = Data()

        // Jump table entries count (0)
        let count = Data(UInt64(0).encode(method: .variableWidth))
        blob.append(contentsOf: count)

        // Encode size (0)
        blob.append(0)

        // Code length
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)

        // Jump table (empty)
        // No jump table entries

        // Code
        blob.append(contentsOf: code)

        // Bitmask (one byte per 8 code bytes, rounded up)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        return blob
    }

    // MARK: - BasicBlockBuilder Tests

    @Test func basicBlockBuilderSingleInstruction() throws {
        // Trap instruction (opcode 0, 1 byte)
        let code = Data([0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Should have one block starting at PC 0
        #expect(blocks.count == 1)
        #expect(blocks[0]?.startPC == 0)
        #expect(blocks[0]?.instructions.count == 1)
        #expect(blocks[0]?.instructions.first?.opcode == 0)
    }

    @Test func basicBlockBuilderEmptyProgram() throws {
        // Empty program
        let code = Data()
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Should have no blocks
        #expect(blocks.isEmpty)
    }

    @Test func basicBlockBuilderMultipleInstructions() throws {
        // Multiple trap instructions
        // Trap = opcode 0 (1 byte each)
        // NOTE: Trap ends basic blocks, so we get 3 separate blocks
        let code = Data([0, 0, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Trap ends each block, so we get 3 blocks
        #expect(blocks.count == 3)
        #expect(blocks[0]?.instructions.count == 1)
        #expect(blocks[1]?.instructions.count == 1)
        #expect(blocks[2]?.instructions.count == 1)

        // All should be trap instructions
        for block in blocks.values {
            #expect(block.instructions.first?.opcode == 0)
        }
    }

    @Test func basicBlockBuilderBlockEndingInstructions() throws {
        // Test that block-ending instructions create separate blocks
        // Trap (0), Jump (4) - both end blocks
        let code = Data([0, 4, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Jump instruction creates separate block
        // We should have blocks at PC 0 and PC 1
        #expect(blocks.count >= 2)
        #expect(blocks[0] != nil)
        #expect(blocks[1] != nil)
    }

    @Test func basicBlockBuilderConsecutiveTraps() throws {
        // Test many consecutive trap instructions
        // NOTE: Trap ends basic blocks, so each Trap creates a new block
        let trapCount = 100
        let code = Data(repeating: 0, count: trapCount)
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Each trap creates a separate block
        #expect(blocks.count == trapCount)

        // Verify all are traps
        for block in blocks.values {
            #expect(block.instructions.count == 1)
            #expect(block.instructions.first?.opcode == 0)
        }
    }

    @Test func basicBlockBuilderInstructionData() throws {
        // Verify instruction data is correctly extracted
        // NOTE: Trap ends basic blocks, so two Traps create two blocks
        let code = Data([0, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        #expect(blocks.count == 2)

        // Each block should have one instruction with data
        for (_, block) in blocks {
            #expect(block.instructions.count == 1)
            let instruction = try #require(block.instructions.first)
            #expect(instruction.opcode == 0)
            #expect(!instruction.data.isEmpty)
            // First byte should be the opcode
            #expect(instruction.data[0] == 0)
        }
    }

    @Test func basicBlockBuilderBranchInstructions() throws {
        // Test block detection with different block-ending instructions
        // Both Trap (0) and Fallthrough (1) are in BASIC_BLOCK_INSTRUCTIONS
        // so each instruction ends its own block
        let code = Data([0, 1, 0, 1, 0]) // Trap, Fallthrough, Trap, Fallthrough, Trap
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Each instruction creates its own block since both Trap and Fallthrough end blocks
        // Block 0: [Trap]
        // Block 1: [Fallthrough]
        // Block 2: [Trap]
        // Block 3: [Fallthrough]
        // Block 4: [Trap]
        #expect(blocks.count == 5)
        #expect(blocks[0]?.instructions.first?.opcode == 0)
        #expect(blocks[1]?.instructions.first?.opcode == 1)
        #expect(blocks[2]?.instructions.first?.opcode == 0)
        #expect(blocks[3]?.instructions.first?.opcode == 1)
        #expect(blocks[4]?.instructions.first?.opcode == 0)

        // Verify all blocks have exactly 1 instruction
        for (_, block) in blocks {
            #expect(block.instructions.count == 1)
        }
    }

    @Test func basicBlockBuilderMixedInstructions() throws {
        // Test mix of Trap and Fallthrough instructions
        // Trap (0) ends blocks, Fallthrough (1) does not
        let code = Data([0, 1, 1, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Each instruction creates its own block except fallthroughs chain
        // Block 0: [Trap]
        // Block 1: [Fallthrough]
        // Block 2: [Fallthrough]
        // Block 3: [Trap]
        #expect(blocks.count == 4)
        #expect(blocks[0]?.instructions.first?.opcode == 0)
        #expect(blocks[1]?.instructions.count == 1) // Fallthrough
        #expect(blocks[1]?.instructions[0].opcode == 1)
        #expect(blocks[2]?.instructions.count == 1) // Fallthrough
        #expect(blocks[2]?.instructions[0].opcode == 1)
        #expect(blocks[3]?.instructions.count == 1) // Trap
        #expect(blocks[3]?.instructions[0].opcode == 0)
    }

    @Test func basicBlockBuilderBlockStartPCs() throws {
        // Verify block start PCs are correctly tracked
        let code = Data([0, 4, 0, 4, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // All blocks should have valid start PCs
        for (pc, block) in blocks {
            #expect(block.startPC == pc)
            #expect(pc < UInt32(code.count))
        }
    }

    @Test func basicBlockBuilderLargeProgram() throws {
        // Test with a larger program
        let instructionCount = 1000
        let code = Data(repeating: 0, count: instructionCount)
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Should successfully process all instructions
        let totalInstructions = blocks.values.reduce(0) { $0 + $1.instructions.count }
        #expect(totalInstructions == instructionCount)
    }

    @Test func basicBlockBuilderDecodesNewlyAddedFixedWidthOpcodes() throws {
        // moveReg (100): 3-byte 2-register format
        // divU64 (203): 3-byte packed 3-register format
        // andInv (224): 4-byte 3-register format
        // trap (0): terminator
        let code = Data([
            100, 1, 2,
            203, 0x21, 3,
            224, 1, 2, 3,
            0,
        ])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // All non-terminating instructions should be in the first block.
        let block0 = try #require(blocks[0])
        #expect(block0.instructions.count == 4)
        #expect(block0.instructions[0].opcode == 100)
        #expect(block0.instructions[0].data.count == 3)
        #expect(block0.instructions[1].opcode == 203)
        #expect(block0.instructions[1].data.count == 3)
        #expect(block0.instructions[2].opcode == 224)
        #expect(block0.instructions[2].data.count == 4)
        #expect(block0.instructions[3].opcode == 0)
        #expect(block0.instructions[3].data.count == 1)
    }
}
