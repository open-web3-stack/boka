// generated by polka.codes
// Unit tests for JIT recompiler components
//
// NOTE: Tests that depend on incomplete C++ code (ProgramCode, BasicBlockBuilder)
// have been removed. Only LabelManager tests remain as it's a pure Swift actor.

import Foundation
import Testing
import Utils

@testable import PolkaVM

struct JITComponentTests {
    // Helper function to create a valid blob with given code
    private func createBlob(code: Data) -> Data {
        var blob = Data()

        // Jump table entries count (0)
        let count = Data(UInt64(0).encode(method: .variableWidth))
        blob.append(contentsOf: count)

        // Encode size (0)
        blob.append(0)

        // Code length
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)

        // Jump table (empty)
        // No jump table entries

        // Code
        blob.append(contentsOf: code)

        // Bitmask (one byte per 8 code bytes, rounded up)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        return blob
    }

    // MARK: - BasicBlockBuilder Tests

    @Test func basicBlockBuilderSingleInstruction() throws {
        // Trap instruction (opcode 0, 1 byte)
        let code = Data([0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Should have one block starting at PC 0
        #expect(blocks.count == 1)
        #expect(blocks[0]?.startPC == 0)
        #expect(blocks[0]?.instructions.count == 1)
        #expect(blocks[0]?.instructions.first?.opcode == 0)
    }

    @Test func basicBlockBuilderEmptyProgram() throws {
        // Empty program
        let code = Data()
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Should have no blocks
        #expect(blocks.isEmpty)
    }

    @Test func basicBlockBuilderMultipleInstructions() throws {
        // Multiple trap instructions
        // Trap = opcode 0 (1 byte each)
        // NOTE: Trap ends basic blocks, so we get 3 separate blocks
        let code = Data([0, 0, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Trap ends each block, so we get 3 blocks
        #expect(blocks.count == 3)
        #expect(blocks[0]?.instructions.count == 1)
        #expect(blocks[1]?.instructions.count == 1)
        #expect(blocks[2]?.instructions.count == 1)

        // All should be trap instructions
        for block in blocks.values {
            #expect(block.instructions.first?.opcode == 0)
        }
    }

    @Test func basicBlockBuilderBlockEndingInstructions() throws {
        // Test that block-ending instructions create separate blocks
        // Trap (0), Jump (4) - both end blocks
        let code = Data([0, 4, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Jump instruction creates separate block
        // We should have blocks at PC 0 and PC 1
        #expect(blocks.count >= 2)
        #expect(blocks[0] != nil)
        #expect(blocks[1] != nil)
    }

    @Test func basicBlockBuilderConsecutiveTraps() throws {
        // Test many consecutive trap instructions
        // NOTE: Trap ends basic blocks, so each Trap creates a new block
        let trapCount = 100
        let code = Data(repeating: 0, count: trapCount)
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Each trap creates a separate block
        #expect(blocks.count == trapCount)

        // Verify all are traps
        for block in blocks.values {
            #expect(block.instructions.count == 1)
            #expect(block.instructions.first?.opcode == 0)
        }
    }

    @Test func basicBlockBuilderInstructionData() throws {
        // Verify instruction data is correctly extracted
        // NOTE: Trap ends basic blocks, so two Traps create two blocks
        let code = Data([0, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        #expect(blocks.count == 2)

        // Each block should have one instruction with data
        for (pc, block) in blocks {
            #expect(block.instructions.count == 1)
            let instruction = block.instructions.first!
            #expect(instruction.opcode == 0)
            #expect(!instruction.data.isEmpty)
            // First byte should be the opcode
            #expect(instruction.data[0] == 0)
        }
    }

    @Test func basicBlockBuilderBranchInstructions() throws {
        // Test block detection with different block-ending instructions
        // Using only argless instructions for now (Trap, Fallthrough)
        // TODO: Update when instruction length calculation is fixed for branches
        let code = Data([0, 1, 0, 1, 0])  // Trap, Fallthrough, Trap, Fallthrough, Trap
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Trap (0) ends blocks, Fallthrough (1) does not
        // Block 0: [Trap] - ends at Trap
        // Block 1: [Fallthrough, Trap] - Fallthrough continues, Trap ends
        // Block 3: [Fallthrough, Trap] - Fallthrough continues, Trap ends
        #expect(blocks.count == 3)
        #expect(blocks[0]?.instructions.first?.opcode == 0)
        #expect(blocks[1]?.instructions.count == 2)
        #expect(blocks[3]?.instructions.count == 2)
    }

    @Test func basicBlockBuilderMixedInstructions() throws {
        // Test mix of Trap and Fallthrough instructions
        // Trap (0) ends blocks, Fallthrough (1) does not
        let code = Data([0, 1, 1, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Block 0: [Trap] - ends at Trap
        // Block 1: [Fallthrough, Fallthrough, Trap] - Fallthroughs continue, Trap ends
        #expect(blocks.count == 2)
        #expect(blocks[0]?.instructions.first?.opcode == 0)
        #expect(blocks[1]?.instructions.count == 3) // Two Fallthroughs + Trap
        #expect(blocks[1]?.instructions[0].opcode == 1) // First Fallthrough
        #expect(blocks[1]?.instructions[1].opcode == 1) // Second Fallthrough
        #expect(blocks[1]?.instructions[2].opcode == 0) // Trap
    }

    @Test func basicBlockBuilderBlockStartPCs() throws {
        // Verify block start PCs are correctly tracked
        let code = Data([0, 4, 0, 4, 0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // All blocks should have valid start PCs
        for (pc, block) in blocks {
            #expect(block.startPC == pc)
            #expect(pc < UInt32(code.count))
        }
    }

    @Test func basicBlockBuilderLargeProgram() throws {
        // Test with a larger program
        let instructionCount = 1000
        let code = Data(repeating: 0, count: instructionCount)
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)
        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Should successfully process all instructions
        let totalInstructions = blocks.values.reduce(0) { $0 + $1.instructions.count }
        #expect(totalInstructions == instructionCount)
    }

    // MARK: - LabelManager Tests

    @Test func labelManagerCreation() async {
        let manager = LabelManager()

        let count = await manager.count
        #expect(count == 0)
    }

    @Test func labelManagerGetOrCreateLabel() async {
        let manager = LabelManager()

        // Create label for PC 0
        let label1 = await manager.getOrCreateLabelId(for: 0)
        #expect(label1 == 0)

        let count1 = await manager.count
        #expect(count1 == 1)

        // Create label for PC 10
        let label2 = await manager.getOrCreateLabelId(for: 10)
        #expect(label2 == 1)

        let count2 = await manager.count
        #expect(count2 == 2)

        // Get existing label for PC 0
        let label1Again = await manager.getOrCreateLabelId(for: 0)
        #expect(label1Again == label1)

        let count3 = await manager.count
        #expect(count3 == 2) // No new label created
    }

    @Test func labelManagerDefineLabel() async {
        let manager = LabelManager()

        let labelId = await manager.getOrCreateLabelId(for: 0)

        let isDefined1 = await manager.isLabelDefined(labelId)
        #expect(!isDefined1)

        await manager.defineLabel(labelId)

        let isDefined2 = await manager.isLabelDefined(labelId)
        #expect(isDefined2)

        // Defining again should be idempotent
        await manager.defineLabel(labelId)

        let isDefined3 = await manager.isLabelDefined(labelId)
        #expect(isDefined3)
    }

    @Test func labelManagerGetLabelId() async {
        let manager = LabelManager()

        // Get non-existent label
        let result1 = await manager.getLabelId(for: 0)
        #expect(result1 == nil)

        // Create label
        _ = await manager.getOrCreateLabelId(for: 0)

        // Get existing label
        let result2 = await manager.getLabelId(for: 0)
        #expect(result2 != nil)
        #expect(result2 == 0)
    }

    @Test func labelManagerFixups() async {
        let manager = LabelManager()

        // Add a fixup
        await manager.addFixup(pc: 0, targetLabelId: 1, offset: 4)

        let fixups = await manager.getPendingFixups()
        #expect(fixups.count == 1)
        #expect(fixups[0].pc == 0)
        #expect(fixups[0].targetLabelId == 1)
        #expect(fixups[0].offset == 4)

        // Add another fixup
        await manager.addFixup(pc: 10, targetLabelId: 2, offset: 8)

        let fixups2 = await manager.getPendingFixups()
        #expect(fixups2.count == 2)

        // Clear fixups
        await manager.clearPendingFixups()

        let fixups3 = await manager.getPendingFixups()
        #expect(fixups3.count == 0)
    }

    @Test func labelManagerMultipleLabels() async {
        let manager = LabelManager()

        // Create multiple labels
        var labels: [UInt32] = []
        for i in 0 ..< 10 {
            let label = await manager.getOrCreateLabelId(for: UInt32(i * 10))
            labels.append(label)
        }

        let count = await manager.count
        #expect(count == 10)

        // Verify all labels are unique
        let uniqueLabels = Set(labels)
        #expect(uniqueLabels.count == 10)

        // Verify labels are sequential
        for (index, label) in labels.enumerated() {
            #expect(label == UInt32(index))
        }
    }

    @Test func labelManagerLabelLifecycle() async {
        let manager = LabelManager()

        // Test full lifecycle: create, check, define, verify
        let labelId = await manager.getOrCreateLabelId(for: 0)

        let isDefined1 = await manager.isLabelDefined(labelId)
        #expect(!isDefined1)

        let count1 = await manager.count
        #expect(count1 == 1)

        await manager.defineLabel(labelId)

        let isDefined2 = await manager.isLabelDefined(labelId)
        #expect(isDefined2)

        let count2 = await manager.count
        #expect(count2 == 1) // Count shouldn't change
    }

    @Test func labelManagerMultipleFixupsSameLabel() async {
        let manager = LabelManager()

        let labelId = await manager.getOrCreateLabelId(for: 100)

        // Add multiple fixups pointing to the same label
        await manager.addFixup(pc: 0, targetLabelId: labelId, offset: 4)
        await manager.addFixup(pc: 10, targetLabelId: labelId, offset: 8)
        await manager.addFixup(pc: 20, targetLabelId: labelId, offset: 12)

        let fixups = await manager.getPendingFixups()
        #expect(fixups.count == 3)

        // All fixups should point to the same label
        for fixup in fixups {
            #expect(fixup.targetLabelId == labelId)
        }
    }

    @Test func labelManagerFixupManagement() async {
        let manager = LabelManager()

        // Add several fixups
        await manager.addFixup(pc: 0, targetLabelId: 1, offset: 4)
        await manager.addFixup(pc: 10, targetLabelId: 2, offset: 8)
        await manager.addFixup(pc: 20, targetLabelId: 3, offset: 12)

        let fixups1 = await manager.getPendingFixups()
        #expect(fixups1.count == 3)

        // Clear and verify
        await manager.clearPendingFixups()

        let fixups2 = await manager.getPendingFixups()
        #expect(fixups2.count == 0)

        // Should be able to add new fixups after clearing
        await manager.addFixup(pc: 5, targetLabelId: 4, offset: 16)

        let fixups3 = await manager.getPendingFixups()
        #expect(fixups3.count == 1)
    }

    @Test func labelManagerLabelReuse() async {
        let manager = LabelManager()

        // Create label for PC 0
        let label1 = await manager.getOrCreateLabelId(for: 0)
        #expect(label1 == 0)

        // Try to create again - should return same label
        let label1Again = await manager.getOrCreateLabelId(for: 0)
        #expect(label1Again == label1)

        let count1 = await manager.count
        #expect(count1 == 1) // No new label created

        // Create label for different PC
        let label2 = await manager.getOrCreateLabelId(for: 100)
        #expect(label2 != label1)

        let count2 = await manager.count
        #expect(count2 == 2)
    }

    @Test func labelManagerGetNonExistentLabel() async {
        let manager = LabelManager()

        // Try to get label that doesn't exist
        let result = await manager.getLabelId(for: 999)
        #expect(result == nil)

        // Create it and verify
        _ = await manager.getOrCreateLabelId(for: 999)

        let result2 = await manager.getLabelId(for: 999)
        #expect(result2 != nil)
    }

    @Test func labelManagerDefineIdempotent() async {
        let manager = LabelManager()

        let labelId = await manager.getOrCreateLabelId(for: 0)

        // Define multiple times - should be idempotent
        await manager.defineLabel(labelId)

        let isDefined1 = await manager.isLabelDefined(labelId)
        #expect(isDefined1)

        await manager.defineLabel(labelId)

        let isDefined2 = await manager.isLabelDefined(labelId)
        #expect(isDefined2)

        await manager.defineLabel(labelId)

        let isDefined3 = await manager.isLabelDefined(labelId)
        #expect(isDefined3)
    }

    @Test func labelManagerSequentialLabelIds() async {
        let manager = LabelManager()

        // Create labels for PCs 0, 10, 20, 30, 40
        let expectedPCs = [0, 10, 20, 30, 40]
        var labelIds: [UInt32] = []

        for pc in expectedPCs {
            let labelId = await manager.getOrCreateLabelId(for: UInt32(pc))
            labelIds.append(labelId)
        }

        // Label IDs should be sequential starting from 0
        for (index, labelId) in labelIds.enumerated() {
            #expect(labelId == UInt32(index))
        }

        let count = await manager.count
        #expect(count == 5)
    }

    @Test func labelManagerForwardReferenceHandling() async {
        // Test handling of forward references (labels used before defined)
        let manager = LabelManager()

        // Create label for PC 100 (forward reference)
        let forwardLabel = await manager.getOrCreateLabelId(for: 100)

        // Add fixups that reference this label before it's defined
        await manager.addFixup(pc: 0, targetLabelId: forwardLabel, offset: 4)
        await manager.addFixup(pc: 10, targetLabelId: forwardLabel, offset: 8)

        // Label should not be defined yet
        let isDefined1 = await manager.isLabelDefined(forwardLabel)
        #expect(!isDefined1)

        // Should have pending fixups
        let fixups1 = await manager.getPendingFixups()
        #expect(fixups1.count == 2)

        // Now define the label
        await manager.defineLabel(forwardLabel)

        // Label should now be defined
        let isDefined2 = await manager.isLabelDefined(forwardLabel)
        #expect(isDefined2)

        // Fixups should still be pending (we don't auto-clear them)
        let fixups2 = await manager.getPendingFixups()
        #expect(fixups2.count == 2)

        // Clear fixups manually
        await manager.clearPendingFixups()

        let fixups3 = await manager.getPendingFixups()
        #expect(fixups3.count == 0)
    }

    @Test func labelManagerLargeScaleLabelManagement() async {
        // Test with many labels to ensure scalability
        let manager = LabelManager()
        let numLabels = 1000

        // Create many labels
        var labelIds: [UInt32] = []
        for i in 0 ..< numLabels {
            let labelId = await manager.getOrCreateLabelId(for: UInt32(i * 10))
            labelIds.append(labelId)
        }

        let count = await manager.count
        #expect(count == numLabels)

        // Verify all label IDs are unique
        let uniqueIds = Set(labelIds)
        #expect(uniqueIds.count == numLabels)

        // Verify sequential numbering
        for (index, labelId) in labelIds.enumerated() {
            #expect(labelId == UInt32(index))
        }
    }
}
