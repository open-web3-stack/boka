// generated by polka.codes
// Unit tests for JIT recompiler components
//
// NOTE: Tests that depend on incomplete C++ code (ProgramCode, BasicBlockBuilder)
// have been removed. Only LabelManager tests remain as it's a pure Swift actor.

import Foundation
import Testing
import Utils

@testable import PolkaVM

struct JITComponentTests {
    // Helper function to create a valid blob with given code
    private func createBlob(code: Data) -> Data {
        var blob = Data()

        // Jump table entries count (0)
        let count = Data(UInt64(0).encode(method: .variableWidth))
        blob.append(contentsOf: count)

        // Encode size (0)
        blob.append(0)

        // Code length
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)

        // Jump table (empty)
        // No jump table entries

        // Code
        blob.append(contentsOf: code)

        // Bitmask (one byte per 8 code bytes, rounded up)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        return blob
    }

    // MARK: - BasicBlockBuilder Tests (INVESTIGATING SIGTRAP)

    @Test func basicBlockBuilderSingleInstruction() throws {
        // Trap instruction (opcode 0, 1 byte)
        let code = Data([0])
        let blob = createBlob(code: code)

        let program = try ProgramCode(blob)

        // Simply test that we can access program.code.count
        let _ = program.code.count

        let builder = BasicBlockBuilder(program: program)
        let blocks = builder.build()

        // Should have one block starting at PC 0
        #expect(blocks.count == 1)
    }

    // MARK: - LabelManager Tests

    @Test func labelManagerCreation() async {
        let manager = LabelManager()

        let count = await manager.count
        #expect(count == 0)
    }

    @Test func labelManagerGetOrCreateLabel() async {
        let manager = LabelManager()

        // Create label for PC 0
        let label1 = await manager.getOrCreateLabelId(for: 0)
        #expect(label1 == 0)

        let count1 = await manager.count
        #expect(count1 == 1)

        // Create label for PC 10
        let label2 = await manager.getOrCreateLabelId(for: 10)
        #expect(label2 == 1)

        let count2 = await manager.count
        #expect(count2 == 2)

        // Get existing label for PC 0
        let label1Again = await manager.getOrCreateLabelId(for: 0)
        #expect(label1Again == label1)

        let count3 = await manager.count
        #expect(count3 == 2) // No new label created
    }

    @Test func labelManagerDefineLabel() async {
        let manager = LabelManager()

        let labelId = await manager.getOrCreateLabelId(for: 0)

        let isDefined1 = await manager.isLabelDefined(labelId)
        #expect(!isDefined1)

        await manager.defineLabel(labelId)

        let isDefined2 = await manager.isLabelDefined(labelId)
        #expect(isDefined2)

        // Defining again should be idempotent
        await manager.defineLabel(labelId)

        let isDefined3 = await manager.isLabelDefined(labelId)
        #expect(isDefined3)
    }

    @Test func labelManagerGetLabelId() async {
        let manager = LabelManager()

        // Get non-existent label
        let result1 = await manager.getLabelId(for: 0)
        #expect(result1 == nil)

        // Create label
        _ = await manager.getOrCreateLabelId(for: 0)

        // Get existing label
        let result2 = await manager.getLabelId(for: 0)
        #expect(result2 != nil)
        #expect(result2 == 0)
    }

    @Test func labelManagerFixups() async {
        let manager = LabelManager()

        // Add a fixup
        await manager.addFixup(pc: 0, targetLabelId: 1, offset: 4)

        let fixups = await manager.getPendingFixups()
        #expect(fixups.count == 1)
        #expect(fixups[0].pc == 0)
        #expect(fixups[0].targetLabelId == 1)
        #expect(fixups[0].offset == 4)

        // Add another fixup
        await manager.addFixup(pc: 10, targetLabelId: 2, offset: 8)

        let fixups2 = await manager.getPendingFixups()
        #expect(fixups2.count == 2)

        // Clear fixups
        await manager.clearPendingFixups()

        let fixups3 = await manager.getPendingFixups()
        #expect(fixups3.count == 0)
    }

    @Test func labelManagerMultipleLabels() async {
        let manager = LabelManager()

        // Create multiple labels
        var labels: [UInt32] = []
        for i in 0 ..< 10 {
            let label = await manager.getOrCreateLabelId(for: UInt32(i * 10))
            labels.append(label)
        }

        let count = await manager.count
        #expect(count == 10)

        // Verify all labels are unique
        let uniqueLabels = Set(labels)
        #expect(uniqueLabels.count == 10)

        // Verify labels are sequential
        for (index, label) in labels.enumerated() {
            #expect(label == UInt32(index))
        }
    }

    @Test func labelManagerLabelLifecycle() async {
        let manager = LabelManager()

        // Test full lifecycle: create, check, define, verify
        let labelId = await manager.getOrCreateLabelId(for: 0)

        let isDefined1 = await manager.isLabelDefined(labelId)
        #expect(!isDefined1)

        let count1 = await manager.count
        #expect(count1 == 1)

        await manager.defineLabel(labelId)

        let isDefined2 = await manager.isLabelDefined(labelId)
        #expect(isDefined2)

        let count2 = await manager.count
        #expect(count2 == 1) // Count shouldn't change
    }

    @Test func labelManagerMultipleFixupsSameLabel() async {
        let manager = LabelManager()

        let labelId = await manager.getOrCreateLabelId(for: 100)

        // Add multiple fixups pointing to the same label
        await manager.addFixup(pc: 0, targetLabelId: labelId, offset: 4)
        await manager.addFixup(pc: 10, targetLabelId: labelId, offset: 8)
        await manager.addFixup(pc: 20, targetLabelId: labelId, offset: 12)

        let fixups = await manager.getPendingFixups()
        #expect(fixups.count == 3)

        // All fixups should point to the same label
        for fixup in fixups {
            #expect(fixup.targetLabelId == labelId)
        }
    }

    @Test func labelManagerFixupManagement() async {
        let manager = LabelManager()

        // Add several fixups
        await manager.addFixup(pc: 0, targetLabelId: 1, offset: 4)
        await manager.addFixup(pc: 10, targetLabelId: 2, offset: 8)
        await manager.addFixup(pc: 20, targetLabelId: 3, offset: 12)

        let fixups1 = await manager.getPendingFixups()
        #expect(fixups1.count == 3)

        // Clear and verify
        await manager.clearPendingFixups()

        let fixups2 = await manager.getPendingFixups()
        #expect(fixups2.count == 0)

        // Should be able to add new fixups after clearing
        await manager.addFixup(pc: 5, targetLabelId: 4, offset: 16)

        let fixups3 = await manager.getPendingFixups()
        #expect(fixups3.count == 1)
    }

    @Test func labelManagerLabelReuse() async {
        let manager = LabelManager()

        // Create label for PC 0
        let label1 = await manager.getOrCreateLabelId(for: 0)
        #expect(label1 == 0)

        // Try to create again - should return same label
        let label1Again = await manager.getOrCreateLabelId(for: 0)
        #expect(label1Again == label1)

        let count1 = await manager.count
        #expect(count1 == 1) // No new label created

        // Create label for different PC
        let label2 = await manager.getOrCreateLabelId(for: 100)
        #expect(label2 != label1)

        let count2 = await manager.count
        #expect(count2 == 2)
    }

    @Test func labelManagerGetNonExistentLabel() async {
        let manager = LabelManager()

        // Try to get label that doesn't exist
        let result = await manager.getLabelId(for: 999)
        #expect(result == nil)

        // Create it and verify
        _ = await manager.getOrCreateLabelId(for: 999)

        let result2 = await manager.getLabelId(for: 999)
        #expect(result2 != nil)
    }

    @Test func labelManagerDefineIdempotent() async {
        let manager = LabelManager()

        let labelId = await manager.getOrCreateLabelId(for: 0)

        // Define multiple times - should be idempotent
        await manager.defineLabel(labelId)

        let isDefined1 = await manager.isLabelDefined(labelId)
        #expect(isDefined1)

        await manager.defineLabel(labelId)

        let isDefined2 = await manager.isLabelDefined(labelId)
        #expect(isDefined2)

        await manager.defineLabel(labelId)

        let isDefined3 = await manager.isLabelDefined(labelId)
        #expect(isDefined3)
    }

    @Test func labelManagerSequentialLabelIds() async {
        let manager = LabelManager()

        // Create labels for PCs 0, 10, 20, 30, 40
        let expectedPCs = [0, 10, 20, 30, 40]
        var labelIds: [UInt32] = []

        for pc in expectedPCs {
            let labelId = await manager.getOrCreateLabelId(for: UInt32(pc))
            labelIds.append(labelId)
        }

        // Label IDs should be sequential starting from 0
        for (index, labelId) in labelIds.enumerated() {
            #expect(labelId == UInt32(index))
        }

        let count = await manager.count
        #expect(count == 5)
    }

    @Test func labelManagerForwardReferenceHandling() async {
        // Test handling of forward references (labels used before defined)
        let manager = LabelManager()

        // Create label for PC 100 (forward reference)
        let forwardLabel = await manager.getOrCreateLabelId(for: 100)

        // Add fixups that reference this label before it's defined
        await manager.addFixup(pc: 0, targetLabelId: forwardLabel, offset: 4)
        await manager.addFixup(pc: 10, targetLabelId: forwardLabel, offset: 8)

        // Label should not be defined yet
        let isDefined1 = await manager.isLabelDefined(forwardLabel)
        #expect(!isDefined1)

        // Should have pending fixups
        let fixups1 = await manager.getPendingFixups()
        #expect(fixups1.count == 2)

        // Now define the label
        await manager.defineLabel(forwardLabel)

        // Label should now be defined
        let isDefined2 = await manager.isLabelDefined(forwardLabel)
        #expect(isDefined2)

        // Fixups should still be pending (we don't auto-clear them)
        let fixups2 = await manager.getPendingFixups()
        #expect(fixups2.count == 2)

        // Clear fixups manually
        await manager.clearPendingFixups()

        let fixups3 = await manager.getPendingFixups()
        #expect(fixups3.count == 0)
    }

    @Test func labelManagerLargeScaleLabelManagement() async {
        // Test with many labels to ensure scalability
        let manager = LabelManager()
        let numLabels = 1000

        // Create many labels
        var labelIds: [UInt32] = []
        for i in 0 ..< numLabels {
            let labelId = await manager.getOrCreateLabelId(for: UInt32(i * 10))
            labelIds.append(labelId)
        }

        let count = await manager.count
        #expect(count == numLabels)

        // Verify all label IDs are unique
        let uniqueIds = Set(labelIds)
        #expect(uniqueIds.count == numLabels)

        // Verify sequential numbering
        for (index, labelId) in labelIds.enumerated() {
            #expect(labelId == UInt32(index))
        }
    }
}
