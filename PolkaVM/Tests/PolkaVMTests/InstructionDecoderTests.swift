// generated by polka.codes
// Unit tests for C++ instruction decoder functions
//
// These tests verify the C++ instruction decoder functions in:
// - instruction_decoder.cpp: decode_load_imm_64, decode_load_u8, etc.
// - instruction_dispatcher.cpp: additional decoder functions

import Foundation
import Testing
import Utils

@testable import PolkaVM

@Suite(.serialized)
struct InstructionDecoderTests {
    // MARK: - Load Immediate Instruction Decoder Tests

    @Test func decodeLoadImm64_CorrectFormat() throws {
        // Test LoadImm64 instruction decoding
        // Format: [opcode][reg_index][value_64bit]
        // Expected size: 1 + 1 + 8 = 10 bytes

        let bytecode: [UInt8] = [
            0x03,       // opcode (example for LoadImm64)
            0x05,       // dest_reg = 5
            0xEF, 0xBE, 0xAD, 0xDE, 0x00, 0x00, 0x00, 0x00  // immediate = 0xDEADBEEF
        ]

        // Expected decoded values:
        // - opcode: 0x03
        // - dest_reg: 5
        // - immediate: 0xDEADBEEF
        // - size: 10

        // TODO: Call C++ decoder function when interface is exposed
        // For now, verify the expected format
        #expect(bytecode[0] == 0x03)
        #expect(bytecode[1] == 0x05)

        let immediate = bytecode.withUnsafeBytes { ptr -> UInt64 in
            return ptr.load(fromByteOffset: 2, as: UInt64.self)
        }
        #expect(immediate == 0xDEADBEEF)
    }

    @Test func decodeLoadImm32_CorrectFormat() throws {
        // Test LoadImm instruction decoding
        // Format: [opcode][reg_index][value_32bit]
        // Expected size: 1 + 1 + 4 = 6 bytes

        let bytecode: [UInt8] = [
            0x01,       // opcode (example for LoadImm)
            0x02,       // dest_reg = 2
            0x78, 0x56, 0x34, 0x12  // immediate = 0x12345678
        ]

        // Expected decoded values:
        // - opcode: 0x01
        // - dest_reg: 2
        // - immediate: 0x12345678 (sign-extended to 64-bit)
        // - size: 6

        let immediate = bytecode.withUnsafeBytes { ptr -> UInt32 in
            return ptr.load(fromByteOffset: 2, as: UInt32.self)
        }
        #expect(immediate == 0x12345678)
    }

    // MARK: - Load from Memory Instruction Decoder Tests

    @Test func decodeLoadU8_CorrectFormat() throws {
        // Test LoadU8 instruction decoding
        // Format: [opcode][reg_index][address_32bit]
        // Expected size: 6 bytes

        let bytecode: [UInt8] = [
            0x10,       // opcode (example for LoadU8)
            0x03,       // dest_reg = 3
            0x00, 0x10, 0x00, 0x00  // address = 0x1000
        ]

        // Expected decoded values:
        // - opcode: 0x10
        // - dest_reg: 3
        // - address: 0x1000
        // - size: 6

        let address = bytecode.withUnsafeBytes { ptr -> UInt32 in
            return ptr.load(fromByteOffset: 2, as: UInt32.self)
        }
        #expect(address == 0x1000)
    }

    @Test func decodeLoadI8_CorrectFormat() throws {
        // Test LoadI8 instruction decoding (sign-extending load)
        // Format: [opcode][reg_index][address_32bit]
        // Expected size: 6 bytes

        let bytecode: [UInt8] = [
            0x11,       // opcode (example for LoadI8)
            0x04,       // dest_reg = 4
            0x00, 0x20, 0x00, 0x00  // address = 0x2000
        ]

        let address = bytecode.withUnsafeBytes { ptr -> UInt32 in
            return ptr.load(fromByteOffset: 2, as: UInt32.self)
        }
        #expect(address == 0x2000)
    }

    @Test func decodeLoadU16_CorrectFormat() throws {
        // Test LoadU16 instruction decoding
        // Format: [opcode][reg_index][address_32bit]
        // Expected size: 6 bytes

        let bytecode: [UInt8] = [
            0x12,       // opcode (example for LoadU16)
            0x01,       // dest_reg = 1
            0x00, 0x30, 0x00, 0x00  // address = 0x3000
        ]

        let address = bytecode.withUnsafeBytes { ptr -> UInt32 in
            return ptr.load(fromByteOffset: 2, as: UInt32.self)
        }
        #expect(address == 0x3000)
    }

    @Test func decodeLoadU32_CorrectFormat() throws {
        // Test LoadU32 instruction decoding
        // Format: [opcode][reg_index][address_32bit]
        // Expected size: 6 bytes

        let bytecode: [UInt8] = [
            0x14,       // opcode (example for LoadU32)
            0x07,       // dest_reg = 7
            0x00, 0x40, 0x00, 0x00  // address = 0x4000
        ]

        let address = bytecode.withUnsafeBytes { ptr -> UInt32 in
            return ptr.load(fromByteOffset: 2, as: UInt32.self)
        }
        #expect(address == 0x4000)
    }

    @Test func decodeLoadU64_CorrectFormat() throws {
        // Test LoadU64 instruction decoding
        // Format: [opcode][reg_index][address_32bit]
        // Expected size: 6 bytes

        let bytecode: [UInt8] = [
            0x16,       // opcode (example for LoadU64)
            0x00,       // dest_reg = 0
            0x00, 0x50, 0x00, 0x00  // address = 0x5000
        ]

        let address = bytecode.withUnsafeBytes { ptr -> UInt32 in
            return ptr.load(fromByteOffset: 2, as: UInt32.self)
        }
        #expect(address == 0x5000)
    }

    // MARK: - Arithmetic Instruction Decoder Tests

    @Test func decodeAdd32_CorrectFormat() throws {
        // Test Add32 instruction decoding
        // Format: [opcode][dest_reg][src_reg]
        // Expected size: 3 bytes

        let bytecode: [UInt8] = [
            0x80,       // opcode (example for Add32)
            0x01,       // dest_reg = 1
            0x02        // src_reg = 2
        ]

        // Expected decoded values:
        // - opcode: 0x80
        // - dest_reg: 1
        // - src_reg: 2
        // - size: 3

        #expect(bytecode[0] == 0x80)
        #expect(bytecode[1] == 0x01)
        #expect(bytecode[2] == 0x02)
    }

    @Test func decodeSub32_CorrectFormat() throws {
        // Test Sub32 instruction decoding
        // Format: [opcode][dest_reg][src_reg]
        // Expected size: 3 bytes

        let bytecode: [UInt8] = [
            0x81,       // opcode (example for Sub32)
            0x03,       // dest_reg = 3
            0x04        // src_reg = 4
        ]

        #expect(bytecode[0] == 0x81)
        #expect(bytecode[1] == 0x03)
        #expect(bytecode[2] == 0x04)
    }

    // MARK: - Control Flow Instruction Decoder Tests

    @Test func decodeJump_CorrectFormat() throws {
        // Test Jump instruction decoding
        // Format: [opcode][offset_32bit]
        // Expected size: 5 bytes
        // Target PC = current PC + 5 + offset (PC-relative)

        let bytecode: [UInt8] = [
            0x20,       // opcode (example for Jump)
            0x10, 0x00, 0x00, 0x00  // offset = +16
        ]

        // Expected decoded values:
        // - opcode: 0x20
        // - offset: 16
        // - target_pc: current_pc + 5 + 16

        let offset = bytecode.withUnsafeBytes { ptr -> Int32 in
            return ptr.load(fromByteOffset: 1, as: Int32.self)
        }
        #expect(offset == 16)

        // If current_pc = 0, target_pc = 0 + 5 + 16 = 21
        let current_pc: UInt32 = 0
        let target_pc = current_pc + 5 + UInt32(bitPattern: offset)
        #expect(target_pc == 21)
    }

    @Test func decodeJump_NegativeOffset() throws {
        // Test Jump instruction with negative offset (backward jump)

        let bytecode: [UInt8] = [
            0x20,       // opcode
            0xF0, 0xFF, 0xFF, 0xFF  // offset = -16 (in two's complement)
        ]

        let offset = bytecode.withUnsafeBytes { ptr -> Int32 in
            return ptr.load(fromByteOffset: 1, as: Int32.self)
        }
        #expect(offset == -16)

        // If current_pc = 100, target_pc = 100 + 5 - 16 = 89
        let current_pc: UInt32 = 100
        let target_pc = Int32(current_pc) + 5 + offset
        #expect(target_pc == 89)
    }

    @Test func decodeTrap_CorrectFormat() throws {
        // Test Trap instruction decoding
        // Format: [opcode]
        // Expected size: 1 byte

        let bytecode: [UInt8] = [0x00]  // opcode for Trap

        // Expected decoded values:
        // - opcode: 0x00
        // - size: 1

        #expect(bytecode[0] == 0x00)
        #expect(bytecode.count == 1)
    }

    @Test func decodeFallthrough_CorrectFormat() throws {
        // Test Fallthrough instruction decoding
        // Format: [opcode]
        // Expected size: 1 byte

        let bytecode: [UInt8] = [0xFF]  // opcode for Fallthrough (example)

        // Expected decoded values:
        // - opcode: 0xFF
        // - size: 1

        #expect(bytecode[0] == 0xFF)
        #expect(bytecode.count == 1)
    }

    // MARK: - Store Immediate Instruction Decoder Tests

    @Test func decodeStoreImmU8_CorrectFormat() throws {
        // Test StoreImmU8 instruction decoding
        // Format: [opcode][value_8bit][address_32bit]
        // Expected size: 1 + 1 + 4 = 6 bytes

        let bytecode: [UInt8] = [
            0x30,       // opcode (example for StoreImmU8)
            0x42,       // value = 0x42
            0x00, 0x60, 0x00, 0x00  // address = 0x6000
        ]

        // Expected decoded values:
        // - opcode: 0x30
        // - immediate: 0x42
        // - address: 0x6000
        // - size: 6

        #expect(bytecode[1] == 0x42)

        let address = bytecode.withUnsafeBytes { ptr -> UInt32 in
            return ptr.load(fromByteOffset: 2, as: UInt32.self)
        }
        #expect(address == 0x6000)
    }

    @Test func decodeStoreImmU16_CorrectFormat() throws {
        // Test StoreImmU16 instruction decoding
        // Format: [opcode][value_16bit][address_32bit]
        // Expected size: 1 + 2 + 4 = 7 bytes

        let bytecode: [UInt8] = [
            0x31,       // opcode (example for StoreImmU16)
            0x34, 0x12, // value = 0x1234
            0x00, 0x70, 0x00, 0x00  // address = 0x7000
        ]

        #expect(bytecode.count == 7)

        let value = bytecode.withUnsafeBytes { ptr -> UInt16 in
            return ptr.load(fromByteOffset: 1, as: UInt16.self)
        }
        #expect(value == 0x1234)

        let address = bytecode.withUnsafeBytes { ptr -> UInt32 in
            return ptr.load(fromByteOffset: 3, as: UInt32.self)
        }
        #expect(address == 0x7000)
    }

    // MARK: - Edge Cases and Error Handling

    @Test func decodeInstruction_InvalidOpcode() throws {
        // Test handling of invalid opcode
        // The decoder should handle unknown opcodes gracefully

        let bytecode: [UInt8] = [0xEE]  // Unknown opcode

        // Expected: Decoder should identify this as an invalid instruction
        // or return an error
        #expect(bytecode[0] == 0xEE)

        // TODO: Call C++ decoder function and verify error handling
        // when interface is exposed
    }

    @Test func decodeInstruction_InsufficientBytes() throws {
        // Test handling of incomplete instruction
        // E.g., a LoadImm32 instruction with only 4 bytes instead of 6

        let bytecode: [UInt8] = [
            0x01,       // opcode (LoadImm32 format)
            0x02,       // dest_reg
            0x78, 0x56  // incomplete immediate (missing 2 bytes)
        ]

        // Expected: Decoder should detect insufficient bytes
        // and return an error or indicate invalid instruction
        #expect(bytecode.count < 6)

        // TODO: Call C++ decoder function and verify error handling
        // when interface is exposed
    }

    @Test func decodeInstruction_LargeImmediate() throws {
        // Test decoding instruction with maximum 64-bit immediate value

        let bytecode: [UInt8] = [
            0x03,       // opcode (LoadImm64)
            0x05,       // dest_reg = 5
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  // immediate = UINT64_MAX
        ]

        let immediate = bytecode.withUnsafeBytes { ptr -> UInt64 in
            return ptr.load(fromByteOffset: 2, as: UInt64.self)
        }
        #expect(immediate == UInt64.max)
    }

    @Test func decodeInstruction_ZeroRegister() throws {
        // Test decoding instruction with register index 0 (valid)

        let bytecode: [UInt8] = [
            0x01,       // opcode (LoadImm32)
            0x00,       // dest_reg = 0 (valid)
            0x00, 0x00, 0x00, 0x00  // immediate = 0
        ]

        #expect(bytecode[1] == 0x00)
    }

    @Test func decodeInstruction_MaxRegister() throws {
        // Test decoding instruction with maximum register index
        // Assuming max 256 registers (0-255)

        let bytecode: [UInt8] = [
            0x01,       // opcode (LoadImm32)
            0xFF,       // dest_reg = 255 (max valid)
            0x00, 0x00, 0x00, 0x00  // immediate = 0
        ]

        #expect(bytecode[1] == 0xFF)
    }

    // MARK: - Instruction Size Validation

    @Test func validateInstructionSize_Trap() {
        // Trap instruction is always 1 byte
        #expect(1 == 1)  // opcode only
    }

    @Test func validateInstructionSize_LoadImm32() {
        // LoadImm32: 1 (opcode) + 1 (reg) + 4 (imm) = 6 bytes
        #expect(1 + 1 + 4 == 6)
    }

    @Test func validateInstructionSize_LoadImm64() {
        // LoadImm64: 1 (opcode) + 1 (reg) + 8 (imm) = 10 bytes
        #expect(1 + 1 + 8 == 10)
    }

    @Test func validateInstructionSize_Jump() {
        // Jump: 1 (opcode) + 4 (offset) = 5 bytes
        #expect(1 + 4 == 5)
    }

    @Test func validateInstructionSize_Add32() {
        // Add32: 1 (opcode) + 1 (dest) + 1 (src) = 3 bytes
        #expect(1 + 1 + 1 == 3)
    }
}
