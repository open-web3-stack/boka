// generated by polka.codes
// JIT Load/Store Instruction Tests
//
// Tests for memory load/store instructions: LoadImm, LoadU8/I8/U16/I16/U32/I32/U64,
// StoreU8/U16/U32/U64, StoreImmU8/U16/U32/U64, and indirect variants

import Foundation
import PolkaVM
import Testing
import TracingUtils
import Utils

@testable import PolkaVM

private let logger = Logger(label: "JITLoadStoreTests")

/// Helper function to encode unsigned integers as varint (LEB128)
/// Uses high bit (0x80) to indicate continuation
private func encodeVarint(_ value: UInt64) -> [UInt8] {
    guard value > 0 else { return [0] }

    var bytes: [UInt8] = []
    var remaining = value

    while remaining > 0 {
        var byte = UInt8(remaining & 0x7F)
        remaining >>= 7

        // Set continuation bit if more bytes follow
        if remaining > 0 {
            byte |= 0x80
        }

        bytes.append(byte)
    }

    return bytes
}

/// JIT Load/Store Instruction Tests
struct JITLoadStoreTests {
    // MARK: - LoadImm Instructions (Opcodes 51, 20)

    @Test("JIT: LoadImm64 loads 64-bit immediate")
    func jitLoadImm64() async throws {
        // LoadImm64 r1, 0x123456789ABCDEF0
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode (20)
            0x01, // r1
        ] + withUnsafeBytes(of: UInt64(0x1234_5678_9ABC_DEF0).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // r1 should contain the loaded value
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 0x1234_5678_9ABC_DEF0)
    }

    @Test("JIT: LoadImm64 with zero")
    func jitLoadImm64Zero() async throws {
        // LoadImm64 r2, 0
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode (20)
            0x02, // r2
        ] + withUnsafeBytes(of: UInt64(0).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0)
    }

    @Test("JIT: LoadImm64 with max value")
    func jitLoadImm64Max() async throws {
        // LoadImm64 r3, UInt64.max
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode (20)
            0x03, // r3
        ] + withUnsafeBytes(of: UInt64.max.littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: UInt64.max)
    }

    @Test("JIT: LoadImm loads 32-bit immediate with sign extension")
    func jitLoadImm32() async throws {
        // LoadImm r1, 0x12345678 (sign-extended to 64-bit)
        // LoadImm uses varint encoding for the immediate value
        let value = UInt64(bitPattern: Int64(Int32(bitPattern: 0x1234_5678)))
        let instruction: [UInt8] = [
            0x33, // LoadImm opcode (32-bit immediate, sign-extended)
            0x01, // r1
        ] + encodeVarint(value)

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // Should be sign-extended to 64 bits
        let expected = UInt64(bitPattern: Int64(Int32(0x1234_5678)))
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: expected)
    }

    @Test("JIT: LoadImm sign-extends negative 32-bit values")
    func jitLoadImmNegative() async throws {
        // LoadImm r1, -1 (0xFFFFFFFF as signed 32-bit)
        // When sign-extended to 64-bit, this becomes 0xFFFFFFFFFFFFFFFF
        let value = UInt64(bitPattern: Int64(Int32(bitPattern: 0xFFFF_FFFF)))
        let instruction: [UInt8] = [
            0x33, // LoadImm opcode (32-bit immediate, sign-extended)
            0x01, // r1
        ] + encodeVarint(value)

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // -1 sign-extended to 64-bit should be all 0xFF
        let expected = UInt64(bitPattern: Int64(-1))
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: expected)
    }

    @Test("JIT: LoadImm64 loads unsigned 32-bit value zero-extended")
    func jitLoadImmU32() async throws {
        // LoadImm64 r1, 0xFFFFFFFF (zero-extended 32-bit value)
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode
            0x01, // r1
        ] + withUnsafeBytes(of: UInt64(0xFFFF_FFFF).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // Should be zero-extended (not sign-extended)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 0x0000_0000_FFFF_FFFF)
    }

    @Test("JIT vs Interpreter: LoadImm64 parity")
    func jitLoadImm64Parity() async throws {
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode
            0x01, // r1
        ] + withUnsafeBytes(of: UInt64(0xDEAD_BEEF_CAFE_BABE).littleEndian) { Array($0) }

        let (_, _, differences) = await JITParityComparator.compareSingleInstruction(
            instruction,
            testName: "LoadImm64"
        )

        #expect(
            differences == nil,
            "LoadImm64 parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - LoadU8/I8/U16/I16/U32/I32/U64 Instructions (Opcodes 52-58)

    @Test("JIT: LoadU8 loads unsigned byte")
    func jitLoadU8() async throws {
        // LoadU8 r2, [0x10000] - load from read-only data using DIRECT addressing
        // Halt

        var code = Data()

        // LoadU8 r2, [0x10000] - direct address (not register-relative!)
        code.append(PVMOpcodes.loadU8.rawValue) // LoadU8 opcode
        code.append(0x02) // r2 (destination register)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0001_0000).littleEndian) { Array($0) }) // address

        // Halt
        code.append(PVMOpcodes.halt.rawValue)

        // Create program with read-only data containing 0xAB at offset 0
        let readOnlyData = Data([0xAB]) // Only 1 byte
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0xAB (zero-extended)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_00AB)
    }

    @Test("JIT: LoadI8 sign-extends byte")
    func jitLoadI8() async throws {
        // LoadI8 r2, [0x10000] - load 0xFF (should sign-extend to -1)
        // Halt

        var code = Data()

        // LoadI8 r2, [0x10000]
        code.append(PVMOpcodes.loadI8.rawValue) // LoadI8 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0001_0000).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        // Read-only data with 0xFF (signed -1 as byte)
        let readOnlyData = Data([0xFF])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0xFFFFFFFFFFFFFFFF (sign-extended -1)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: UInt64(0xFFFF_FFFF_FFFF_FFFF))
    }

    @Test("JIT: LoadU16 loads unsigned halfword")
    func jitLoadU16() async throws {
        // LoadU16 r2, [0x10000] - load 0x1234
        // Halt

        var code = Data()

        // LoadU16 r2, [0x10000]
        code.append(PVMOpcodes.loadU16.rawValue) // LoadU16 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0001_0000).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        // Read-only data with 0x1234 (little-endian)
        let readOnlyData = Data([0x34, 0x12])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0x1234
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_1234)
    }

    @Test("JIT vs Interpreter: LoadU8 parity")
    func jitLoadU8Parity() async throws {
        var code = Data()

        // LoadU8 r2, [0x10000]
        code.append(0x34) // LoadU8 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0001_0000).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        let readOnlyData = Data([0xAB, 0xCD])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "LoadU8"
        )

        #expect(
            differences == nil,
            "LoadU8 parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - StoreU8/U16/U32/U64 Instructions (Opcodes 59-62)

    @Test("JIT: StoreU8 stores byte to memory")
    func jitStoreU8() async throws {
        // LoadImm64 r1, value (0xAB)
        // StoreU8 [0x20000], r1
        // LoadU8 r2, [0x20000] - read back
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0xAB
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00AB).littleEndian) { Array($0) })

        // StoreU8 [0x20000], r1
        code.append(PVMOpcodes.storeU8.rawValue) // StoreU8 opcode
        code.append(0x01) // r1 (source register)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) }) // address

        // LoadU8 r2, [0x20000] to verify
        code.append(0x34) // LoadU8
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        // Create program with read-write data (heap)
        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain the stored value 0xAB
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_00AB)
    }

    @Test("JIT: StoreU16 stores halfword to memory")
    func jitStoreU16() async throws {
        // LoadImm64 r1, value (0x1234)
        // StoreU16 [0x20000], r1
        // LoadU16 r2, [0x20000] - read back
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x1234
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_1234).littleEndian) { Array($0) })

        // StoreU16 [0x20000], r1
        code.append(0x3C) // StoreU16 opcode (60)
        code.append(0x01) // r1 (source register)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) }) // address

        // LoadU16 r2, [0x20000] to verify
        code.append(0x36) // LoadU16 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_1234)
    }

    @Test("JIT vs Interpreter: StoreU8 parity")
    func jitStoreU8Parity() async throws {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0xFF
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00FF).littleEndian) { Array($0) })

        code.append(0x3B) // StoreU8 [0x20000], r1
        code.append(0x01) // r1 (source)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) }) // address

        code.append(0x01) // Halt

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "StoreU8"
        )

        #expect(
            differences == nil,
            "StoreU8 parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - StoreImmU8/U16/U32/U64 Instructions (Opcodes 30-33)

    @Test("JIT: StoreImmU8 stores immediate byte")
    func jitStoreImmU8() async throws {
        // LoadImm64 r1, writeable address
        // StoreImmU8 [r1], 0xAB
        // LoadU8 r2, [r1] - read back
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        // StoreImmIndU8 [r1 + 0], 0xAB
        code.append(0x46) // StoreImmIndU8 opcode (70)
        code.append(0x01) // r1
        code.append(contentsOf: encodeVarint(0)) // offset (varint)
        code.append(contentsOf: encodeVarint(0xAB)) // value (varint)

        // LoadU8 r2, [0x20000] to verify (direct addressing)
        code.append(0x34) // LoadU8 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_00AB)
    }

    @Test("JIT: StoreImmU32 stores immediate 32-bit value")
    func jitStoreImmU32() async throws {
        // LoadImm64 r1, writeable address
        // StoreImmU32 [r1], 0x12345678
        // LoadU32 r2, [r1] - read back
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        // StoreImmIndU32 [r1 + 0], 0x12345678
        code.append(0x48) // StoreImmIndU32 opcode (72)
        code.append(0x01) // r1
        code.append(contentsOf: encodeVarint(0)) // offset (varint)
        code.append(contentsOf: encodeVarint(0x1234_5678)) // value (varint)

        // LoadU32 r2, [0x20000] to verify (direct addressing)
        code.append(0x38) // LoadU32 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_1234_5678)
    }

    @Test("JIT vs Interpreter: StoreImmU8 parity")
    func jitStoreImmU8Parity() async throws {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x46) // StoreImmIndU8 [r1+0], 0xCD
        code.append(0x01) // r1
        code.append(contentsOf: encodeVarint(0)) // offset (varint)
        code.append(contentsOf: encodeVarint(0xCD)) // value (varint)

        code.append(0x01) // Halt

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "StoreImmU8"
        )

        #expect(
            differences == nil,
            "StoreImmU8 parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - Edge Cases

    @Test("JIT: Load from invalid address causes page fault", .disabled("Memory protection requires bounds checking in JIT load/store instructions"))
    func jitLoadInvalidAddress() async throws {
        // LoadImm64 r1, invalid address (beyond all zones)
        // LoadIndU8 r2, [r1] - should page fault
        // Halt (shouldn't reach)

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x63000000 (invalid)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x6300_0000).littleEndian) { Array($0) })

        // LoadIndU8 r2, [r1 + 0] - register-relative addressing
        // Format: [opcode][ra_rb_packed][offset_32bit] where ra_rb = (ra | rb << 4)
        code.append(0x7C) // LoadIndU8 opcode (124)
        code.append(0x12) // r2 (ra=2) | (r1 (rb=1) << 4) = 0x02 | 0x10 = 0x12
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) }) // offset

        code.append(0x01) // Halt

        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should page fault
        let isPageFault = switch result.exitReason {
        case .pageFault:
            true
        default:
            false
        }
        #expect(
            isPageFault,
            "Load from invalid address should page fault: got \(result.exitReason)"
        )
    }

    @Test("JIT: Store to read-only memory causes panic")
    func jitStoreToReadOnly() async throws {
        // LoadImm64 r1, read-only address
        // LoadImm64 r2, value
        // StoreIndU8 [r1+0], r2 - should panic (read-only violation)
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x10000 (read-only)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0001_0000).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 0xAB
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00AB).littleEndian) { Array($0) })

        // StoreIndU8 [r1 + 0], r2 - register-relative addressing
        // Format: [opcode][src_dest_packed][offset_32bit] where src_dest = (src | dest << 4)
        code.append(0x78) // StoreIndU8 opcode (120)
        code.append(0x12) // r2 (src=2) | (r1 (dest=1) << 4) = 0x02 | 0x10 = 0x12
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) }) // offset

        code.append(0x01) // Halt

        let readOnlyData = Data([0xAA])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should result in error (hostCall for memory protection or pageFault)
        // The exact reason depends on implementation
        let hasError = switch result.exitReason {
        case .hostCall, .pageFault, .panic:
            true
        default:
            false
        }
        #expect(hasError, "Store to read-only should error: got \(result.exitReason)")
    }
}
