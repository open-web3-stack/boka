// generated by polka.codes
// JIT Load/Store Instruction Tests
//
// Tests for memory load/store instructions: LoadImm, LoadU8/I8/U16/I16/U32/I32/U64,
// StoreU8/U16/U32/U64, StoreImmU8/U16/U32/U64, and indirect variants

import Foundation
@testable import PolkaVM
import Testing
import TracingUtils
import Utils

private let logger = Logger(label: "JITLoadStoreTests")

/// Encode a signed immediate in compact little-endian form.
/// Length must be 1...4 to match PVM compact immediate operands.
private func encodeCompactImmediate(_ value: Int32, length: Int) -> [UInt8] {
    precondition((1 ... 4).contains(length))
    let raw = UInt32(bitPattern: value)
    return (0 ..< length).map { i in
        UInt8(truncatingIfNeeded: raw >> (i * 8))
    }
}

/// JIT Load/Store Instruction Tests
@Suite
struct JITLoadStoreTests {
    // MARK: - LoadImm Instructions (Opcodes 51, 20)

    @Test
    func jitLoadImm64() async {
        // LoadImm64 r1, 0x123456789ABCDEF0
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode (20)
            0x01, // r1
        ] + withUnsafeBytes(of: UInt64(0x1234_5678_9ABC_DEF0).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // r1 should contain the loaded value
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 0x1234_5678_9ABC_DEF0)
    }

    @Test
    func jitLoadImm64Zero() async {
        // LoadImm64 r2, 0
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode (20)
            0x02, // r2
        ] + withUnsafeBytes(of: UInt64(0).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0)
    }

    @Test
    func jitLoadImm64Max() async {
        // LoadImm64 r3, UInt64.max
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode (20)
            0x03, // r3
        ] + withUnsafeBytes(of: UInt64.max.littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: UInt64.max)
    }

    @Test
    func jitLoadImm32() async {
        // LoadImm r1, 0x12345678 (sign-extended to 64-bit)
        // LoadImm format: [opcode][reg_index][value_32bit] (6 bytes total)
        let value = Int32(0x1234_5678)
        let instruction: [UInt8] = [
            0x33, // LoadImm opcode (32-bit immediate, sign-extended)
            0x01, // r1
        ] + withUnsafeBytes(of: value.littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // Should be sign-extended to 64 bits
        let expected = UInt64(bitPattern: Int64(Int32(0x1234_5678)))
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: expected)
    }

    @Test
    func jitLoadImmNegative() async {
        // LoadImm r1, -1 (0xFFFFFFFF as signed 32-bit)
        // LoadImm format: [opcode][reg_index][value_32bit] (6 bytes total)
        // When sign-extended to 64-bit, this becomes 0xFFFFFFFFFFFFFFFF
        let value = Int32(-1) // 0xFFFFFFFF
        let instruction: [UInt8] = [
            0x33, // LoadImm opcode (32-bit immediate, sign-extended)
            0x01, // r1
        ] + withUnsafeBytes(of: value.littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // -1 sign-extended to 64-bit should be all 0xFF
        let expected = UInt64(bitPattern: Int64(-1))
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: expected)
    }

    @Test
    func jitLoadImmU32() async {
        // LoadImm64 r1, 0xFFFFFFFF (zero-extended 32-bit value)
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode
            0x01, // r1
        ] + withUnsafeBytes(of: UInt64(0xFFFF_FFFF).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // Should be zero-extended (not sign-extended)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 0x0000_0000_FFFF_FFFF)
    }

    @Test
    func jitLoadImm64Parity() async {
        let instruction: [UInt8] = [
            0x14, // LoadImm64 opcode
            0x01, // r1
        ] + withUnsafeBytes(of: UInt64(0xDEAD_BEEF_CAFE_BABE).littleEndian) { Array($0) }

        let (_, _, differences) = await JITParityComparator.compareSingleInstruction(
            instruction,
            testName: "LoadImm64",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - LoadU8/I8/U16/I16/U32/I32/U64 Instructions (Opcodes 52-58)

    @Test
    func jitLoadU8() async {
        // LoadU8 r2, [0x10000] - load from read-only data using DIRECT addressing
        // Halt

        var code = Data()

        // LoadU8 r2, [0x10000] - direct address (not register-relative!)
        code.append(PVMOpcodes.loadU8.rawValue) // LoadU8 opcode
        code.append(0x02) // r2 (destination register)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0001_0000).littleEndian) { Array($0) }) // address

        // Halt
        code.append(PVMOpcodes.halt.rawValue)

        // Create program with read-only data containing 0xAB at offset 0
        let readOnlyData = Data([0xAB]) // Only 1 byte
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0xAB (zero-extended)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_00AB)
    }

    @Test
    func jitLoadI8() async {
        // LoadI8 r2, [0x10000] - load 0xFF (should sign-extend to -1)
        // Halt

        var code = Data()

        // LoadI8 r2, [0x10000]
        code.append(PVMOpcodes.loadI8.rawValue) // LoadI8 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0001_0000).littleEndian) { Array($0) })

        code.append(0x00) // Trap (proper termination per spec)

        // Read-only data with 0xFF (signed -1 as byte)
        let readOnlyData = Data([0xFF])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0xFFFFFFFFFFFFFFFF (sign-extended -1)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: UInt64(0xFFFF_FFFF_FFFF_FFFF))
    }

    @Test
    func jitLoadU16() async {
        // LoadU16 r2, [0x10000] - load 0x1234
        // Halt

        var code = Data()

        // LoadU16 r2, [0x10000]
        code.append(PVMOpcodes.loadU16.rawValue) // LoadU16 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0001_0000).littleEndian) { Array($0) })

        code.append(0x00) // Trap (proper termination per spec)

        // Read-only data with 0x1234 (little-endian)
        let readOnlyData = Data([0x34, 0x12])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0x1234
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_1234)
    }

    @Test
    func jitLoadU8Parity() async {
        var code = Data()

        // LoadU8 r2, [0x10000]
        code.append(0x34) // LoadU8 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0001_0000).littleEndian) { Array($0) })

        code.append(0x00) // Trap (proper termination per spec)

        let readOnlyData = Data([0xAB, 0xCD])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0,
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "LoadU8",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - StoreU8/U16/U32/U64 Instructions (Opcodes 59-62)

    @Test
    func jitStoreU8() async {
        // LoadImm64 r1, value (0xAB)
        // StoreU8 [0x20000], r1
        // LoadU8 r2, [0x20000] - read back
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0xAB
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00AB).littleEndian) { Array($0) })

        // StoreU8 [0x20000], r1
        code.append(PVMOpcodes.storeU8.rawValue) // StoreU8 opcode
        code.append(0x01) // r1 (source register)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) }) // address

        // LoadU8 r2, [0x20000] to verify
        code.append(0x34) // LoadU8
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x00) // Trap (proper termination per spec)

        // Create program with read-write data (heap)
        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain the stored value 0xAB
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_00AB)
    }

    @Test
    func jitStoreU16() async {
        // LoadImm64 r1, value (0x1234)
        // StoreU16 [0x20000], r1
        // LoadU16 r2, [0x20000] - read back
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x1234
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_1234).littleEndian) { Array($0) })

        // StoreU16 [0x20000], r1
        code.append(0x3C) // StoreU16 opcode (60)
        code.append(0x01) // r1 (source register)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) }) // address

        // LoadU16 r2, [0x20000] to verify
        code.append(0x36) // LoadU16 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x00) // Trap (proper termination per spec)

        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_1234)
    }

    @Test
    func jitStoreU8Parity() async {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0xFF
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00FF).littleEndian) { Array($0) })

        code.append(0x3B) // StoreU8 [0x20000], r1
        code.append(0x01) // r1 (source)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) }) // address

        code.append(0x00) // Trap (proper termination per spec)

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0,
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "StoreU8",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - StoreImmU8/U16/U32/U64 Instructions (Opcodes 30-33)

    @Test
    func jitStoreImmU8() async {
        // LoadImm64 r1, writeable address
        // StoreImmU8 [r1], 0xAB
        // LoadU8 r2, [r1] - read back
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        // StoreImmIndU8 [r1 + 0], 0xAB
        // Format: [opcode][packed_rA_lX][immed_X][immed_Y]
        // packed_rA_lX: low nibble=rA (base reg), high bits=l_X (offset bytes)
        code.append(0x46) // StoreImmIndU8 opcode (70)
        code.append(0x11) // rA=1, l_X=1
        code.append(contentsOf: encodeCompactImmediate(0, length: 1)) // immed_X (offset)
        code.append(contentsOf: encodeCompactImmediate(0xAB, length: 4)) // immed_Y (value)

        // LoadU8 r2, [0x20000] to verify (direct addressing)
        code.append(0x34) // LoadU8 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x00) // Trap (proper termination per spec)

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_00AB)
    }

    @Test
    func jitStoreImmU32() async {
        // LoadImm64 r1, writeable address
        // StoreImmU32 [r1], 0x12345678
        // LoadU32 r2, [r1] - read back
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        // StoreImmIndU32 [r1 + 0], 0x12345678
        code.append(0x48) // StoreImmIndU32 opcode (72)
        code.append(0x11) // rA=1, l_X=1
        code.append(contentsOf: encodeCompactImmediate(0, length: 1)) // immed_X (offset)
        code.append(contentsOf: encodeCompactImmediate(0x1234_5678, length: 4)) // immed_Y (value)

        // LoadU32 r2, [0x20000] to verify (direct addressing)
        code.append(0x38) // LoadU32 opcode
        code.append(0x02) // r2
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x00) // Trap (proper termination per spec)

        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_1234_5678)
    }

    @Test
    func jitStoreImmU8Parity() async {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x46) // StoreImmIndU8 [r1+0], 0xCD
        code.append(0x11) // rA=1, l_X=1
        code.append(contentsOf: encodeCompactImmediate(0, length: 1)) // immed_X (offset)
        code.append(contentsOf: encodeCompactImmediate(0xCD, length: 4)) // immed_Y (value)

        code.append(0x00) // Trap (proper termination per spec)

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0,
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "StoreImmU8",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - Edge Cases

    @Test
    func jitLoadInvalidAddress() async {
        // LoadU8 r1, [0xFFFF0000] where address equals memory_size, so it must page fault.
        var code = Data()
        code.append(PVMOpcodes.loadU8.rawValue)
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0xFFFF_0000).littleEndian) { Array($0) })
        code.append(PVMOpcodes.halt.rawValue)

        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: Data(),
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        let isPageFault = switch result.exitReason {
        case .pageFault:
            true
        default:
            false
        }
        #expect(isPageFault)
    }

    @Test
    func jitStoreToReadOnly() async {
        // LoadImm64 r1, read-only address
        // LoadImm64 r2, value
        // StoreIndU8 [r1+0], r2 - should panic (read-only violation)
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x10000 (read-only)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0001_0000).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 0xAB
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00AB).littleEndian) { Array($0) })

        // StoreIndU8 [r1 + 0], r2 - register-relative addressing
        // Format: [opcode][src_dest_packed][offset_32bit] where src_dest = (src | dest << 4)
        code.append(0x78) // StoreIndU8 opcode (120)
        code.append(0x12) // r2 (src=2) | (r1 (dest=1) << 4) = 0x02 | 0x10 = 0x12
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) }) // offset

        code.append(0x00) // Trap (proper termination per spec)

        let readOnlyData = Data([0xAA])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0,
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should result in error (hostCall for memory protection or pageFault)
        // The exact reason depends on implementation
        let hasError = switch result.exitReason {
        case .hostCall, .pageFault, .panic:
            true
        default:
            false
        }
        #expect(hasError)
    }
}
