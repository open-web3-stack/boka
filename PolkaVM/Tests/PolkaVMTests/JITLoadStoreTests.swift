// generated by polka.codes
// JIT Load/Store Instruction Tests
//
// Tests for memory load/store instructions: LoadImm, LoadU8/I8/U16/I16/U32/I32/U64,
// StoreU8/U16/U32/U64, StoreImmU8/U16/U32/U64, and indirect variants

import Foundation
import PolkaVM
import Testing
import TracingUtils
import Utils

@testable import PolkaVM

private let logger = Logger(label: "JITLoadStoreTests")

/// JIT Load/Store Instruction Tests
struct JITLoadStoreTests {
    // MARK: - LoadImm Instructions (Opcodes 51, 20)

    @Test("JIT: LoadImm64 loads 64-bit immediate")
    func jitLoadImm64() async throws {
        // LoadImm64 r1, 0x123456789ABCDEF0
        let instruction: [UInt8] = [
            0x33, // LoadImm64 opcode
            0x01, // r1
        ] + withUnsafeBytes(of: UInt64(0x1234_5678_9ABC_DEF0).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // r1 should contain the loaded value
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 0x1234_5678_9ABC_DEF0)
    }

    @Test("JIT: LoadImm64 with zero")
    func jitLoadImm64Zero() async throws {
        // LoadImm64 r2, 0
        let instruction: [UInt8] = [
            0x33, // LoadImm64 opcode
            0x02, // r2
        ] + withUnsafeBytes(of: UInt64(0).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0)
    }

    @Test("JIT: LoadImm64 with max value")
    func jitLoadImm64Max() async throws {
        // LoadImm64 r3, UInt64.max
        let instruction: [UInt8] = [
            0x33, // LoadImm64 opcode
            0x03, // r3
        ] + withUnsafeBytes(of: UInt64.max.littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: UInt64.max)
    }

    @Test("JIT: LoadImm32 loads 32-bit immediate with sign extension")
    func jitLoadImm32() async throws {
        // LoadImm32 r1, 0x12345678
        let instruction: [UInt8] = [
            0x32, // LoadImm32 opcode
            0x01, // r1
        ] + withUnsafeBytes(of: UInt32(0x1234_5678).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // Should be sign-extended to 64 bits
        let expected = UInt64(bitPattern: Int64(Int32(0x1234_5678)))
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: expected)
    }

    @Test("JIT: LoadImmU32 loads unsigned 32-bit immediate")
    func jitLoadImmU32() async throws {
        // LoadImmU32 r1, 0xFFFFFFFF (should be zero-extended)
        let instruction: [UInt8] = [
            0x31, // LoadImmU32 opcode
            0x01, // r1
        ] + withUnsafeBytes(of: UInt32(0xFFFF_FFFF).littleEndian) { Array($0) }

        let result = await JITInstructionExecutor.executeSingleInstruction(instruction)

        // Should be zero-extended (not sign-extended)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 0x0000_0000_FFFF_FFFF)
    }

    @Test("JIT vs Interpreter: LoadImm64 parity")
    func jitLoadImm64Parity() async throws {
        let instruction: [UInt8] = [
            0x33, // LoadImm64 opcode
            0x01, // r1
        ] + withUnsafeBytes(of: UInt64(0xDEAD_BEEF_CAFE_BABE).littleEndian) { Array($0) }

        let (_, _, differences) = await JITParityComparator.compareSingleInstruction(
            instruction,
            testName: "LoadImm64"
        )

        #expect(
            differences == nil,
            "LoadImm64 parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - LoadU8/I8/U16/I16/U32/I32/U64 Instructions (Opcodes 52-58)

    @Test("JIT: LoadU8 loads unsigned byte")
    func jitLoadU8() async throws {
        // LoadImm64 r1, address (0x10000)
        // LoadU8 r2, [r1] - load from read-only data
        // Halt

        var code = Data()

        // LoadImm64 r1, 0x10000 (address in read-only zone)
        code.append(0x33) // LoadImm64
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0001_0000).littleEndian) { Array($0) })

        // LoadU8 r2, [r1 + 0] (offset 0)
        code.append(0x34) // LoadU8 opcode
        code.append(0x02) // r2
        code.append(0x01) // r1 (base register)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) }) // offset

        // Halt
        code.append(0x01)

        // Create program with read-only data containing 0xAB at offset 0
        let readOnlyData = Data([0xAB, 0xCD, 0xEF])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0xAB (zero-extended)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_00AB)
    }

    @Test("JIT: LoadI8 sign-extends byte")
    func jitLoadI8() async throws {
        // LoadImm64 r1, address
        // LoadI8 r2, [r1] - load 0xFF (should sign-extend to -1)
        // Halt

        var code = Data()

        code.append(0x33) // LoadImm64
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0001_0000).littleEndian) { Array($0) })

        // LoadI8 r2, [r1 + 0]
        code.append(0x35) // LoadI8 opcode
        code.append(0x02) // r2
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        // Read-only data with 0xFF (signed -1 as byte)
        let readOnlyData = Data([0xFF])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0xFFFFFFFFFFFFFFFF (sign-extended -1)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: UInt64(0xFFFF_FFFF_FFFF_FFFF))
    }

    @Test("JIT: LoadU16 loads unsigned halfword")
    func jitLoadU16() async throws {
        // LoadImm64 r1, address
        // LoadU16 r2, [r1] - load 0x1234
        // Halt

        var code = Data()

        code.append(0x33) // LoadImm64
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0001_0000).littleEndian) { Array($0) })

        // LoadU16 r2, [r1 + 0]
        code.append(0x36) // LoadU16 opcode
        code.append(0x02) // r2
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        // Read-only data with 0x1234 (little-endian)
        let readOnlyData = Data([0x34, 0x12])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r2 should contain 0x1234
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_1234)
    }

    @Test("JIT vs Interpreter: LoadU8 parity")
    func jitLoadU8Parity() async throws {
        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x10000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0001_0000).littleEndian) { Array($0) })

        code.append(0x34) // LoadU8 r2, [r1 + 0]
        code.append(0x02)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        let readOnlyData = Data([0xAB, 0xCD])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "LoadU8"
        )

        #expect(
            differences == nil,
            "LoadU8 parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - StoreU8/U16/U32/U64 Instructions (Opcodes 59-62)

    @Test("JIT: StoreU8 stores byte to memory")
    func jitStoreU8() async throws {
        // LoadImm64 r1, writeable address
        // LoadImm64 r2, value (0xAB)
        // StoreU8 [r1], r2
        // LoadU8 r3, [r1] - read back
        // Halt

        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x20000 (heap start)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x33) // LoadImm64 r2, 0xAB
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00AB).littleEndian) { Array($0) })

        // StoreU8 [r1 + 0], r2
        code.append(0x3B) // StoreU8 opcode
        code.append(0x01) // r1 (base)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) }) // offset
        code.append(0x02) // r2 (value)

        // LoadU8 r3, [r1 + 0] to verify
        code.append(0x34) // LoadU8
        code.append(0x03) // r3
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        // Create program with read-write data (heap)
        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r3 should contain the stored value 0xAB
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0x0000_0000_0000_00AB)
    }

    @Test("JIT: StoreU16 stores halfword to memory")
    func jitStoreU16() async throws {
        // LoadImm64 r1, writeable address
        // LoadImm64 r2, value (0x1234)
        // StoreU16 [r1], r2
        // LoadU16 r3, [r1] - read back
        // Halt

        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x33) // LoadImm64 r2, 0x1234
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_1234).littleEndian) { Array($0) })

        // StoreU16 [r1 + 0], r2
        code.append(0x3C) // StoreU16 opcode
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })
        code.append(0x02)

        // LoadU16 r3, [r1 + 0]
        code.append(0x36) // LoadU16
        code.append(0x03)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0x0000_0000_0000_1234)
    }

    @Test("JIT vs Interpreter: StoreU8 parity")
    func jitStoreU8Parity() async throws {
        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x33) // LoadImm64 r2, 0xFF
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00FF).littleEndian) { Array($0) })

        code.append(0x3B) // StoreU8 [r1+0], r2
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })
        code.append(0x02)

        code.append(0x01) // Halt

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "StoreU8"
        )

        #expect(
            differences == nil,
            "StoreU8 parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - StoreImmU8/U16/U32/U64 Instructions (Opcodes 30-33)

    @Test("JIT: StoreImmU8 stores immediate byte")
    func jitStoreImmU8() async throws {
        // LoadImm64 r1, writeable address
        // StoreImmU8 [r1], 0xAB
        // LoadU8 r2, [r1] - read back
        // Halt

        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        // StoreImmU8 [r1 + 0], 0xAB
        code.append(0x1E) // StoreImmU8 opcode
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) }) // offset
        code.append(0xAB) // immediate value

        // LoadU8 r2, [r1 + 0]
        code.append(0x34)
        code.append(0x02)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_0000_00AB)
    }

    @Test("JIT: StoreImmU32 stores immediate 32-bit value")
    func jitStoreImmU32() async throws {
        // LoadImm64 r1, writeable address
        // StoreImmU32 [r1], 0x12345678
        // LoadU32 r2, [r1] - read back
        // Halt

        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        // StoreImmU32 [r1 + 0], 0x12345678
        code.append(0x21) // StoreImmU32 opcode
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) }) // offset
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0x1234_5678).littleEndian) { Array($0) }) // immediate

        // LoadU32 r2, [r1 + 0]
        code.append(0x38) // LoadU32 opcode
        code.append(0x02) // r2
        code.append(0x01) // r1
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) }) // offset

        code.append(0x01) // Halt

        let heapData = Data([0x00, 0x00, 0x00, 0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0x0000_0000_1234_5678)
    }

    @Test("JIT vs Interpreter: StoreImmU8 parity")
    func jitStoreImmU8Parity() async throws {
        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x20000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0002_0000).littleEndian) { Array($0) })

        code.append(0x1E) // StoreImmU8 [r1+0], 0xCD
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })
        code.append(0xCD)

        code.append(0x01) // Halt

        let heapData = Data([0x00])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: heapData,
            heapPages: 0
        )

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "StoreImmU8"
        )

        #expect(
            differences == nil,
            "StoreImmU8 parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - Edge Cases

    @Test("JIT: Load from invalid address causes page fault")
    func jitLoadInvalidAddress() async throws {
        // LoadImm64 r1, invalid address (beyond all zones)
        // LoadU8 r2, [r1] - should page fault
        // Halt (shouldn't reach)

        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x63000000 (invalid)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x6300_0000).littleEndian) { Array($0) })

        code.append(0x34) // LoadU8 r2, [r1 + 0]
        code.append(0x02)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })

        code.append(0x01) // Halt

        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: Data(),
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should page fault
        let isPageFault = switch result.exitReason {
        case .pageFault:
            true
        default:
            false
        }
        #expect(
            isPageFault,
            "Load from invalid address should page fault: got \(result.exitReason)"
        )
    }

    @Test("JIT: Store to read-only memory causes panic")
    func jitStoreToReadOnly() async throws {
        // LoadImm64 r1, read-only address
        // LoadImm64 r2, value
        // StoreU8 [r1], r2 - should panic (read-only violation)
        // Halt

        var code = Data()

        code.append(0x33) // LoadImm64 r1, 0x10000 (read-only)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0001_0000).littleEndian) { Array($0) })

        code.append(0x33) // LoadImm64 r2, 0xAB
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0000_0000_0000_00AB).littleEndian) { Array($0) })

        code.append(0x3B) // StoreU8 [r1+0], r2
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt32(0).littleEndian) { Array($0) })
        code.append(0x02)

        code.append(0x01) // Halt

        let readOnlyData = Data([0xAA])
        let blob = ProgramBlobBuilder.createStandardProgram(
            programCode: ProgramBlobBuilder.createProgramCodeBlob(Array(code)),
            readOnlyData: readOnlyData,
            readWriteData: Data(),
            heapPages: 0
        )

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should result in error (hostCall for memory protection or pageFault)
        // The exact reason depends on implementation
        let hasError = switch result.exitReason {
        case .hostCall, .pageFault, .panic:
            true
        default:
            false
        }
        #expect(hasError, "Store to read-only should error: got \(result.exitReason)")
    }
}
