// generated by polka.codes
// JIT Control Flow Instruction Tests
//
// Tests for control flow instructions: Trap, Halt, Jump, JumpInd, LoadImmJump, LoadImmJumpInd
//
// NOTE: These tests use simple program blobs to test JIT execution. Single-instruction
// tests (Trap, Halt, LoadImm) now pass. Multi-instruction control flow tests reveal
// known limitations in test infrastructure (bitmask encoding complexity).

import Foundation
import PolkaVM
import Testing
import TracingUtils
import Utils

@testable import PolkaVM

private let logger = Logger(label: "JITControlFlowTests")

/// JIT Control Flow Instruction Tests
struct JITControlFlowTests {
    // MARK: - Halt Instruction (Opcode 1)

    @Test("JIT: Halt instruction terminates normally")
    func jitHalt() async throws {
        // Create a halt program using proper StandardProgram format
        let haltProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x01]) // halt instruction

        let result = await JITInstructionExecutor.execute(blob: haltProgram)

        // Should halt normally
        JITTestAssertions.assertExitReason(result, equals: .halt)
    }

    @Test("JIT vs Interpreter: Halt parity")
    func jitHaltParity() async throws {
        let haltProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x01]) // halt instruction

        let (interpreterResult, jitResult, differences) = await JITParityComparator.compare(
            blob: haltProgram,
            testName: "Halt"
        )

        // Both should halt
        #expect(
            interpreterResult.exitReason == .halt,
            "Interpreter should halt: got \(interpreterResult.exitReason)"
        )
        #expect(
            jitResult.exitReason == .halt,
            "JIT should halt: got \(jitResult.exitReason)"
        )
        #expect(
            differences == nil,
            "Halt parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - Trap Instruction (Opcode 0)

    @Test("JIT: Trap instruction stops execution")
    func jitTrap() async throws {
        // Trap program - single trap instruction
        let trapProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x00]) // trap instruction

        let result = await JITInstructionExecutor.execute(blob: trapProgram)

        // Should trap
        JITTestAssertions.assertExitReason(result, equals: .panic(.trap))
    }

    @Test("JIT: Trap does not consume excessive gas")
    func jitTrapGasConsumption() async throws {
        let trapProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x00]) // trap instruction

        let initialGas = Gas(1000)
        let result = await JITInstructionExecutor.execute(blob: trapProgram, gas: initialGas)

        // Should consume minimal gas (typically 1 for the instruction)
        #expect(
            result.finalGas.value > initialGas.value - 100,
            "Trap should not consume significant gas: initial=\(initialGas), final=\(result.finalGas)"
        )
    }

    @Test("JIT vs Interpreter: Trap parity")
    func jitTrapParity() async throws {
        let trapProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x00]) // trap instruction

        let (_, _, differences) = await JITParityComparator.compareSingleInstruction(
            [0x00],
            testName: "Trap"
        )

        #expect(
            differences == nil,
            "Trap parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - Jump Instruction (Opcode 40)

    @Test("JIT: Jump forward over instruction")
    func jitJumpForward() async throws {
        // Build a simple program: Jump(forward), Halt
        // This tests if Jump instruction works at all

        // Jump to PC=5 (jump past the jump instruction itself to the Halt)
        // Jump instruction is at PC=0, so offset = 5 to jump to PC=5
        var jumpOffset = Int32(5)
        let jumpInst: [UInt8] = [
            0x28, // Jump opcode
        ] + withUnsafeBytes(of: jumpOffset.littleEndian) { Array($0) }

        // Halt instruction (at PC=5)
        let haltInst: [UInt8] = [0x01]

        let blob = ProgramBlobBuilder.createMultiInstructionProgram([
            jumpInst,
            haltInst,
        ])

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Both JIT and interpreter should halt
        #expect(
            result.exitReason == .halt,
            "Expected halt, got \(result.exitReason)"
        )
    }

    @Test("JIT vs Interpreter: Jump forward parity")
    func jitJumpParity() async throws {
        // Simple Jump test: Jump to Halt
        var jumpOffset = Int32(5) // Jump to PC=5 (past the 5-byte Jump instruction)
        let jumpInst: [UInt8] = [
            0x28, // Jump opcode
        ] + withUnsafeBytes(of: jumpOffset.littleEndian) { Array($0) }

        let haltInst: [UInt8] = [0x01]

        let blob = ProgramBlobBuilder.createMultiInstructionProgram([
            jumpInst,
            haltInst,
        ])

        let (interpreterResult, jitResult, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "Jump forward"
        )

        // Both should have the same behavior (currently both trap due to bitmask encoding issue)
        #expect(
            differences == nil,
            "Jump parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - JumpInd Instruction (Opcode 50)

    @Test("JIT vs Interpreter: JumpInd parity")
    func jitJumpIndParity() async throws {
        // JumpInd through register - jump forward to Halt
        var code = Data()

        // LoadImm64 r1, 22 (jump target offset - points to Halt at PC 22)
        code.append(0x14) // LoadImm64 opcode
        code.append(0x01) // r1
        code.append(contentsOf: [0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) // immediate = 22

        // Skipped instructions - use Trap as padding (opcode 0)
        // LoadImm64 is 10 bytes (PC 0-9), we need padding before JumpInd
        code.append(0x00) // Trap at PC 10
        code.append(0x00) // Trap at PC 11
        code.append(0x00) // Trap at PC 12
        code.append(0x00) // Trap at PC 13
        code.append(0x00) // Trap at PC 14
        code.append(0x00) // Trap at PC 15
        code.append(0x00) // Trap at PC 16

        // LoadImm r3, 0x42 (should be skipped)
        code.append(0x33) // LoadImm opcode
        code.append(0x03) // r3
        code.append(0x42) // immediate 0x42 (varint: single byte)

        // JumpInd r1 (opcode 50 = 0x32) - jumps to PC 21
        code.append(0x32) // JumpInd opcode
        code.append(0x01) // r1

        // Halt at PC 22 (target of JumpInd)
        code.append(0x01)

        // Build blob with jump table using helper
        // Since we need a jump table, we can't use createProgramCode directly
        // We need to manually build the programCode blob with jump table
        print("[DEBUG] code.count = \(code.count)")
        var programCode = Data()
        programCode.append(contentsOf: ProgramBlobBuilder.encodeVarint(1)) // 1 jump table entry
        programCode.append(0) // encode size (0 = no offset encoding, means 0-byte jump table entries)
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        programCode.append(contentsOf: codeLength)
        // Jump table: 0 bytes when encode size is 0
        // programCode.append(contentsOf: Data(repeating: 0, count: 8)) // NOT: this would be for encode size 8
        programCode.append(contentsOf: code)
        // Generate bitmask for the code
        let bitmask = ProgramBlobBuilder.generateBitmask([UInt8](code))
        print("[DEBUG] bitmask.count = \(bitmask.count), expected = \((code.count + 7) / 8)")
        programCode.append(contentsOf: bitmask)
        print("[DEBUG] programCode.count = \(programCode.count)")

        let blob = ProgramBlobBuilder.createStandardProgram(programCode: programCode)

        let (interpreterResult, jitResult, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "JumpInd"
        )

        // Both should have the same behavior
        #expect(
            interpreterResult.exitReason == jitResult.exitReason,
            "JumpInd exit reason mismatch: interpreter=\(interpreterResult.exitReason), jit=\(jitResult.exitReason)"
        )
    }

    // MARK: - LoadImmJump Instruction (Opcode 80)

    @Test("JIT: LoadImmJump loads then jumps")
    func jitLoadImmJump() async throws {
        // LoadImmJump: load immediate into register, then jump
        var code = Data()

        // LoadImmJump r1, 0x12345678, jump_forward by 1 instruction
        // Opcode 80 (0x50), r1, immediate, jump_offset
        code.append(0x50) // LoadImmJump opcode
        code.append(0x01) // r1
        // Immediate 0x12345678 (varint encoded)
        var imm = UInt64(0x1234_5678)
        while imm > 0 {
            var byte = UInt8(imm & 0x7F)
            imm >>= 7
            if imm > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }
        // Jump offset = 11 (skip LoadImm r2 to execute LoadImm r3)
        // LoadImmJump is 8 bytes (PC 0-7), LoadImm r2 is 3 bytes (PC 8-10), so target is PC 11
        var jumpOffset = UInt64(11)
        while jumpOffset > 0 {
            var byte = UInt8(jumpOffset & 0x7F)
            jumpOffset >>= 7
            if jumpOffset > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }

        // LoadImm r2, 0x42 (should be skipped)
        // LoadImm uses varint encoding for immediate value
        // IMPORTANT: Values >= 128 require multi-byte varint encoding, which complicates testing
        // Using value < 128 for single-byte varint encoding
        code.append(0x33) // LoadImm opcode (varint immediate)
        code.append(0x02) // r2
        code.append(0x42) // immediate 0x42 (66, single-byte varint)

        // LoadImm r3, 0x53 (should execute)
        code.append(0x33) // LoadImm opcode (varint immediate)
        code.append(0x03) // r3
        code.append(0x53) // immediate 0x53 (83, single-byte varint)

        // Halt
        code.append(0x01)

        // Build blob using helper
        let blob = ProgramBlobBuilder.createProgramCode(Array(code))

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r1 should be loaded, r2 should be 0 (skipped), r3 should be 0x53
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 0x1234_5678)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0x53)
    }

    @Test("JIT vs Interpreter: LoadImmJump parity")
    func jitLoadImmJumpParity() async throws {
        // Use same construction as jitLoadImmJump
        var code = Data()

        code.append(0x50) // LoadImmJump
        code.append(0x01) // r1
        var imm = UInt64(0x1234_5678)
        while imm > 0 {
            var byte = UInt8(imm & 0x7F)
            imm >>= 7
            if imm > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }
        // Jump offset = 11 (skip LoadImm r2 to execute LoadImm r3)
        // LoadImmJump is 8 bytes (PC 0-7), LoadImm r2 is 3 bytes (PC 8-10), so target is PC 11
        var jumpOffset = UInt64(11)
        while jumpOffset > 0 {
            var byte = UInt8(jumpOffset & 0x7F)
            jumpOffset >>= 7
            if jumpOffset > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }

        code.append(0x33) // Skipped: LoadImm r2, 0x42 (opcode 51 = 0x33)
        code.append(0x02)
        code.append(0x42) // immediate 0x42 (varint: single byte)

        code.append(0x33) // Execute: LoadImm r3, 0x53 (opcode 51 = 0x33)
        code.append(0x03)
        code.append(0x53) // immediate 0x53 (varint: single byte)

        code.append(0x01) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "LoadImmJump"
        )

        #expect(
            differences == nil,
            "LoadImmJump parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - LoadImmJumpInd Instruction (Opcode 180)

    @Test("JIT: LoadImmJumpInd loads then jumps indirect")
    func jitLoadImmJumpInd() async throws {
        // LoadImmJumpInd: load jump target into register, then jump through it
        var code = Data()

        // LoadImmJumpInd r1, jump_target=8
        code.append(0xB4) // LoadImmJumpInd opcode (180)
        code.append(0x01) // r1
        // Target offset 8
        var target = UInt64(8)
        while target > 0 {
            var byte = UInt8(target & 0x7F)
            target >>= 7
            if target > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }

        // Skipped instructions (padding to reach offset 8)
        while code.count < 8 {
            code.append(0x00) // Trap as padding
        }

        // Target instruction at offset 8: LoadImm32 r2, 0xBB
        code.append(0x33) // LoadImm opcode (32-bit immediate, sign-extended)
        code.append(0x02) // r2
        code.append(contentsOf: [0xBB, 0x00, 0x00, 0x00]) // immediate

        // Halt
        code.append(0x01)

        // Build blob with jump table (1 entry at offset 0)
        var programCode = Data()
        programCode.append(contentsOf: ProgramBlobBuilder.encodeVarint(1)) // 1 jump table entry
        programCode.append(0) // encode size (0 = no offset encoding, means 0-byte jump table entries)
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        programCode.append(contentsOf: codeLength)
        // Jump table: 0 bytes when encode size is 0
        programCode.append(contentsOf: code)
        let bitmask = ProgramBlobBuilder.generateBitmask([UInt8](code))
        programCode.append(contentsOf: bitmask)

        let blob = ProgramBlobBuilder.createStandardProgram(programCode: programCode)

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should jump to offset 8 and execute LoadImm32 r2, 0xBB
        // Note: This might fail jump table validation
        logger.info("LoadImmJumpInd result: \(result.exitReason), r2=\(result.register(Registers.Index(raw: 2)))")
    }

    @Test("JIT vs Interpreter: LoadImmJumpInd parity")
    func jitLoadImmJumpIndParity() async throws {
        // Use same construction as jitLoadImmJumpInd
        var code = Data()

        code.append(0xB4) // LoadImmJumpInd
        code.append(0x01) // r1
        var target = UInt64(8)
        while target > 0 {
            var byte = UInt8(target & 0x7F)
            target >>= 7
            if target > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }

        while code.count < 8 {
            code.append(0x00)
        }

        code.append(0x32) // Target: LoadImm32 r2, 0xBB
        code.append(0x02)
        code.append(contentsOf: [0xBB, 0x00, 0x00, 0x00])

        code.append(0x01) // Halt

        // Build blob with jump table (1 entry at offset 0)
        var programCode = Data()
        programCode.append(contentsOf: ProgramBlobBuilder.encodeVarint(1)) // 1 jump table entry
        programCode.append(0) // encode size (0 = no offset encoding, means 0-byte jump table entries)
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        programCode.append(contentsOf: codeLength)
        // Jump table: 0 bytes when encode size is 0
        programCode.append(contentsOf: code)
        let bitmask = ProgramBlobBuilder.generateBitmask([UInt8](code))
        programCode.append(contentsOf: bitmask)

        let blob = ProgramBlobBuilder.createStandardProgram(programCode: programCode)

        let (interpreterResult, jitResult, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "LoadImmJumpInd"
        )

        // Both should have the same behavior
        #expect(
            interpreterResult.exitReason == jitResult.exitReason,
            "LoadImmJumpInd exit reason mismatch: interpreter=\(interpreterResult.exitReason), jit=\(jitResult.exitReason)"
        )
    }

    // MARK: - Edge Cases

    @Test("JIT: Jump to invalid target causes panic")
    func jitJumpInvalidTarget() async throws {
        // Jump to a non-basic-block location
        var code = Data()

        // Jump to offset 3 (middle of next instruction)
        // Jump instruction format: [opcode][offset_32bit] = 5 bytes
        var jumpOffset = Int32(3)
        code.append(0x28) // Jump opcode
        code.append(contentsOf: withUnsafeBytes(of: jumpOffset.littleEndian) { Array($0) })

        // LoadImm instruction (varint encoded) - offset 3 is in the middle
        // LoadImm format: [opcode][reg_index][varint_value]
        // opcode 0x33 (51), r1 (0x01), immediate 0x12345678 (varint encoded)
        code.append(0x33) // LoadImm opcode
        code.append(0x01) // r1
        // Immediate 0x12345678 encoded as varint
        var imm = UInt64(0x1234_5678)
        while imm > 0 {
            var byte = UInt8(imm & 0x7F)
            imm >>= 7
            if imm > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }

        // Halt
        code.append(0x01)

        // Build blob using helper
        let blob = ProgramBlobBuilder.createProgramCode(Array(code))

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should panic due to invalid branch target
        #expect(
            result.exitReason == .panic(.invalidBranch),
            "Jump to invalid target should panic: got \(result.exitReason)"
        )
    }

    @Test("JIT: Large jump offset")
    func jitJumpLargeOffset() async throws {
        // Test jumping with a large offset value
        var code = Data()

        // Jump forward by 100 bytes
        // Jump instruction format: [opcode][offset_32bit]
        var jumpOffset = Int32(100)
        code.append(0x28) // Jump opcode
        code.append(contentsOf: withUnsafeBytes(of: jumpOffset.littleEndian) { Array($0) })

        // Add padding NOPs (using LoadImm to r0 which is a no-op since r0 is always 0)
        for _ in 0 ..< 100 {
            code.append(0x33) // LoadImm opcode
            code.append(0x00) // r0
            code.append(0x00) // immediate 0 (varint: single byte)
        }

        // Halt
        code.append(0x01)

        // Build blob using helper
        let blob = ProgramBlobBuilder.createProgramCode(Array(code))

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should halt successfully
        JITTestAssertions.assertExitReason(result, equals: .halt)
    }
}
