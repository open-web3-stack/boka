// generated by polka.codes
// JIT Control Flow Instruction Tests
//
// Tests for control flow instructions: Trap, Halt, Jump, JumpInd, LoadImmJump, LoadImmJumpInd
//
// NOTE: These tests use simple program blobs to test JIT execution. The JIT is currently
// broken on this branch (fix-jamtests-errors) and will crash with ud2 instruction.
// These tests are ready to run once the JIT is fixed.

import Foundation
import PolkaVM
import Testing
import TracingUtils
import Utils

@testable import PolkaVM

private let logger = Logger(label: "JITControlFlowTests")

/// JIT Control Flow Instruction Tests
struct JITControlFlowTests {
    // MARK: - Halt Instruction (Opcode 1)

    @Test("JIT: Halt instruction terminates normally")
    func jitHalt() async throws {
        // Create a halt program using proper StandardProgram format
        let haltProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x01]) // halt instruction

        let result = await JITInstructionExecutor.execute(blob: haltProgram)

        // Should halt normally
        JITTestAssertions.assertExitReason(result, equals: .halt)
    }

    @Test("JIT vs Interpreter: Halt parity")
    func jitHaltParity() async throws {
        let haltProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x01]) // halt instruction

        let (interpreterResult, jitResult, differences) = await JITParityComparator.compare(
            blob: haltProgram,
            testName: "Halt"
        )

        // Both should halt
        #expect(
            interpreterResult.exitReason == .halt,
            "Interpreter should halt: got \(interpreterResult.exitReason)"
        )
        #expect(
            jitResult.exitReason == .halt,
            "JIT should halt: got \(jitResult.exitReason)"
        )
        #expect(
            differences == nil,
            "Halt parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - Trap Instruction (Opcode 0)

    @Test("JIT: Trap instruction stops execution")
    func jitTrap() async throws {
        // Trap program - single trap instruction
        let trapProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x00]) // trap instruction

        let result = await JITInstructionExecutor.execute(blob: trapProgram)

        // Should trap
        JITTestAssertions.assertExitReason(result, equals: .panic(.trap))
    }

    @Test("JIT: Trap does not consume excessive gas")
    func jitTrapGasConsumption() async throws {
        let trapProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x00]) // trap instruction

        let initialGas = Gas(1000)
        let result = await JITInstructionExecutor.execute(blob: trapProgram, gas: initialGas)

        // Should consume minimal gas (typically 1 for the instruction)
        #expect(
            result.finalGas.value > initialGas.value - 100,
            "Trap should not consume significant gas: initial=\(initialGas), final=\(result.finalGas)"
        )
    }

    @Test("JIT vs Interpreter: Trap parity")
    func jitTrapParity() async throws {
        let trapProgram = ProgramBlobBuilder.createSingleInstructionProgram([0x00]) // trap instruction

        let (_, _, differences) = await JITParityComparator.compareSingleInstruction(
            [0x00],
            testName: "Trap"
        )

        #expect(
            differences == nil,
            "Trap parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - Jump Instruction (Opcode 40)

    @Test("JIT: Jump forward over instruction")
    func jitJumpForward() async throws {
        // Build a simple program: Jump(forward), Halt
        // This tests if Jump instruction works at all

        // Jump to PC=5 (jump past the jump instruction itself to the Halt)
        // Jump instruction is at PC=0, so offset = 5 to jump to PC=5
        var jumpOffset = Int32(5)
        let jumpInst: [UInt8] = [
            0x28, // Jump opcode
        ] + withUnsafeBytes(of: jumpOffset.littleEndian) { Array($0) }

        // Halt instruction (at PC=5)
        let haltInst: [UInt8] = [0x01]

        let blob = ProgramBlobBuilder.createMultiInstructionProgram([
            jumpInst,
            haltInst,
        ])

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Both JIT and interpreter should halt
        #expect(
            result.exitReason == .halt,
            "Expected halt, got \(result.exitReason)"
        )
    }

    @Test("JIT vs Interpreter: Jump forward parity")
    func jitJumpParity() async throws {
        // Simple Jump test: Jump to Halt
        var jumpOffset = Int32(5) // Jump to PC=5 (past the 5-byte Jump instruction)
        let jumpInst: [UInt8] = [
            0x28, // Jump opcode
        ] + withUnsafeBytes(of: jumpOffset.littleEndian) { Array($0) }

        let haltInst: [UInt8] = [0x01]

        let blob = ProgramBlobBuilder.createMultiInstructionProgram([
            jumpInst,
            haltInst,
        ])

        let (interpreterResult, jitResult, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "Jump forward"
        )

        // Log results for debugging
        print("DEBUG: Jump test")
        print("  Interpreter exitReason: \(interpreterResult.exitReason)")
        print("  JIT exitReason: \(jitResult.exitReason)")
        if let diff = differences {
            print("  Differences: \(diff)")
        }

        #expect(
            differences == nil,
            "Jump parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - JumpInd Instruction (Opcode 50)

    @Test("JIT vs Interpreter: JumpInd parity")
    func jitJumpIndParity() async throws {
        // JumpInd through register
        var code = Data()

        // LoadImm64 r1, 8 (jump target offset)
        code.append(0x33) // LoadImm64 opcode
        code.append(0x01) // r1
        code.append(contentsOf: [0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) // immediate = 8

        // Skipped instruction
        code.append(0x32) // LoadImm32 r1
        code.append(0x02) // r2
        code.append(contentsOf: [0xFF, 0x00, 0x00, 0x00]) // immediate

        // Target instruction at offset 8 (approximately)
        code.append(0x32) // LoadImm32 r2
        code.append(0x03) // r3
        code.append(contentsOf: [0xBB, 0x00, 0x00, 0x00]) // immediate

        // JumpInd r1 (opcode 50 = 0x32)
        code.append(0x32) // JumpInd opcode
        code.append(0x01) // r1

        // Halt
        code.append(0x01)

        // Build blob with jump table
        var blob = Data()
        blob.append(1) // 1 jump table entry
        blob.append(0) // encode size
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)
        // Jump table entry: offset 0
        blob.append(contentsOf: Data(repeating: 0, count: 8))
        blob.append(contentsOf: code)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        let (interpreterResult, jitResult, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "JumpInd"
        )

        // Both should have the same behavior
        #expect(
            interpreterResult.exitReason == jitResult.exitReason,
            "JumpInd exit reason mismatch: interpreter=\(interpreterResult.exitReason), jit=\(jitResult.exitReason)"
        )
    }

    // MARK: - LoadImmJump Instruction (Opcode 80)

    @Test("JIT: LoadImmJump loads then jumps")
    func jitLoadImmJump() async throws {
        // LoadImmJump: load immediate into register, then jump
        var code = Data()

        // LoadImmJump r1, 0x12345678, jump_forward by 1 instruction
        // Opcode 80 (0x50), r1, immediate, jump_offset
        code.append(0x50) // LoadImmJump opcode
        code.append(0x01) // r1
        // Immediate 0x12345678 (varint encoded)
        var imm = UInt64(0x1234_5678)
        while imm > 0 {
            var byte = UInt8(imm & 0x7F)
            imm >>= 7
            if imm > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }
        // Jump offset = 1 (skip next instruction)
        code.append(0x01) // jump offset

        // LoadImm32 r2, 0xFF (should be skipped)
        code.append(0x32) // LoadImm32 opcode
        code.append(0x02) // r2
        code.append(contentsOf: [0xFF, 0x00, 0x00, 0x00]) // immediate

        // LoadImm32 r3, 0xAA (should execute)
        code.append(0x32) // LoadImm32 opcode
        code.append(0x03) // r3
        code.append(contentsOf: [0xAA, 0x00, 0x00, 0x00]) // immediate

        // Halt
        code.append(0x01)

        // Build blob
        var blob = Data()
        blob.append(0) // 0 jump table entries
        blob.append(0) // encode size
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)
        blob.append(contentsOf: code)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        let result = await JITInstructionExecutor.execute(blob: blob)

        // r1 should be loaded, r2 should be 0 (skipped), r3 should be 0xAA
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 0x1234_5678)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 2), equals: 0)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0xAA)
    }

    @Test("JIT vs Interpreter: LoadImmJump parity")
    func jitLoadImmJumpParity() async throws {
        // Use same construction as jitLoadImmJump
        var code = Data()

        code.append(0x50) // LoadImmJump
        code.append(0x01) // r1
        var imm = UInt64(0x1234_5678)
        while imm > 0 {
            var byte = UInt8(imm & 0x7F)
            imm >>= 7
            if imm > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }
        code.append(0x01) // jump offset

        code.append(0x32) // Skipped: LoadImm32 r2, 0xFF
        code.append(0x02)
        code.append(contentsOf: [0xFF, 0x00, 0x00, 0x00])

        code.append(0x32) // Execute: LoadImm32 r3, 0xAA
        code.append(0x03)
        code.append(contentsOf: [0xAA, 0x00, 0x00, 0x00])

        code.append(0x01) // Halt

        var blob = Data()
        blob.append(0)
        blob.append(0)
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)
        blob.append(contentsOf: code)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "LoadImmJump"
        )

        #expect(
            differences == nil,
            "LoadImmJump parity mismatch: \(differences ?? "none")"
        )
    }

    // MARK: - LoadImmJumpInd Instruction (Opcode 180)

    @Test("JIT: LoadImmJumpInd loads then jumps indirect")
    func jitLoadImmJumpInd() async throws {
        // LoadImmJumpInd: load jump target into register, then jump through it
        var code = Data()

        // LoadImmJumpInd r1, jump_target=8
        code.append(0xB4) // LoadImmJumpInd opcode (180)
        code.append(0x01) // r1
        // Target offset 8
        var target = UInt64(8)
        while target > 0 {
            var byte = UInt8(target & 0x7F)
            target >>= 7
            if target > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }

        // Skipped instructions (padding to reach offset 8)
        while code.count < 8 {
            code.append(0x00) // Trap as padding
        }

        // Target instruction at offset 8: LoadImm32 r2, 0xBB
        code.append(0x32) // LoadImm32 opcode
        code.append(0x02) // r2
        code.append(contentsOf: [0xBB, 0x00, 0x00, 0x00]) // immediate

        // Halt
        code.append(0x01)

        // Build blob with jump table
        var blob = Data()
        blob.append(1) // 1 jump table entry
        blob.append(0) // encode size
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)
        // Jump table: entry 0 -> offset 0
        blob.append(contentsOf: Data(repeating: 0, count: 8))
        blob.append(contentsOf: code)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should jump to offset 8 and execute LoadImm32 r2, 0xBB
        // Note: This might fail jump table validation
        logger.info("LoadImmJumpInd result: \(result.exitReason), r2=\(result.register(Registers.Index(raw: 2)))")
    }

    @Test("JIT vs Interpreter: LoadImmJumpInd parity")
    func jitLoadImmJumpIndParity() async throws {
        // Use same construction as jitLoadImmJumpInd
        var code = Data()

        code.append(0xB4) // LoadImmJumpInd
        code.append(0x01) // r1
        var target = UInt64(8)
        while target > 0 {
            var byte = UInt8(target & 0x7F)
            target >>= 7
            if target > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }

        while code.count < 8 {
            code.append(0x00)
        }

        code.append(0x32) // Target: LoadImm32 r2, 0xBB
        code.append(0x02)
        code.append(contentsOf: [0xBB, 0x00, 0x00, 0x00])

        code.append(0x01) // Halt

        var blob = Data()
        blob.append(1)
        blob.append(0)
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)
        blob.append(contentsOf: Data(repeating: 0, count: 8))
        blob.append(contentsOf: code)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        let (interpreterResult, jitResult, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "LoadImmJumpInd"
        )

        // Both should have the same behavior
        #expect(
            interpreterResult.exitReason == jitResult.exitReason,
            "LoadImmJumpInd exit reason mismatch: interpreter=\(interpreterResult.exitReason), jit=\(jitResult.exitReason)"
        )
    }

    // MARK: - Edge Cases

    @Test("JIT: Jump to invalid target causes panic")
    func jitJumpInvalidTarget() async throws {
        // Jump to a non-basic-block location
        var code = Data()

        // Jump to offset 3 (middle of next instruction)
        code.append(0x28) // Jump opcode
        code.append(0x03) // offset 3

        // LoadImm32 instruction (6 bytes) - offset 3 is in the middle
        code.append(0x32) // LoadImm32 opcode
        code.append(0x01) // r1
        code.append(contentsOf: [0x78, 0x56, 0x34, 0x12]) // immediate

        // Halt
        code.append(0x01)

        // Build blob
        var blob = Data()
        blob.append(0)
        blob.append(0)
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)
        blob.append(contentsOf: code)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should panic due to invalid branch target
        #expect(
            result.exitReason == .panic(.invalidBranch),
            "Jump to invalid target should panic: got \(result.exitReason)"
        )
    }

    @Test("JIT: Large jump offset")
    func jitJumpLargeOffset() async throws {
        // Test jumping with a large offset value
        var code = Data()

        // Jump forward by 100 bytes
        code.append(0x28) // Jump opcode
        var offset = UInt64(100)
        while offset > 0 {
            var byte = UInt8(offset & 0x7F)
            offset >>= 7
            if offset > 0 {
                byte |= 0x80
            }
            code.append(byte)
        }

        // Add padding NOPs (using LoadImm32 to r0 which is a no-op since r0 is always 0)
        for _ in 0 ..< 100 {
            code.append(0x32) // LoadImm32
            code.append(0x00) // r0
            code.append(contentsOf: [0x00, 0x00, 0x00, 0x00]) // immediate 0
        }

        // Halt
        code.append(0x01)

        // Build blob
        var blob = Data()
        blob.append(0)
        blob.append(0)
        let codeLength = Data(UInt64(code.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)
        blob.append(contentsOf: code)
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should halt successfully
        JITTestAssertions.assertExitReason(result, equals: .halt)
    }
}
