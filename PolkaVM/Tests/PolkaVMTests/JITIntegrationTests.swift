// generated by polka.codes
// Integration tests for JIT-compiled code execution
//
// These tests verify that the JIT compiler produces correct results
// by comparing with expected outputs.

import Foundation
import Testing
import Utils

@testable import PolkaVM

@Suite(.serialized)
struct JITIntegrationTests {
    // MARK: - Simple Compilation Test

    @Test func testJITCompilesSuccessfully() async throws {
        // Minimal test: just verify JIT compilation doesn't crash
        // Program: LoadImm 42, Halt

        // Blob format:
        // - jumpTableEntriesCount (ULEB128): 0
        // - encodeSize: 8
        // - codeLength (ULEB128): 5
        // - jumpTable: (empty)
        // - code: [51, 0, 42, 0, 1] (LoadImm R0, 42, Halt)
        // - bitmask: 1 byte (since codeLength is 5, need 1 byte for bitmask)

        let blob = Data([
            0,              // jumpTableEntriesCount = 0
            8,              // encodeSize = 8
            5,              // codeLength = 5
            // No jump table data (0 entries * 8 bytes = 0 bytes)
            51, 0, 42, 0,   // LoadImm R0, 42
            1,              // Fallthrough (Halt)
            0               // bitmask (1 byte, all zeros = no instructions with special encoding)
        ])

        let config = DefaultPvmConfig()

        // Execute with JIT backend
        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        // We expect the program to halt or trap
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Simple Arithmetic Tests

    @Test func testJITLoadImmAdd() async throws {
        // Program: LoadImm 42, Add R0+R0, Halt
        // Expected: R0 = 84
        let code: [UInt8] = [
            51, 0, 42, 0,  // LoadImm R0, 42
            190, 0, 0,      // Add64 R0, R0, R0
            1,              // Fallthrough (Halt)
        ]

        let blob = Data(code)
        let config = DefaultPvmConfig()

        // Execute with JIT backend
        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        // We expect the program to halt successfully
        // For now, just verify it doesn't crash
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITLoadImmMultiple() async throws {
        // Program: LoadImm multiple registers
        let code: [UInt8] = [
            51, 0, 10, 0,   // LoadImm R0, 10
            51, 1, 20, 0,   // LoadImm R1, 20
            51, 2, 30, 0,   // LoadImm R2, 30
            1,              // Fallthrough (Halt)
        ]

        let blob = Data(code)
        let config = DefaultPvmConfig()

        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        // Verify successful execution
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITConditionalBranchEqual() async throws {
        // Program: Test BranchEq
        // LoadImm 10 into R0 and R1, BranchEq to halt (should branch)
        let code: [UInt8] = [
            51, 0, 10, 0,   // LoadImm R0, 10
            51, 1, 10, 0,   // LoadImm R1, 10
            170, 0, 1,      // BranchEq R0, R1, +5 (jump to halt)
            51, 0, 99, 0,   // LoadImm R0, 99 (should not execute)
            1,              // Fallthrough (Halt)
        ]

        let blob = Data(code)
        let config = DefaultPvmConfig()

        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITConditionalBranchNotEqual() async throws {
        // Program: Test BranchNe
        // LoadImm 10 into R0, 20 into R1, BranchNe to halt (should branch)
        let code: [UInt8] = [
            51, 0, 10, 0,   // LoadImm R0, 10
            51, 1, 20, 0,   // LoadImm R1, 20
            171, 0, 1,      // BranchNe R0, R1, +5 (jump to halt)
            51, 0, 99, 0,   // LoadImm R0, 99 (should not execute)
            1,              // Fallthrough (Halt)
        ]

        let blob = Data(code)
        let config = DefaultPvmConfig()

        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITUnconditionalJump() async throws {
        // Program: Test Jump
        let code: [UInt8] = [
            40, 4, 0, 0, 0,  // Jump to PC 8 (halt instruction)
            51, 0, 99, 0,    // LoadImm R0, 99 (should not execute)
            1,               // Fallthrough (Halt) - target of jump
        ]

        let blob = Data(code)
        let config = DefaultPvmConfig()

        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Memory Operations

    @Test func testJITLoadStore() async throws {
        // Program: Test LoadU8/StoreU8
        let code: [UInt8] = [
            51, 0, 42, 0,   // LoadImm R0, 42
            62, 0, 100, 0,  // StoreU8 R0, @100
            63, 1, 100, 0,  // LoadU8 R1, @100
            1,              // Fallthrough (Halt)
        ]

        let blob = Data(code)
        let config = DefaultPvmConfig()

        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Division Operations

    @Test func testJITDivision() async throws {
        // Program: Test DivU32
        // 100 / 5 = 20
        let code: [UInt8] = [
            51, 0, 100, 0,  // LoadImm R0, 100
            51, 1, 5, 0,    // LoadImm R1, 5
            206, 2, 0, 1,   // DivU32 R2, R0, R1 (R2 = 100 / 5 = 20)
            1,              // Fallthrough (Halt)
        ]

        let blob = Data(code)
        let config = DefaultPvmConfig()

        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Loop Test

    @Test func testJITSimpleLoop() async throws {
        // Program: Simple loop that counts down
        // This tests if the label-based compilation handles loops correctly
        var code: [UInt8] = []

        // Initialize: R0 = 5, R1 = 0
        code += [51, 0, 5, 0]    // LoadImm R0, 5
        code += [51, 1, 0, 0]    // LoadImm R1, 0

        // Loop start:
        // BranchEq R0, R2(zero), end (when R0 == 0, jump to end)
        code += [170, 0, 2]      // BranchEq R0, R2, ...
        // Calculate jump target (will be +6 to skip to end)
        let jumpOffset = UInt32(6)
        withUnsafeBytes(of: jumpOffset.littleEndian) { code += Array($0) }

        // Loop body: R1++, R0--
        code += [179, 1, 1, 1]   // AddU32 R1, R1, 1 (R1++)
        code += [180, 0, 0, 255] // AddU32 R0, R0, -1 (R0--)

        // Jump back to loop start
        // Loop start is at PC 8 (after 4 LoadImm instructions)
        code += [40]              // Jump
        let loopStart = UInt32(8 - (UInt32(code.count) + 4))
        withUnsafeBytes(of: loopStart.littleEndian) { code += Array($0) }

        // End: halt
        code += [1]               // Fallthrough (Halt)

        let blob = Data(code)
        let config = DefaultPvmConfig()

        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }
}
