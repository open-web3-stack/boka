// generated by polka.codes
// Integration tests for JIT-compiled code execution
//
// These tests verify that the JIT compiler produces correct results
// by comparing with expected outputs.

import Foundation
import Testing
import Utils

@testable import PolkaVM

// MARK: - Test Helpers

extension JITIntegrationTests {
    /// Builds a PVM blob from bytecode instructions
    /// - Parameter code: Array of bytecode instructions
    /// - Returns: Properly formatted PVM blob
    func buildBlob(from code: [UInt8]) -> Data {
        var blob = Data()

        // jumpTableEntriesCount (ULEB128): 0
        blob.append(0)

        // encodeSize: 8
        blob.append(8)

        // codeLength (ULEB128)
        var codeLength = code.count
        while codeLength > 0 {
            let byte = UInt8(codeLength & 0x7F)
            codeLength >>= 7
            blob.append(codeLength > 0 ? (byte | 0x80) : byte)
        }

        // No jump table data

        // Code
        blob.append(Data(code))

        // bitmask: calculate number of bytes needed
        let bitmaskSize = (code.count + 7) / 8
        for _ in 0..<bitmaskSize {
            blob.append(0)
        }

        return blob
    }

    /// Executes a PVM blob with the JIT backend
    /// - Parameter blob: The PVM program blob
    /// - Returns: Exit reason from execution
    func executeJIT(blob: Data) async throws -> ExitReason {
        let config = DefaultPvmConfig()
        let executor = ExecutorBackendJIT()
        return await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )
    }
}

// MARK: - Opcodes

// Use centralized PVM opcode definitions
typealias Opcode = PVMOpcodes

@Suite(.serialized)
struct JITIntegrationTests {
    // MARK: - Simple Compilation Test

    @Test func testJITCompilesSuccessfully() async throws {
        // Program: LoadImm 42, Halt
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 42, 0,  // LoadImm R0, 42
            Opcode.halt.rawValue           // Halt
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Simple Arithmetic Tests

    @Test func testJITLoadImmAdd() async throws {
        // Program: LoadImm 42, Add R0+R0, Halt
        // Expected: R0 = 84
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 42, 0,  // LoadImm R0, 42
            Opcode.add32.rawValue, 0, 0,         // Add32 R0, R0, R0
            Opcode.halt.rawValue           // Halt
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITLoadImmMultiple() async throws {
        // Program: LoadImm multiple registers
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 10, 0,  // LoadImm R0, 10
            Opcode.loadImm.rawValue, 1, 20, 0,  // LoadImm R1, 20
            Opcode.loadImm.rawValue, 2, 30, 0,  // LoadImm R2, 30
            Opcode.halt.rawValue           // Halt
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITUnconditionalJump() async throws {
        // Program: Jump over LoadImm to reach Halt
        let code: [UInt8] = [
            Opcode.jump.rawValue, 4, 0, 0, 0,   // Jump forward 4 bytes (to halt)
            Opcode.loadImm.rawValue, 0, 99, 0,  // LoadImm R0, 99 (should not execute)
            Opcode.halt.rawValue           // Halt (jump target)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITDivision() async throws {
        // Program: DivU32 100 / 5 = 20
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 100, 0,  // LoadImm R0, 100
            Opcode.loadImm.rawValue, 1, 5, 0,    // LoadImm R1, 5
            Opcode.divU32.rawValue, 2, 0,        // DivU32 R2, R0, R1
            Opcode.halt.rawValue           // Halt
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // TODO: Add tests for conditional branches, loops, load/store operations
    // These require proper blob format encoding with correct instruction sizes
}
