// generated by polka.codes
// Integration tests for JIT-compiled code execution
//
// These tests verify that the JIT compiler produces correct results
// by comparing with expected outputs.

import Foundation
import Testing
import Utils

@testable import PolkaVM

@Suite(.serialized)
struct JITIntegrationTests {
    // MARK: - Simple Compilation Test

    @Test func testJITCompilesSuccessfully() async throws {
        // Minimal test: just verify JIT compilation doesn't crash
        // Program: LoadImm 42, Halt

        // Blob format:
        // - jumpTableEntriesCount (ULEB128): 0
        // - encodeSize: 8
        // - codeLength (ULEB128): 5
        // - jumpTable: (empty)
        // - code: [51, 0, 42, 0, 1] (LoadImm R0, 42, Halt)
        // - bitmask: 1 byte (since codeLength is 5, need 1 byte for bitmask)

        let blob = Data([
            0,              // jumpTableEntriesCount = 0
            8,              // encodeSize = 8
            5,              // codeLength = 5
            // No jump table data (0 entries * 8 bytes = 0 bytes)
            51, 0, 42, 0,   // LoadImm R0, 42
            1,              // Fallthrough (Halt)
            0               // bitmask (1 byte, all zeros = no instructions with special encoding)
        ])

        let config = DefaultPvmConfig()

        // Execute with JIT backend
        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        // We expect the program to halt or trap
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Simple Arithmetic Tests

    @Test func testJITLoadImmAdd() async throws {
        // Program: LoadImm 42, Add R0+R0, Halt
        // Expected: R0 = 84

        // Blob format: [jumpCount=0][encodeSize=8][codeLen=7][code][bitmask=0]
        let blob = Data([
            0,              // jumpTableEntriesCount = 0
            8,              // encodeSize = 8
            7,              // codeLength = 7
            // Code:
            51, 0, 42, 0,  // LoadImm R0, 42
            190, 0, 0,      // Add32 R0, R0, R0
            1,              // Fallthrough (Halt)
            0               // bitmask
        ])

        let config = DefaultPvmConfig()
        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITLoadImmMultiple() async throws {
        // Program: LoadImm multiple registers
        // Blob: [jumpCount=0][encodeSize=8][codeLen=13][code][bitmask=0]
        let blob = Data([
            0,              // jumpTableEntriesCount = 0
            8,              // encodeSize = 8
            13,             // codeLength = 13
            // Code:
            51, 0, 10, 0,   // LoadImm R0, 10
            51, 1, 20, 0,   // LoadImm R1, 20
            51, 2, 30, 0,   // LoadImm R2, 30
            1,              // Fallthrough (Halt)
            0               // bitmask
        ])

        let config = DefaultPvmConfig()
        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITUnconditionalJump() async throws {
        // Program: Test Jump
        // Blob: [jumpCount=0][encodeSize=8][codeLen=10][code][bitmask=0]
        let blob = Data([
            0,              // jumpTableEntriesCount = 0
            8,              // encodeSize = 8
            10,             // codeLength = 10
            // Code:
            40, 4, 0, 0, 0,  // Jump to PC 8 (halt instruction)
            51, 0, 99, 0,    // LoadImm R0, 99 (should not execute)
            1,                // Fallthrough (Halt) - target of jump
            0                 // bitmask
        ])

        let config = DefaultPvmConfig()
        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITDivision() async throws {
        // Program: Test DivU32
        // 100 / 5 = 20
        // Blob: [jumpCount=0][encodeSize=8][codeLen=10][code][bitmask=0]
        let blob = Data([
            0,              // jumpTableEntriesCount = 0
            8,              // encodeSize = 8
            10,             // codeLength = 10
            // Code:
            51, 0, 100, 0,  // LoadImm R0, 100
            51, 1, 5, 0,    // LoadImm R1, 5
            193, 2, 0,      // DivU32 R2, R0, R1 (R2 = 100 / 5 = 20)
            1,              // Fallthrough (Halt)
            0               // bitmask
        ])

        let config = DefaultPvmConfig()
        let executor = ExecutorBackendJIT()
        let exitReason = await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // TODO: Add tests for conditional branches, loops, load/store operations
    // These require proper blob format encoding with correct instruction sizes
}
