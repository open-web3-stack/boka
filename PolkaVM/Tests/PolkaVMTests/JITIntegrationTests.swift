// generated by polka.codes
// Integration tests for JIT-compiled code execution
//
// These tests verify that the JIT compiler produces correct results
// by comparing with expected outputs.

import Foundation
import Testing
import Utils

@testable import PolkaVM

// MARK: - Test Helpers

extension JITIntegrationTests {
    /// Builds a PVM blob from bytecode instructions
    /// - Parameter code: Array of bytecode instructions
    /// - Returns: Properly formatted PVM blob
    func buildBlob(from code: [UInt8]) -> Data {
        var blob = Data()

        // jumpTableEntriesCount (ULEB128): 0
        blob.append(0)

        // encodeSize: 8
        blob.append(8)

        // codeLength (ULEB128)
        var codeLength = code.count
        while codeLength > 0 {
            let byte = UInt8(codeLength & 0x7F)
            codeLength >>= 7
            blob.append(codeLength > 0 ? (byte | 0x80) : byte)
        }

        // No jump table data

        // Code
        blob.append(Data(code))

        // bitmask: calculate number of bytes needed
        let bitmaskSize = (code.count + 7) / 8
        for _ in 0..<bitmaskSize {
            blob.append(0)
        }

        return blob
    }

    /// Executes a PVM blob with the JIT backend
    /// - Parameter blob: The PVM program blob
    /// - Returns: Exit reason from execution
    func executeJIT(blob: Data) async throws -> ExitReason {
        let config = DefaultPvmConfig()
        let executor = ExecutorBackendJIT()
        return await executor.execute(
            config: config,
            blob: blob,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: nil,
            ctx: nil
        )
    }
}

// MARK: - Opcodes

// Use centralized PVM opcode definitions
typealias Opcode = PVMOpcodes

@Suite(.serialized)
struct JITIntegrationTests {
    // MARK: - Simple Compilation Test

    @Test func testJITCompilesSuccessfully() async throws {
        // Program: LoadImm 42, Halt
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 42, 0, 0, 0,  // LoadImm R0, 42 (6 bytes: opcode + reg + value_32bit)
            Opcode.halt.rawValue           // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Simple Arithmetic Tests

    @Test func testJITLoadImmAdd() async throws {
        // Program: LoadImm 42, Add R0+R0, Halt
        // Expected: R0 = 84
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 42, 0, 0, 0,  // LoadImm R0, 42 (6 bytes)
            Opcode.add32.rawValue, 0, 0,               // Add32 R0, R0, R0 (3 bytes)
            Opcode.halt.rawValue                       // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITLoadImmMultiple() async throws {
        // Program: LoadImm multiple registers
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 10, 0, 0, 0,  // LoadImm R0, 10 (6 bytes)
            Opcode.loadImm.rawValue, 1, 20, 0, 0, 0,  // LoadImm R1, 20 (6 bytes)
            Opcode.loadImm.rawValue, 2, 30, 0, 0, 0,  // LoadImm R2, 30 (6 bytes)
            Opcode.halt.rawValue                       // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITUnconditionalJump() async throws {
        // Program: Jump over LoadImm to reach Halt
        // Bytecode layout:
        // [0-4]:   Jump instruction (5 bytes: opcode + offset)
        // [5-10]:  LoadImm (6 bytes) - should be skipped
        // [11]:    Halt (1 byte) - jump target
        let code: [UInt8] = [
            Opcode.jump.rawValue, 6, 0, 0, 0,   // Jump forward 6 bytes (skip LoadImm)
            Opcode.loadImm.rawValue, 0, 99, 0, 0, 0,  // LoadImm R0, 99 (6 bytes, should not execute)
            Opcode.halt.rawValue                       // Halt (1 byte, jump target)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITDivision() async throws {
        // Program: DivU32 100 / 5 = 20
        // DivU32 does: dest_reg = dest_reg / src_reg
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 2, 100, 0, 0, 0,  // LoadImm R2, 100 (6 bytes) - dividend
            Opcode.loadImm.rawValue, 0, 5, 0, 0, 0,    // LoadImm R0, 5 (6 bytes) - divisor
            Opcode.divU32.rawValue, 2, 0,              // DivU32 R2, R0 -> R2 = R2 / R0 = 20 (3 bytes)
            Opcode.halt.rawValue                       // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Memory Bounds Checking Tests

    @Test func testJITLoadValidAddress() async throws {
        // Program: Load from valid address (>= 65536)
        // Setup: R0 = 100000 (valid address), LoadU8 R1, [R0], Halt
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 160, 134, 1, 0,  // LoadImm R0, 100000 (6 bytes) - valid address
            Opcode.loadU8.rawValue, 1, 0, 0, 0,          // LoadU8 R1, [R0 + offset 0] (6 bytes)
            Opcode.halt.rawValue                           // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should halt successfully (memory access is within bounds for UInt32.max)
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITLoadPanicAddress() async throws {
        // Program: Load from address < 65536 → should panic
        // Setup: R0 = 1000 (panic address), LoadU8 R1, [R0], Halt
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 232, 3, 0, 0,    // LoadImm R0, 1000 (6 bytes) - < 65536
            Opcode.loadU8.rawValue, 1, 0, 0, 0,          // LoadU8 R1, [R0 + offset 0] (6 bytes)
            Opcode.halt.rawValue                           // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should panic (address < 65536)
        #expect(exitReason == .panic(.trap))
    }

    @Test func testJITStoreValidAddress() async throws {
        // Program: Store to valid address (>= 65536)
        // Setup: R0 = 100000 (valid address), R1 = 42, StoreU8 [R0], R1, Halt
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 160, 134, 1, 0,  // LoadImm R0, 100000 (6 bytes) - valid address
            Opcode.loadImm.rawValue, 1, 42, 0, 0, 0,     // LoadImm R1, 42 (6 bytes)
            Opcode.storeU8.rawValue, 0, 1, 0, 0,         // StoreU8 [R0 + offset 0], R1 (6 bytes)
            Opcode.halt.rawValue                           // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should halt successfully (memory access is within bounds for UInt32.max)
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITStorePanicAddress() async throws {
        // Program: Store to address < 65536 → should panic
        // Setup: R0 = 1000 (panic address), R1 = 42, StoreU8 [R0], R1, Halt
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 232, 3, 0, 0,    // LoadImm R0, 1000 (6 bytes) - < 65536
            Opcode.loadImm.rawValue, 1, 42, 0, 0, 0,     // LoadImm R1, 42 (6 bytes)
            Opcode.storeU8.rawValue, 0, 1, 0, 0,         // StoreU8 [R0 + offset 0], R1 (6 bytes)
            Opcode.halt.rawValue                           // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should panic (address < 65536)
        #expect(exitReason == .panic(.trap))
    }

    // MARK: - StoreImm Instruction Tests

    @Test func testJITStoreImmU8() async throws {
        // Program: StoreImmU8 42 to address 100000, then Halt
        let code: [UInt8] = [
            Opcode.storeImmU8.rawValue, 42, 160, 134, 1, 0,  // StoreImmU8 42, address=100000 (6 bytes)
            Opcode.halt.rawValue                                  // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should halt successfully
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITStoreImmU8PanicAddress() async throws {
        // Program: StoreImmU8 42 to address < 65536 → should panic
        let code: [UInt8] = [
            Opcode.storeImmU8.rawValue, 42, 100, 0, 0, 0,     // StoreImmU8 42, address=100 (6 bytes) - < 65536
            Opcode.halt.rawValue                                  // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should panic (address < 65536)
        #expect(exitReason == .panic(.trap))
    }

    @Test func testJITStoreImmU32() async throws {
        // Program: StoreImmU32 0xDEADBEEF to address 100000, then Halt
        // 100000 in hex = 0x000186A0, bytes: [0xA0, 0x86, 0x01, 0x00]
        let code: [UInt8] = [
            Opcode.storeImmU32.rawValue, 0xEF, 0xBE, 0xAD, 0xDE, 160, 134, 1, 0,  // StoreImmU32 0xDEADBEEF, address=100000 (9 bytes)
            Opcode.halt.rawValue                                                        // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should halt successfully
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITStoreImmU64() async throws {
        // Program: StoreImmU64 0x123456789ABCDEF0 to address 100000, then Halt
        // 100000 in hex = 0x000186A0, bytes: [0xA0, 0x86, 0x01, 0x00]
        let code: [UInt8] = [
            Opcode.storeImmU64.rawValue, 0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12, 160, 134, 1, 0,  // StoreImmU64, address=100000 (13 bytes)
            Opcode.halt.rawValue                                                                            // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should halt successfully
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    // MARK: - Negative Offset Tests

    @Test func testJITLoadWithNegativeOffset() async throws {
        // Program: Load from base address 100000 with offset -4
        // Setup: R0 = 100000, LoadU8 R1, [R0 - 4], Halt
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 160, 134, 1, 0,  // LoadImm R0, 100000 (6 bytes)
            Opcode.loadU8.rawValue, 1, 0, 252, 255,       // LoadU8 R1, [R0 - 4] (6 bytes, offset=-4 as 0xFFFC)
            Opcode.halt.rawValue                           // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should halt successfully (100000 - 4 = 99996, still >= 65536)
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITStoreWithNegativeOffset() async throws {
        // Program: Store to base address 100000 with offset -8
        // Setup: R0 = 100000, R1 = 99, StoreU8 [R0 - 8], R1, Halt
        let code: [UInt8] = [
            Opcode.loadImm.rawValue, 0, 160, 134, 1, 0,  // LoadImm R0, 100000 (6 bytes)
            Opcode.loadImm.rawValue, 1, 99, 0, 0, 0,     // LoadImm R1, 99 (6 bytes)
            Opcode.storeU8.rawValue, 0, 1, 248, 255,      // StoreU8 [R0 - 8], R1 (6 bytes, offset=-8 as 0xFFF8)
            Opcode.halt.rawValue                           // Halt (1 byte)
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should halt successfully (100000 - 8 = 99992, still >= 65536)
        #expect(exitReason == .halt || exitReason == .panic(.trap))
    }

    @Test func testJITStoreImmPageFault() async throws {
        // Program: StoreImmU8 42 to address beyond memory size
        // With default config: 16 heap + 16 stack pages = 32 pages * 4096 bytes = 131072 bytes
        // Address 132000 should trigger page fault
        // 132000 in hex = 0x000203A0, bytes: [0xA0, 0x03, 0x02, 0x00]
        let code: [UInt8] = [
            Opcode.storeImmU8.rawValue, 42, 160, 3, 2, 0,  // StoreImmU8 42, address=132000 (beyond 131072)
            Opcode.halt.rawValue
        ]

        let blob = buildBlob(from: code)
        let exitReason = try await executeJIT(blob: blob)

        // Should page fault (address >= memory_size)
        #expect(exitReason == .pageFault(132000))
    }

    // TODO: Add tests for conditional branches, loops
}
