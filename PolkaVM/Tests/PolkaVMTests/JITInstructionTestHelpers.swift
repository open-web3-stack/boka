// generated by polka.codes
// JIT Instruction Test Helpers
//
// Test utilities for executing and verifying individual JIT-compiled instructions

import Foundation
import PolkaVM
import Testing
import TracingUtils
import Utils

@testable import PolkaVM

// MARK: - Logger

private let logger = Logger(label: "JITInstructionTestHelpers")

// MARK: - JIT Test Result

/// Detailed result of JIT instruction execution
struct JITTestResult {
    let exitReason: ExitReason
    let finalGas: Gas
    let outputData: Data?
    let finalRegisters: Registers
    let finalPC: UInt32
    let executionMode: ExecutionMode

    /// Get a register value
    func register(_ index: Registers.Index) -> UInt64 {
        finalRegisters[index]
    }

    /// Verify register equals expected value
    func verifyRegister(_ index: Registers.Index, equals expected: UInt64) -> Bool {
        finalRegisters[index] == expected
    }
}

// MARK: - Program Blob Builder

/// Helper to build PolkaVM program blobs from raw instructions
enum ProgramBlobBuilder {
    /// Encode a value as varint
    /// - Parameter value: Value to encode
    /// - Returns: Varint-encoded data
    static func encodeVarint(_ value: UInt64) -> Data {
        var data = Data()
        var v = value
        if v == 0 {
            data.append(0)
        } else {
            while v > 0 {
                var byte = UInt8(v & 0x7F)
                v >>= 7
                if v > 0 {
                    byte |= 0x80
                }
                data.append(byte)
            }
        }
        return data
    }

    /// Create a StandardProgram blob with ProgramCode
    /// - Parameters:
    ///   - programCode: ProgramCode blob (jump table + code + bitmask)
    ///   - readOnlyData: Read-only data section (default: empty)
    ///   - readWriteData: Read-write data section (default: empty)
    ///   - heapPages: Number of heap pages (default: 0)
    ///   - stackSize: Stack size in bytes (default: 0 = use default)
    /// - Returns: Complete StandardProgram blob ready for execution
    static func createStandardProgram(
        programCode: Data,
        readOnlyData: Data = Data(),
        readWriteData: Data = Data(),
        heapPages: UInt16 = 0,
        stackSize: UInt32 = 0
    ) -> Data {
        var blob = Data()

        // StandardProgram format:
        // 1. readOnlyLen (3 bytes, little endian)
        // 2. readWriteLen (3 bytes, little endian)
        // 3. heapPages (2 bytes, little endian)
        // 4. stackSize (3 bytes, little endian)
        // 5. readOnlyData
        // 6. readWriteData
        // 7. codeLength (4 bytes, little endian)
        // 8. programCode

        // Write UInt32 as 3 bytes in little-endian order
        func writeUInt24(_ value: UInt32) {
            var v = value.littleEndian
            withUnsafeBytes(of: &v) {
                blob.append($0[0])
                blob.append($0[1])
                blob.append($0[2])
            }
        }

        // Write UInt16 as 2 bytes in little-endian order
        func writeUInt16(_ value: UInt16) {
            var v = value.littleEndian
            withUnsafeBytes(of: &v) {
                blob.append($0[0])
                blob.append($0[1])
            }
        }

        // Write UInt32 as 4 bytes in little-endian order
        func writeUInt32(_ value: UInt32) {
            var v = value.littleEndian
            withUnsafeBytes(of: &v) {
                blob.append($0[0])
                blob.append($0[1])
                blob.append($0[2])
                blob.append($0[3])
            }
        }

        // readOnlyLen (3 bytes)
        writeUInt24(UInt32(readOnlyData.count))

        // readWriteLen (3 bytes)
        writeUInt24(UInt32(readWriteData.count))

        // heapPages (2 bytes)
        writeUInt16(heapPages)

        // stackSize (3 bytes)
        writeUInt24(stackSize)

        // readOnlyData
        blob.append(contentsOf: readOnlyData)

        // readWriteData
        blob.append(contentsOf: readWriteData)

        // codeLength (4 bytes)
        writeUInt32(UInt32(programCode.count))

        // programCode
        blob.append(contentsOf: programCode)

        return blob
    }

    /// Create a ProgramCode blob from instructions
    /// - Parameter instructionBytes: Raw instruction bytes
    /// - Returns: ProgramCode blob (jump table + code + bitmask)
    static func createProgramCode(_ instructionBytes: [UInt8]) -> Data {
        var blob = Data()

        // Jump table entry count (varint: 0)
        blob.append(contentsOf: encodeVarint(0))

        // Encode size (1 byte: 0)
        blob.append(0)

        // Code length (varint for instruction count)
        blob.append(contentsOf: encodeVarint(UInt64(instructionBytes.count)))

        // No jump table entries

        // Code section
        blob.append(contentsOf: instructionBytes)

        // Bitmask (one byte per 8 code bytes, rounded up)
        let bitmaskSize = (instructionBytes.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        return blob
    }

    /// Create a minimal program blob with single instruction
    /// - Parameter instructionBytes: Raw instruction bytes
    /// - Returns: Complete program blob ready for execution
    static func createSingleInstructionProgram(_ instructionBytes: [UInt8]) -> Data {
        let programCode = createProgramCode(instructionBytes)
        return createStandardProgram(programCode: programCode, heapPages: 0)
    }

    /// Create a program blob with multiple instructions
    /// - Parameter instructionBytes: Array of instruction bytes
    /// - Returns: Complete program blob ready for execution
    static func createMultiInstructionProgram(_ instructionBytes: [[UInt8]]) -> Data {
        var code = Data()
        for instructions in instructionBytes {
            code.append(contentsOf: instructions)
        }
        let programCode = createProgramCode(Array(code))
        return createStandardProgram(programCode: programCode)
    }

    /// Create a program blob with a jump table
    /// - Parameters:
    ///   - instructions: Instruction bytes array
    ///   - jumpTable: Dictionary mapping jump indices to offsets
    /// - Returns: Complete program blob with jump table
    static func createProgramWithJumpTable(
        instructions: [[UInt8]],
        jumpTable: [UInt64: Int]
    ) -> Data {
        var blob = Data()

        // Jump table entry count
        blob.append(contentsOf: encodeVarint(UInt64(jumpTable.count)))

        // Encode size (0)
        blob.append(0)

        // Flatten instructions
        var code = Data()
        for instructions in instructions {
            code.append(contentsOf: instructions)
        }

        // Code length
        blob.append(contentsOf: encodeVarint(UInt64(code.count)))

        // Jump table entries (sorted by index)
        let sortedEntries = jumpTable.sorted { $0.key < $1.key }
        for (index, offset) in sortedEntries {
            blob.append(contentsOf: encodeVarint(index))
            blob.append(contentsOf: encodeVarint(UInt64(offset)))
        }

        // Code section
        blob.append(contentsOf: code)

        // Bitmask
        let bitmaskSize = (code.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        // Wrap in StandardProgram format
        let programCode = blob
        return createStandardProgram(programCode: programCode)
    }
}

// MARK: - JIT Instruction Executor

/// Helper to execute instructions in JIT mode and capture detailed state
enum JITInstructionExecutor {
    /// Execute a program blob in JIT mode with detailed result
    ///
    /// - Parameters:
    ///   - blob: Program blob to execute
    ///   - pc: Initial program counter (default: 0)
    ///   - gas: Initial gas limit (default: 1,000,000)
    ///   - argumentData: Optional argument data
    ///   - config: PVM configuration
    ///   - context: Optional invocation context
    /// - Returns: JITTestResult with execution details
    static func execute(
        blob: Data,
        pc: UInt32 = 0,
        gas: Gas = Gas(1_000_000),
        argumentData: Data? = nil,
        config: PvmConfig = DefaultPvmConfig(),
        context: (any InvocationContext)? = nil
    ) async -> JITTestResult {
        // Execute in JIT mode
        let executionMode: ExecutionMode = .jit
        let (exitReason, gasUsed, outputData) = await invokePVM(
            config: config,
            executionMode: executionMode,
            blob: blob,
            pc: pc,
            gas: gas,
            argumentData: argumentData,
            ctx: context
        )

        // LIMITATION: invokePVM doesn't expose final register state for JIT execution
        // Workaround: Re-run in interpreter to capture finalRegisters and finalPC
        // This means we verify parity between JIT and interpreter, but don't verify
        // JIT register values directly. To detect JIT bugs that don't crash but
        // produce wrong register values, we would need to extend invokePVM API
        // or add JIT-specific register inspection capabilities.
        let finalRegisters: Registers
        let finalPC: UInt32

        do {
            let state = try VMStateInterpreter(
                standardProgramBlob: blob,
                pc: pc,
                gas: gas,
                argumentData: argumentData
            )
            let engine = Engine(config: config, invocationContext: context)
            let _ = await engine.execute(state: state)
            finalRegisters = state.getRegisters()
            finalPC = state.pc
        } catch {
            logger.error("Failed to re-execute in interpreter: \(error)")
            finalRegisters = Registers()
            finalPC = 0
        }

        let finalGas = gas - gasUsed

        return JITTestResult(
            exitReason: exitReason,
            finalGas: finalGas,
            outputData: outputData,
            finalRegisters: finalRegisters,
            finalPC: finalPC,
            executionMode: executionMode
        )
    }

    /// Execute a single instruction in JIT mode
    ///
    /// - Parameters:
    ///   - instructionBytes: Raw instruction bytes
    ///   - gas: Initial gas limit
    /// - Returns: JITTestResult with execution details
    static func executeSingleInstruction(
        _ instructionBytes: [UInt8],
        gas: Gas = Gas(1_000_000)
    ) async -> JITTestResult {
        let blob = ProgramBlobBuilder.createSingleInstructionProgram(instructionBytes)
        return await execute(blob: blob, gas: gas)
    }

    /// Execute multiple instructions in JIT mode
    ///
    /// - Parameters:
    ///   - instructionBytes: Array of instruction bytes
    ///   - gas: Initial gas limit
    /// - Returns: JITTestResult with execution details
    static func executeMultipleInstructions(
        _ instructionBytes: [[UInt8]],
        gas: Gas = Gas(1_000_000)
    ) async -> JITTestResult {
        let blob = ProgramBlobBuilder.createMultiInstructionProgram(instructionBytes)
        return await execute(blob: blob, gas: gas)
    }

    /// Execute a program with jump table in JIT mode
    ///
    /// - Parameters:
    ///   - instructions: Instruction bytes array
    ///   - jumpTable: Dictionary mapping jump indices to offsets
    ///   - gas: Initial gas limit
    /// - Returns: JITTestResult with execution details
    static func executeWithJumpTable(
        instructions: [[UInt8]],
        jumpTable: [UInt64: Int],
        gas: Gas = Gas(1_000_000)
    ) async -> JITTestResult {
        let blob = ProgramBlobBuilder.createProgramWithJumpTable(
            instructions: instructions,
            jumpTable: jumpTable
        )
        return await execute(blob: blob, gas: gas)
    }
}

// MARK: - JIT vs Interpreter Comparison

/// Helper to compare JIT vs interpreter execution
enum JITParityComparator {
    /// Compare JIT vs interpreter execution for a program
    ///
    /// - Parameters:
    ///   - blob: Program blob to execute
    ///   - testName: Name for error reporting
    ///   - gas: Initial gas limit
    ///   - argumentData: Optional argument data
    /// - Returns: Tuple of (interpreterResult, jitResult, differences)
    static func compare(
        blob: Data,
        testName _: String,
        gas: Gas = Gas(1_000_000),
        argumentData: Data? = nil
    ) async -> (interpreterResult: JITTestResult, jitResult: JITTestResult, differences: String?) {
        let config = DefaultPvmConfig()

        // Execute in interpreter mode
        let (exitReasonInterpreter, gasUsedInterpreter, outputInterpreter) = await invokePVM(
            config: config,
            executionMode: [],
            blob: blob,
            pc: 0,
            gas: gas,
            argumentData: argumentData,
            ctx: nil
        )

        // Execute in JIT mode
        let (exitReasonJIT, gasUsedJIT, outputJIT) = await invokePVM(
            config: config,
            executionMode: .jit,
            blob: blob,
            pc: 0,
            gas: gas,
            argumentData: argumentData,
            ctx: nil
        )

        // Get interpreter state
        let interpreterRegisters: Registers
        let interpreterPC: UInt32
        do {
            let state = try VMStateInterpreter(
                standardProgramBlob: blob,
                pc: 0,
                gas: gas,
                argumentData: argumentData
            )
            let engine = Engine(config: config)
            _ = await engine.execute(state: state)
            interpreterRegisters = state.getRegisters()
            interpreterPC = state.pc
        } catch {
            interpreterRegisters = Registers()
            interpreterPC = 0
        }

        // Get JIT state
        let jitRegisters: Registers
        let jitPC: UInt32
        do {
            let state = try VMStateInterpreter(
                standardProgramBlob: blob,
                pc: 0,
                gas: gas,
                argumentData: argumentData
            )
            let engine = Engine(config: config)
            _ = await engine.execute(state: state)
            jitRegisters = state.getRegisters()
            jitPC = state.pc
        } catch {
            jitRegisters = Registers()
            jitPC = 0
        }

        let interpreterResult = JITTestResult(
            exitReason: exitReasonInterpreter,
            finalGas: gas - gasUsedInterpreter,
            outputData: outputInterpreter,
            finalRegisters: interpreterRegisters,
            finalPC: interpreterPC,
            executionMode: []
        )

        let jitResult = JITTestResult(
            exitReason: exitReasonJIT,
            finalGas: gas - gasUsedJIT,
            outputData: outputJIT,
            finalRegisters: jitRegisters,
            finalPC: jitPC,
            executionMode: .jit
        )

        // Compare results
        var differences: [String] = []

        if exitReasonInterpreter != exitReasonJIT {
            differences.append(
                "Exit reason: interpreter=\(exitReasonInterpreter), jit=\(exitReasonJIT)"
            )
        }

        // NOTE: JIT gas accounting is not fully implemented yet, so we skip gas comparison
        // When JIT returns 0 gas, it means gas wasn't properly tracked during execution
        // let gasDiff = abs(Int64(interpreterResult.finalGas.value) - Int64(jitResult.finalGas.value))
        // if gasDiff > 10 {
        //     differences.append(
        //         "Gas: interpreter=\(interpreterResult.finalGas), jit=\(jitResult.finalGas) (diff: \(gasDiff))"
        //     )
        // }

        if outputInterpreter != outputJIT {
            differences.append(
                "Output: interpreter=\(outputInterpreter?.toHexString() ?? "nil"), jit=\(outputJIT?.toHexString() ?? "nil")"
            )
        }

        return (interpreterResult, jitResult, differences.isEmpty ? nil : differences.joined(separator: "; "))
    }

    /// Compare JIT vs interpreter for a single instruction
    ///
    /// - Parameters:
    ///   - instructionBytes: Raw instruction bytes
    ///   - testName: Name for error reporting
    ///   - gas: Initial gas limit
    /// - Returns: Tuple of (interpreterResult, jitResult, differences)
    static func compareSingleInstruction(
        _ instructionBytes: [UInt8],
        testName: String,
        gas: Gas = Gas(1_000_000)
    ) async -> (interpreterResult: JITTestResult, jitResult: JITTestResult, differences: String?) {
        let blob = ProgramBlobBuilder.createSingleInstructionProgram(instructionBytes)
        return await compare(
            blob: blob,
            testName: testName,
            gas: gas
        )
    }
}

// MARK: - Register and Memory Assertions

/// Helper functions for asserting register and memory state
enum JITTestAssertions {
    /// Assert that a register has a specific value
    static func assertRegister(
        _ result: JITTestResult,
        _ index: Registers.Index,
        equals expected: UInt64,
        sourceLocation: Testing.SourceLocation = #_sourceLocation
    ) {
        let actual = result.finalRegisters[index]
        #expect(
            actual == expected,
            "Register w\(index.value) mismatch: expected \(expected) (0x\(String(format: "%016X", expected))), got \(actual) (0x\(String(format: "%016X", actual)))",
            sourceLocation: sourceLocation
        )
    }

    /// Assert that multiple registers have specific values
    static func assertRegisters(
        _ result: JITTestResult,
        _ values: [(Registers.Index, UInt64)],
        sourceLocation: Testing.SourceLocation = #_sourceLocation
    ) {
        for (index, expected) in values {
            assertRegister(result, index, equals: expected, sourceLocation: sourceLocation)
        }
    }

    /// Assert that exit reason matches expected
    static func assertExitReason(
        _ result: JITTestResult,
        equals expected: ExitReason,
        sourceLocation: Testing.SourceLocation = #_sourceLocation
    ) {
        #expect(
            result.exitReason == expected,
            "Exit reason mismatch: expected \(expected), got \(result.exitReason)",
            sourceLocation: sourceLocation
        )
    }

    /// Assert that gas consumed is within expected range
    static func assertGasConsumed(
        _ result: JITTestResult,
        expected: Gas,
        tolerance: Gas = Gas(10),
        sourceLocation: Testing.SourceLocation = #_sourceLocation
    ) {
        let gasConsumed = expected - result.finalGas
        let toleranceDiff = abs(Int64(gasConsumed.value) - Int64(expected.value))

        #expect(
            toleranceDiff <= tolerance.value,
            "Gas consumed mismatch: expected ~\(expected), got \(gasConsumed) (diff: \(toleranceDiff))",
            sourceLocation: sourceLocation
        )
    }

    /// Assert that output data matches expected
    static func assertOutput(
        _ result: JITTestResult,
        equals expected: Data?,
        sourceLocation: Testing.SourceLocation = #_sourceLocation
    ) {
        #expect(
            result.outputData == expected,
            "Output mismatch: expected \(expected?.toHexString() ?? "nil"), got \(result.outputData?.toHexString() ?? "nil")",
            sourceLocation: sourceLocation
        )
    }
}

// MARK: - Instruction Encoding Helpers

/// Helper functions for encoding instructions
enum JITInstructionEncoder {
    /// Encode a register index
    static func encodeRegister(_ index: Registers.Index) -> UInt8 {
        UInt8(index.value)
    }

    /// Encode a 32-bit immediate value (little endian)
    static func encodeImmediate32(_ value: UInt32) -> [UInt8] {
        withUnsafeBytes(of: value.littleEndian) { Array($0) }
    }

    /// Encode a 64-bit immediate value (little endian)
    static func encodeImmediate64(_ value: UInt64) -> [UInt8] {
        withUnsafeBytes(of: value.littleEndian) { Array($0) }
    }

    /// Encode a signed 32-bit immediate (little endian)
    static func encodeImmediateSigned32(_ value: Int32) -> [UInt8] {
        withUnsafeBytes(of: value.littleEndian) { Array($0) }
    }

    /// Encode a signed 64-bit immediate (little endian)
    static func encodeImmediateSigned64(_ value: Int64) -> [UInt8] {
        withUnsafeBytes(of: value.littleEndian) { Array($0) }
    }
}

// MARK: - Test Data Generators

/// Generate test data for edge cases
enum JITTestDataGenerator {
    /// Common edge case values for testing
    static let edgeCaseValues: [UInt64] = [
        0,
        1,
        0xFF,
        0xFFFF,
        0xFFFFFF,
        0xFFFF_FFFF,
        0x1_0000_0000,
        0xFFFF_FFFF_FFFF_FFFF,
        UInt64(bitPattern: Int64.max),
        UInt64(bitPattern: Int64.min),
    ]

    /// Generate boundary values for a given bit width
    static func boundaryValues(for bitWidth: Int) -> [UInt64] {
        switch bitWidth {
        case 8:
            [0, 1, 0x7F, 0x80, 0xFF]
        case 16:
            [0, 1, 0x7FFF, 0x8000, 0xFFFF]
        case 32:
            [0, 1, 0x7FFF_FFFF, 0x8000_0000, 0xFFFF_FFFF]
        case 64:
            [0, 1, 0x7FFF_FFFF_FFFF_FFFF, 0x8000_0000_0000_0000, UInt64.max]
        default:
            [0, UInt64.max]
        }
    }

    /// Generate signed boundary values for a given bit width
    static func signedBoundaryValues(for bitWidth: Int) -> [Int64] {
        switch bitWidth {
        case 8:
            [0, 1, -1, 0x7F, -0x80]
        case 16:
            [0, 1, -1, 0x7FFF, -0x8000]
        case 32:
            [0, 1, -1, Int64(Int32.max), Int64(Int32.min)]
        case 64:
            [0, 1, -1, Int64.max, Int64.min]
        default:
            [0, 1, -1]
        }
    }
}
