// generated by polka.codes
// JIT instruction-level parity tests
//
// These tests compare JIT vs interpreter execution for individual instructions
// to identify exactly where JIT behavior diverges from interpreter.

import Foundation
import PolkaVM
import Testing
import TracingUtils
import Utils

@testable import PolkaVM

private let logger = Logger(label: "JITInstructionParityTests")

/// JIT vs Interpreter parity tests
struct JITInstructionParityTests {
    /// Create a minimal test program with a single instruction
    private func createSingleInstructionProgram(_ instructionBytes: [UInt8]) -> Data {
        var blob = Data()

        // Jump table entry count (0 entries)
        let count = Data(UInt64(0).encode(method: .variableWidth))
        blob.append(contentsOf: count)

        // Encode size (0)
        blob.append(0)

        // Code length
        let codeLength = Data(UInt64(instructionBytes.count).encode(method: .variableWidth))
        blob.append(contentsOf: codeLength)

        // No jump table

        // Code
        blob.append(contentsOf: instructionBytes)

        // Bitmask (one byte per 8 code bytes, rounded up)
        let bitmaskSize = (instructionBytes.count + 7) / 8
        blob.append(contentsOf: Data(repeating: 0, count: bitmaskSize))

        return blob
    }

    /// Compare JIT vs interpreter execution
    private func compareExecution(
        instructionBytes: [UInt8],
        initialValue _: UInt64 = 0,
        testName: String
    ) async throws {
        let config = DefaultPvmConfig()
        let blob = createSingleInstructionProgram(instructionBytes)

        // Execute in interpreter mode
        let (exitReasonInterpreter, _, outputInterpreter) = await invokePVM(
            config: config,
            executionMode: [],
            blob: blob,
            pc: 0,
            gas: Gas(100_000),
            argumentData: nil,
            ctx: nil
        )

        // Execute in JIT mode
        let (exitReasonJIT, _, outputJIT) = await invokePVM(
            config: config,
            executionMode: .jit,
            blob: blob,
            pc: 0,
            gas: Gas(100_000),
            argumentData: nil,
            ctx: nil
        )

        // Compare exit reasons
        #expect(
            exitReasonInterpreter == exitReasonJIT,
            "\(testName): Exit reason mismatch - interpreter: \(exitReasonInterpreter), JIT: \(exitReasonJIT)"
        )

        // Compare outputs
        #expect(
            outputInterpreter == outputJIT,
            "\(testName): Output mismatch - interpreter: \(outputInterpreter?.toHexString() ?? "nil"), JIT: \(outputJIT?.toHexString() ?? "nil")"
        )
    }

    // MARK: - Load Immediate Instructions

    @Test("JIT vs Interpreter: LoadImm64")
    func testLoadImm64() async throws {
        // LoadImm64 r1, 0x123456789ABCDEF0
        // Opcode 0x33, dest_reg=0x01, immediate=0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12
        let instruction: [UInt8] = [
            0x33, 0x01, 0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12,
        ]
        try await compareExecution(
            instructionBytes: instruction,
            testName: "LoadImm64"
        )
    }

    @Test("JIT vs Interpreter: LoadImm32")
    func testLoadImm32() async throws {
        // LoadImm32 r1, 0x12345678 (sign-extended)
        // Opcode 0x32, dest_reg=0x01, immediate=0x78, 0x56, 0x34, 0x12
        let instruction: [UInt8] = [
            0x32, 0x01, 0x78, 0x56, 0x34, 0x12,
        ]
        try await compareExecution(
            instructionBytes: instruction,
            testName: "LoadImm32"
        )
    }

    @Test("JIT vs Interpreter: LoadImmU32")
    func testLoadImmU32() async throws {
        // LoadImmU32 r1, 0x12345678 (zero-extended)
        // Opcode 0x31, dest_reg=0x01, immediate=0x78, 0x56, 0x34, 0x12
        let instruction: [UInt8] = [
            0x31, 0x01, 0x78, 0x56, 0x34, 0x12,
        ]
        try await compareExecution(
            instructionBytes: instruction,
            testName: "LoadImmU32"
        )
    }

    // MARK: - Arithmetic Instructions

    @Test("JIT vs Interpreter: Add64")
    func testAdd64() async throws {
        // Need to setup initial registers first, then add
        // This is more complex and requires a multi-instruction program
        // For now, we'll skip this and test with real programs
    }

    // MARK: - Real Program Tests

    @Test("JIT vs Interpreter: SumToN program (N=10)")
    func testSumToN() async throws {
        let config = DefaultPvmConfig()

        let sumToN = Data([
            0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 46, 0, 0, 0, 0, 0, 38, 128, 119, 0,
            51, 8, 0, 100, 121, 40, 3, 0, 200, 137, 8, 149, 153, 255, 86, 9, 250,
            61, 8, 0, 0, 2, 0, 51, 8, 4, 51, 7, 0, 0, 2, 0, 1, 50, 0, 73, 77, 18,
            36, 24,
        ])

        let input: UInt8 = 10
        let expectedOutput = UInt32(55) // sum(1..10) = 55

        // Execute in interpreter mode
        let (exitReasonInterpreter, _, outputInterpreter) = await invokePVM(
            config: config,
            executionMode: [],
            blob: sumToN,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: Data([input]),
            ctx: nil
        )

        // Execute in JIT mode
        let (exitReasonJIT, _, outputJIT) = await invokePVM(
            config: config,
            executionMode: .jit,
            blob: sumToN,
            pc: 0,
            gas: Gas(1_000_000),
            argumentData: Data([input]),
            ctx: nil
        )

        // Verify interpreter produces correct output
        let valueInterpreter = outputInterpreter?.withUnsafeBytes { $0.loadUnaligned(as: UInt32.self) } ?? 0
        #expect(
            valueInterpreter == expectedOutput,
            "Interpreter output incorrect: expected \(expectedOutput), got \(valueInterpreter)"
        )

        // Verify JIT produces correct output
        let valueJIT = outputJIT?.withUnsafeBytes { $0.loadUnaligned(as: UInt32.self) } ?? 0
        #expect(
            valueJIT == expectedOutput,
            "JIT output incorrect: expected \(expectedOutput), got \(valueJIT)"
        )

        // Verify both match
        #expect(
            exitReasonInterpreter == exitReasonJIT,
            "Exit reason mismatch - interpreter: \(exitReasonInterpreter), JIT: \(exitReasonJIT)"
        )

        #expect(
            outputInterpreter == outputJIT,
            "Output mismatch - interpreter: \(outputInterpreter?.toHexString() ?? "nil"), JIT: \(outputJIT?.toHexString() ?? "nil")"
        )
    }

    @Test("JIT vs Interpreter: Halt program")
    func testHalt() async throws {
        let config = DefaultPvmConfig()

        // Minimal halt program
        let haltProgram = Data([
            1, // 1 jump table entry
            0, 0, 0, 0, 0, 0, 0, 0, // jump table entry 0: offset 0
            0x01, // halt instruction (opcode 1)
        ])

        // Execute in interpreter mode
        let (exitReasonInterpreter, _, outputInterpreter) = await invokePVM(
            config: config,
            executionMode: [],
            blob: haltProgram,
            pc: 0,
            gas: Gas(100_000),
            argumentData: nil,
            ctx: nil
        )

        // Execute in JIT mode
        let (exitReasonJIT, _, outputJIT) = await invokePVM(
            config: config,
            executionMode: .jit,
            blob: haltProgram,
            pc: 0,
            gas: Gas(100_000),
            argumentData: nil,
            ctx: nil
        )

        // Both should halt
        #expect(exitReasonInterpreter == .halt, "Interpreter should halt: got \(exitReasonInterpreter)")
        #expect(exitReasonJIT == .halt, "JIT should halt: got \(exitReasonJIT)")

        // Both should have no output
        #expect(outputInterpreter == nil, "Interpreter should have no output")
        #expect(outputJIT == nil, "JIT should have no output")
    }
}
