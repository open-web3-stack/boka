// generated by polka.codes
// JIT Arithmetic Instruction Tests
//
// Tests for arithmetic instructions: Add, Sub, Mul, Div, Rem, Shlo, Shro, Shar
// and their immediate variants

import Foundation
@testable import PolkaVM
import Testing
import TracingUtils
import Utils

private let logger = Logger(label: "JITArithmeticTests")

/// JIT Arithmetic Instruction Tests
@Suite
struct JITArithmeticTests {
    // MARK: - Add64/Sub64 Instructions (Opcodes 200-201)

    @Test
    func jitAdd64() async {
        // LoadImm64 r1, 100
        // LoadImm64 r2, 42
        // Add64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 100
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(100).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 42
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(42).littleEndian) { Array($0) })

        // Add64: [opcode][ra|rb<<4][rd] where rd = ra + rb
        code.append(PVMOpcodes.add64.rawValue) // Add64 opcode
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // r3 should contain 142
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 142)
    }

    @Test
    func jitAdd64Overflow() async {
        // LoadImm64 r1, UInt64.max
        // LoadImm64 r2, 1
        // Add64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, UInt64.max
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64.max.littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 1
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(1).littleEndian) { Array($0) })

        // Add64: [opcode][ra|rb<<4][rd] where rd = ra + rb
        code.append(PVMOpcodes.add64.rawValue) // Add64 opcode
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should wrap to 0
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0)
    }

    @Test
    func jitSub64() async {
        // LoadImm64 r1, 100
        // LoadImm64 r2, 42
        // Sub64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 100
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(100).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 42
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(42).littleEndian) { Array($0) })

        // Sub64: [opcode][ra|rb<<4][rd] where rd = ra - rb
        code.append(PVMOpcodes.sub64.rawValue) // Sub64 opcode
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // r3 should contain 58
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 58)
    }

    @Test
    func jitSub64Underflow() async {
        // LoadImm64 r1, 42
        // LoadImm64 r2, 100
        // Sub64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 42
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(42).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 100
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(100).littleEndian) { Array($0) })

        // Sub64: [opcode][ra|rb<<4][rd] where rd = ra - rb
        code.append(PVMOpcodes.sub64.rawValue) // Sub64 opcode
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // Should wrap to UInt64.max - 57
        let expected = UInt64.max - 57
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: expected)
    }

    @Test
    func jitAdd64Parity() async {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 1000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(1000).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 234
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(234).littleEndian) { Array($0) })

        // Add64: [opcode][ra|rb<<4][rd] where rd = ra + rb
        code.append(PVMOpcodes.add64.rawValue) // Add64 opcode
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "Add64",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - AddImm/SubImm Instructions (Opcodes 149-154)

    @Test
    func jitAddImm64() async {
        // LoadImm64 r1, 100
        // AddImm64 r1, 42
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 100
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(100).littleEndian) { Array($0) })

        // AddImm64 r1, r1, 42
        code.append(PVMOpcodes.addImm64.rawValue) // AddImm64 opcode (149)
        code.append(0x11) // packed: ra=r1, rb=r1
        code.append(contentsOf: withUnsafeBytes(of: Int32(42).littleEndian) { Array($0) }) // 32-bit sign-extended immediate

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // r1 should contain 142
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 1), equals: 142)
    }

    @Test
    func jitAddImm64Parity() async {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 1000
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(1000).littleEndian) { Array($0) })

        // AddImm64 r1, r1, 500
        code.append(0x95) // AddImm64 (opcode 149)
        code.append(0x11) // packed: ra=r1, rb=r1
        code.append(contentsOf: withUnsafeBytes(of: Int32(500).littleEndian) { Array($0) }) // 32-bit sign-extended immediate

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "AddImm64",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - Mul64 Instruction (Opcode 202)

    @Test
    func jitMul64() async {
        // LoadImm64 r1, 100
        // LoadImm64 r2, 42
        // Mul64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 100
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(100).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 42
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(42).littleEndian) { Array($0) })

        code.append(0xCA) // Mul64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // r3 should contain 4200
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 4200)
    }

    @Test
    func jitMul64Overflow() async {
        // LoadImm64 r1, 2^40
        // LoadImm64 r2, 2^30
        // Mul64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 2^40
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(1 << 40).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 2^30
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(1 << 30).littleEndian) { Array($0) })

        code.append(0xCA) // Mul64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // 2^40 * 2^30 = 2^70, which overflows 64 bits
        // In 64-bit arithmetic: 2^70 mod 2^64 = 0 (because 2^70 = 2^64 * 2^6)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0)
    }

    @Test
    func jitMul64Parity() async {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 12345
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(12345).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 6789
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(6789).littleEndian) { Array($0) })

        code.append(0xCA) // Mul64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "Mul64",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - Shift Instructions (Opcodes 206-211)

    @Test
    func jitShloL64() async {
        // LoadImm64 r1, 1
        // LoadImm64 r2, 4
        // ShloL64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 1
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(1).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 4
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(4).littleEndian) { Array($0) })

        code.append(0xCF) // ShloL64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // 1 << 4 = 16
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 16)
    }

    @Test
    func jitShloL64LargeShift() async {
        // LoadImm64 r1, 1
        // LoadImm64 r2, 68 (greater than 64)
        // ShloL64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 1
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(1).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 68
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(68).littleEndian) { Array($0) })

        code.append(0xCF) // ShloL64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // 1 << 68 should wrap to 1 << 4 = 16
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 16)
    }

    @Test
    func jitShroR64() async {
        // LoadImm64 r1, 128
        // LoadImm64 r2, 2
        // ShroR64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 128
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(128).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 2
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(2).littleEndian) { Array($0) })

        code.append(0xD0) // ShroR64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // 128 >> 2 = 32
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 32)
    }

    @Test
    func jitSharR64() async {
        // LoadImm64 r1, -128 (as signed)
        // LoadImm64 r2, 2
        // SharR64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, UInt64.max - 127 (signed -128)
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(bitPattern: Int64(-128)).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 2
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(2).littleEndian) { Array($0) })

        code.append(0xD1) // SharR64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // Arithmetic right shift: -128 >> 2 = -32
        // In two's complement: -32 = 0xFFFFFFFFFFFFFFE0
        let expected = UInt64(bitPattern: Int64(-32))
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: expected)
    }

    @Test
    func jitShloL64Parity() async {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 256
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(256).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 3
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(3).littleEndian) { Array($0) })

        code.append(0xCF) // ShloL64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "ShloL64",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - And/Or/Xor Instructions (Opcodes 210-212)

    @Test
    func jitAnd() async {
        // LoadImm64 r1, 0xFF00FF00
        // LoadImm64 r2, 0xFFFF0000
        // And r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0xFF00FF00
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0xFF00_FF00).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 0xFFFF0000
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0xFFFF_0000).littleEndian) { Array($0) })

        code.append(0xD2) // And r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // 0xFF00FF00 & 0xFFFF0000 = 0xFF000000
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0x0000_0000_FF00_0000)
    }

    @Test
    func jitOr() async {
        // LoadImm64 r1, 0xF0
        // LoadImm64 r2, 0x0F
        // Or r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0xF0
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0xF0).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 0x0F
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x0F).littleEndian) { Array($0) })

        code.append(0xD4) // Or r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // 0xF0 | 0x0F = 0xFF
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0xFF)
    }

    @Test
    func jitXor() async {
        // LoadImm64 r1, 0xFF
        // LoadImm64 r2, 0xFF
        // Xor r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0xFF
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0xFF).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 0xFF
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0xFF).littleEndian) { Array($0) })

        code.append(0xD3) // Xor r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // 0xFF ^ 0xFF = 0
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0)
    }

    @Test
    func jitAndParity() async {
        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 0x123456789ABCDEF0
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0x1234_5678_9ABC_DEF0).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 0xFF00FF00FF00FF00
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0xFF00_FF00_FF00_FF00).littleEndian) { Array($0) })

        code.append(0xD2) // And r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let (_, _, differences) = await JITParityComparator.compare(
            blob: blob,
            testName: "And",
        )

        #expect(
            differences == nil,
        )
    }

    // MARK: - Edge Cases

    @Test
    func jitAdd64WithZero() async {
        // LoadImm64 r1, 100
        // LoadImm64 r2, 0
        // Add64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 100
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(100).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 0
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0).littleEndian) { Array($0) })

        code.append(PVMOpcodes.add64.rawValue) // Add64 opcode
        code.append(0x02 | (0x01 << 4)) // ra=2, rb=1 packed
        code.append(0x03) // rd=3

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // r3 should contain 100 (r1 + r2 = 100 + 0)
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 100)
    }

    @Test
    func jitMul64ByZero() async {
        // LoadImm64 r1, 12345
        // LoadImm64 r2, 0
        // Mul64 r3, r1, r2
        // Halt

        var code = Data()

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r1, 12345
        code.append(0x01)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(12345).littleEndian) { Array($0) })

        code.append(PVMOpcodes.loadImmU64.rawValue) // LoadImm64 r2, 0
        code.append(0x02)
        code.append(contentsOf: withUnsafeBytes(of: UInt64(0).littleEndian) { Array($0) })

        code.append(0xCA) // Mul64 r3, r1, r2 (packed: ra=0x01, rb=0x02)
        code.append(0x01 | (0x02 << 4)) // ra=0x01, rb=0x02 packed
        code.append(0x03) // rd=0x03

        code.append(PVMOpcodes.halt.rawValue) // Halt

        let blob = ProgramBlobBuilder.createProgramCode(Array(code))
        let result = await JITInstructionExecutor.execute(blob: blob)

        // r3 should contain 0
        JITTestAssertions.assertRegister(result, Registers.Index(raw: 3), equals: 0)
    }
}
